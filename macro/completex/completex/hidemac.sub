[snippet]
filedelete=//例1.\n//秀丸メール TKInfo.dllを利用\n//WindowsAPIのDeleteFile関数。パラメータ1にファイル名を指定する。\n//削除に成功すると0以外を返す。\n//失敗すると0を返す。\n\tcall HidemaruMail ;\n\t$$file = "d:\\\\a.txt" ;\n\t##n = dllfunc("\vBypass_DeleteFile", $$file);\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n//機能:TKInfo.dllをロードする\n//秀シリーズサポートHPより 抜粋\n\t// DLL を Load する\n\topenreg "CURRENTUSER","Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\n\tif( !result ) {\n\t\tmessage "秀丸メールがインストールされてないです (^^;)\\n"+$info;\n\t\tclosereg ;\n\t\tendmacro;\n\t}\n\n\t$$HomeDIR = getregstr( "TuruKameDir" );\t//最後に"\\"が付いた値\n\tclosereg ;\n\tloaddll $$HomeDIR + "TKInfo.dll";\n\tif( !result ) {\n\tmessage "DLLロードに失敗\\n"+$info;\n\tendmacro;\n\t}\nreturn ;\n\n//例2.\n//田楽DLLを使用したファイル削除( ファイルまたはフォルダを削除します。)\n\tcall Dengaku ;\n\t$$file = "d:\\\\a.txt" ;\n\t##n = dllfunc("REMOVE",$$file);\n\t//ゴミ箱に削除\n\t##n = dllfunc("REMOVE","/g '" + $$file + "'");\n\t//強制的に削除\n\t##n = dllfunc("REMOVE","/f '" + $$file + "'");\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nDengaku:\n\t//\t田楽DLLのロード\n\tif(existfile(hidemarudir+"\\\\DengakuDLL.dll"))loaddll hidemarudir+"\\\\DengakuDLL.dll";\n\telse {\n\t\t$$mes = "田楽DLLが見つかりませんでした。\\n" +\n\t\t\t\t"田楽DLLを秀丸エディタインストールディレクトリにおいてください。\\n" +\n\t\t\t\t"  秀丸エディタインストールディレクトリ:\\n\\t"+hidemarudir + "\\n\\n" +\n\t\t\t\t"田楽DLL ダウンロードURL\\n"+\n\t\t\t\t"  http://www.ceres.dti.ne.jp/~sugiura/hidemaru/macros/dgserver/\\n" + \n\t\t\t\t$info ;\n\t\tmessage $$mes ;\n\t\tgoto LEND ;\n\t}\n\n\tif (!result) {\n\t\tmessage "田楽DLL をロードできませんでした。"+$info;\n\t\tgoto LEND ;\n\t}\nreturn;\n
filecopy=//例1.\n//秀丸メール TKInfo.dllを利用\n//WindowsAPIを使用して、ファイルのcopyを実施します。\n\tcall HidemaruMail ;\n\tif ( !dllfunc("\vBypass_CopyFile", "d:\\\\a.txt", "d:\\\\b.txt") ){\n\t\tmessage "copy ng";\n\t}\n\tif(!result){\n\t\tmessage "Error" ;\n\t\tendmacro;\n\t}\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n//機能:TKInfo.dllをロードする\n//秀シリーズサポートHPより 抜粋\n\t// DLL を Load する\n\topenreg "CURRENTUSER","Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\n\tif( !result ) {\n\t\tmessage "秀丸メールがインストールされてないです (^^;)\\n"+$info;\n\t\tclosereg ;\n\t\tendmacro;\n\t}\n\n\t$$HomeDIR = getregstr( "TuruKameDir" );\t//最後に"\\"が付いた値\n\tclosereg ;\n\tloaddll $$HomeDIR + "TKInfo.dll";\n\tif( !result ) {\n\tmessage "DLLロードに失敗\\n"+$info;\n\tendmacro;\n\t}\nreturn ;\n\n//例2.\n//田楽DLLを使用したファイルcopy( ファイルまたはフォルダをコピーします。)\n\t$$file1 = "d:\\\\a.txt" ;\n\t$$file2 = "d:\\\\b.txt" ;\n\tcall Dengaku ;\n\n\t//すべての上書きを確認してcopy\n\t##n = dllfunc("COPY","/i '" + $$file1 + "'",$$file2) ;\n\t//タイムスタンプで判断して上書きcopy\n\t##n = dllfunc("COPY","/u '" + $$file1 + "'",$$file2) ;\n\t//強制的に上書きcopy\n\t##n = dllfunc("COPY","/f '" + $$file1 + "'",$$file2) ;\n\nLEND:\n\tfreedll;\n\tendmacro; \n\nDengaku:\n\t//\t田楽DLLのロード\n\tif(existfile(hidemarudir+"\\\\DengakuDLL.dll"))loaddll hidemarudir+"\\\\DengakuDLL.dll";\n\telse {\n\t\t$$mes = "田楽DLLが見つかりませんでした。\\n" +\n\t\t\t\t"田楽DLLを秀丸エディタインストールディレクトリにおいてください。\\n" +\n\t\t\t\t"  秀丸エディタインストールディレクトリ:\\n\\t"+hidemarudir + "\\n\\n" +\n\t\t\t\t"田楽DLL ダウンロードURL\\n"+\n\t\t\t\t"  http://www.ceres.dti.ne.jp/~sugiura/hidemaru/macros/dgserver/\\n" + \n\t\t\t\t$info ;\n\t\tmessage $$mes ;\n\t\tgoto LEND ;\n\t}\n\n\tif (!result) {\n\t\tmessage "田楽DLL をロードできませんでした。"+$info;\n\t\tgoto LEND ;\n\t}\nreturn;\n
filemove=//例1.\n//秀丸メール TKInfo.dllを利用\n//WindowsAPIを使用したファイルの移動。\n\tcall HidemaruMail ;\n\t##n = dllfunc( "\vBypass_MoveFile", \t"d:\\\\a.txt" ,\n\t\t\t\t\t\t\t\t\t\t"d:\\\\b.txt" ) ;\nLEND:\n\tfreedll;\n\tendmacro;\n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n//機能:TKInfo.dllをロードする\n//秀シリーズサポートHPより 抜粋\n\t// DLL を Load する\n\topenreg "CURRENTUSER","Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\n\tif( !result ) {\n\t\tmessage "秀丸メールがインストールされてないです (^^;)\\n"+$info;\n\t\tclosereg ;\n\t\tendmacro;\n\t}\n\n\t$$HomeDIR = getregstr( "TuruKameDir" );\t//最後に"\\"が付いた値\n\tclosereg ;\n\tloaddll $$HomeDIR + "TKInfo.dll";\n\tif( !result ) {\n\tmessage "DLLロードに失敗\\n"+$info;\n\tendmacro;\n\t}\nreturn ;\n\n//例2.\n//田楽DLLを使用したmove( ファイルまたはフォルダを移動(または名前を変更)します。)\n\t$$file1 = "d:\\\\a.txt" ;\n\t$$file2 = "d:\\\\b.txt" ;\n\tcall Dengaku ;\n\t//すべての上書きを確認してmove\n\t##n = dllfunc("MOVE","/i '" + $$file1 + "'",$$file2) ;\n\t//タイムスタンプで判断して上書きmove\n\t##n = dllfunc("MOVE","/u '" + $$file1 + "'",$$file2) ;\n\t//強制的に上書きmove\n\t##n = dllfunc("MOVE","/f '" + $$file1 + "'",$$file2) ;\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nDengaku:\n\t//\t田楽DLLのロード\n\tif(existfile(hidemarudir+"\\\\DengakuDLL.dll"))loaddll hidemarudir+"\\\\DengakuDLL.dll";\n\telse {\n\t\t$$mes = "田楽DLLが見つかりませんでした。\\n" +\n\t\t\t\t"田楽DLLを秀丸エディタインストールディレクトリにおいてください。\\n" +\n\t\t\t\t"  秀丸エディタインストールディレクトリ:\\n\\t"+hidemarudir + "\\n\\n" +\n\t\t\t\t"田楽DLL ダウンロードURL\\n"+\n\t\t\t\t"  http://www.ceres.dti.ne.jp/~sugiura/hidemaru/macros/dgserver/\\n" + \n\t\t\t\t$info ;\n\t\tmessage $$mes ;\n\t\tgoto LEND ;\n\t}\n\n\tif (!result) {\n\t\tmessage "田楽DLL をロードできませんでした。"+$info;\n\t\tgoto LEND ;\n\t}\nreturn;\n
mkdir=//例1.\n//秀丸メール TKInfo.dllを利用\n//パラメータ1に作成したいフォルダ名を指定する。\n//成功すると0以外を返す。\n//失敗すると0を返す。\n\tcall HidemaruMail ;\n\t$$dir = "d:\\\\hmml_tmp" ;\n\t##n = dllfunc( "\vBypass_CreateDirectory", $$dir) ;\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n//機能:TKInfo.dllをロードする\n//秀シリーズサポートHPより 抜粋\n\t// DLL を Load する\n\topenreg "CURRENTUSER","Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\n\tif( !result ) {\n\t\tmessage "秀丸メールがインストールされてないです (^^;)\\n"+$info;\n\t\tclosereg ;\n\t\tendmacro;\n\t}\n\n\t$$HomeDIR = getregstr( "TuruKameDir" );\t//最後に"\\"が付いた値\n\tclosereg ;\n\tloaddll $$HomeDIR + "TKInfo.dll";\n\tif( !result ) {\n\tmessage "DLLロードに失敗\\n"+$info;\n\tendmacro;\n\t}\nreturn ;\n\n//例2.\n//田楽DLLを使用したディレクトリ作成( ファイルまたはフォルダを削除します。)\n\tcall Dengaku ;\n\t$$dir = "d:\\\\hmml_tmp" ;\n\t##n = dllfunc("MKDIR",$$dir);\n\t//(もし存在しなければ) 指定された全てのサブフォルダを作成\n\t$$dir = "d:\\\\" + year + "\\\\" + month + "\\\\" + day + "\\\\" + "hmml_tmp" ;\n\t##n = dllfunc("MKDIR","/p '" + $$dir + "'");\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nDengaku:\n\t//\t田楽DLLのロード\n\tif(existfile(hidemarudir+"\\\\DengakuDLL.dll"))loaddll hidemarudir+"\\\\DengakuDLL.dll";\n\telse {\n\t\t$$mes = "田楽DLLが見つかりませんでした。\\n" +\n\t\t\t\t"田楽DLLを秀丸エディタインストールディレクトリにおいてください。\\n" +\n\t\t\t\t"  秀丸エディタインストールディレクトリ:\\n\\t"+hidemarudir + "\\n\\n" +\n\t\t\t\t"田楽DLL ダウンロードURL\\n"+\n\t\t\t\t"  http://www.ceres.dti.ne.jp/~sugiura/hidemaru/macros/dgserver/\\n" + \n\t\t\t\t$info ;\n\t\tmessage $$mes ;\n\t\tgoto LEND ;\n\t}\n\n\tif (!result) {\n\t\tmessage "田楽DLL をロードできませんでした。"+$info;\n\t\tgoto LEND ;\n\t}\nreturn;\n
rmdir=//例1.\n//秀丸メール TKInfo.dllを利用\n//パラメータ1にフォルダのパス名を指定する。(パラメータ2は省略)\n//成功すると0以外を返す。\n//失敗すると0を返す。\n\tcall HidemaruMail ;\n\t$$dir = "d:\\\\hmml_tmp" ;\n\t##n = dllfunc( "\vBypass_RemoveDirectory", $$dir) ;\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n//機能:TKInfo.dllをロードする\n//秀シリーズサポートHPより 抜粋\n\t// DLL を Load する\n\topenreg "CURRENTUSER","Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\n\tif( !result ) {\n\t\tmessage "秀丸メールがインストールされてないです (^^;)\\n"+$info;\n\t\tclosereg ;\n\t\tendmacro;\n\t}\n\n\t$$HomeDIR = getregstr( "TuruKameDir" );\t//最後に"\\"が付いた値\n\tclosereg ;\n\tloaddll $$HomeDIR + "TKInfo.dll";\n\tif( !result ) {\n\tmessage "DLLロードに失敗\\n"+$info;\n\tendmacro;\n\t}\nreturn ;\n\n//例2.\n//田楽DLLを使用したディレクトリ削除(指定された[空の]フォルダを削除します。)\n\tcall Dengaku ;\n\t$$dir = "d:\\\\hmml_tmp" ;\n\t##n = dllfunc("RMDIR",$$dir);\n\t//すべてのディレクトリの削除を確認して実施\n\t##n = dllfunc("RMDIR","/i '" + $$dir + "'");\n\t//強制的に削除\n\t##n = dllfunc("RMDIR","/f '" + $$dir + "'");\n\tLEND:\n\t\tfreedll;\n\t\tendmacro; \n\nDengaku:\n\t//\t田楽DLLのロード\n\tif(existfile(hidemarudir+"\\\\DengakuDLL.dll"))loaddll hidemarudir+"\\\\DengakuDLL.dll";\n\telse {\n\t\t$$mes = "田楽DLLが見つかりませんでした。\\n" +\n\t\t\t\t"田楽DLLを秀丸エディタインストールディレクトリにおいてください。\\n" +\n\t\t\t\t"  秀丸エディタインストールディレクトリ:\\n\\t"+hidemarudir + "\\n\\n" +\n\t\t\t\t"田楽DLL ダウンロードURL\\n"+\n\t\t\t\t"  http://www.ceres.dti.ne.jp/~sugiura/hidemaru/macros/dgserver/\\n" + \n\t\t\t\t$info ;\n\t\tmessage $$mes ;\n\t\tgoto LEND ;\n\t}\n\n\tif (!result) {\n\t\tmessage "田楽DLL をロードできませんでした。"+$info;\n\t\tgoto LEND ;\n\t}\nreturn;\n

dupline=dupline ;\t//行の二重化\n
filter=//標準の変換 第二引数 \n//tozenkakualnum, toupper, ToLower, ToHankaku, ToZenkakuHira, \n//ToZenkakuKata, ToSpace, ToTab, ToHankakuAlnum, ToZenkakuAlnum, \n//ToHankakuKataOnly, ToZenkakuKataOnly, Indent, UnIndent, \nfilter "" , "tozenkakualnum";\n
insert=insert "\v" ;\t//文字列の挿入
insertfix=insertfix "\v" ;\t//文字列の挿入その2
insertline=insertline ;\t//空行挿入
overwriteswitch=if( overwrite ) {\n\toverwriteswitch; insertreturn; overwriteswitch;\n} \nelse {\n\tinsertreturn;\n}\t//上書き/挿入モード切り替え
overwrite=overwrite "\v" ;\t//文字列の上書き
tab=tab ;\t//タブ文字の挿入
undelete=undelete ;\t//削除内容復元
exit=exit ;\t//終了
exitall=exitall ;\t//全終了
newfile=newfile ;\t//ファイルの新規作成
print=print ;\t//印刷
quit=quit ;\t//破棄して終了
save=save ;\t//ファイルの上書き保存
saveexit=saveexit ;\t//保存して終了
saveall=saveall :\t//全保存
saveexitall=saveexitall ;\t//全保存終了
saveupdatedall=saveupdatedall ;\t//全保存（更新ファイルのみ）
savelf=savelf ;\t//上書き保存（改行=LF）
openbyshell=openbyshell//...を開く
openbyhidemaru=openbyhidemaru\t//...を秀丸で開く
appendsave=appendsave "\v" ;\t//別ファイルへの追加保存
changename=changename "\v" ;\t//ファイル名の変更
insertfile=insertfile "\v" ;\t//カーソル位置への読み込み
loadfile=loadfile "\v" ;\t//ファイルを閉じて開く
openfile=openfile "\v" ;\t//ファイルを開く\n//openfile ファイル名 [,sjis | unicode | euc | jis | utf7 | utf8]
readonlyopenfile=readonlyopenfile "\v" ;\t//書換え禁止でファイルを開く
readonlyloadfile=readonlyloadfile "\v" ;\t//書換え禁止でファイルを閉じて開く
saveas=saveas "\v" ;\t//ファイルの名前を付けて保存\n//saveas ファイル名 [,sjis | unicode | euc | jis | utf7 | utf8] [, lf]
freedll=loaddll "sample.dll";\nif(!result ){\n\tmessage "sample.dllのロードに失敗しました。";\n\tendmacro;\n}\n##a =dllfunc("SampleFunc",10 );\nmessage str(##a);\nfreedll;\n
loaddll=loaddll "sample.dll";\nif(!result ){\n\tmessage "sample.dllのロードに失敗しました。";\n\tendmacro;\n}\n##a =dllfunc("SampleFunc",10 );\nmessage str(##a);\nfreedll;\n
APPENDSAVE_dlg=APPENDSAVE ;\t//ダイアログボックスを出す。\n//別ファイルへの追加保存\nif( ! result )  message "Cancelしました";\n
CHANGENAME_dlg=CHANGENAME ;\t//ダイアログボックスを出す。\n//ファイル名の変更\nif( ! result )  message "Cancelしました";
INSERTFILE_dlg=INSERTFILE ;\t//ダイアログボックスを出す。\n//カーソル位置への読み込み\nif( ! result )  message "Cancelしました";
LOAD_dlg=LOAD ;\t//ダイアログボックスを出す。\n//ファイルを閉じて開く\nif( ! result )  message "Cancelしました";
OPEN_dlg=OPEN ;\t//ダイアログボックスを出す。\n//ファイルを開く\n//openfile ファイル名 [,sjis | unicode | euc | jis]\nif( ! result )  message "Cancelしました";
SAVEAS_dlg=SAVEAS ;\t//ダイアログボックスを出す。\n//ファイルの名前を付けて保存\n//saveas ファイル名 [,sjis | unicode | euc | jis] [, lf]\nif( ! result )  message "Cancelしました";
down=down \v ;\t//カーソル下移動
gofileend=gofileend ;\t//ファイルの最後に移動
gofiletop=gofiletop ;\t//ファイルの先頭に移動
gokakko=gokakko ;\t//対応する括弧に移動
golastupdated=golastupdated ;\t//最後に編集した所に移動
goleftkakko=goleftkakko ;\t//'{'に移動
golineend=golineend ;\t//行の最後に移動
golineend2=golineend2 ;\t//論理行末に移動
golineend3=golineend3 ;\t//行末に移動(その２) (V5.05以降) 
golinetop=golinetop ;\t//行の先頭に移動
golinetop2=golinetop2 ;\t//論理行頭に移動
gorightkakko=gorightkakko ;\t//'}'に移動
goscreenend=goscreenend ;\t//画面の最後に移動
goscreentop=goscreentop ;\t//画面の先頭に移動
gowordend=gowordend ;\t//単語の最後に移動
gowordtop=gowordtop ;\t//単語の先頭に移動
halfnextpage=halfnextpage ;\t//半次ページ
halfprevpage=halfprevpage ;\t//半分前ページ
jump=jump \v ;\t//指定行に移動
left=left \v ;\t//カーソル左移動
moveto=moveto \v##x,##y;\t//任意の位置へのカーソル移動\n//パラメタとしてX座標とY座標を指定してください。数値でないといけません。\n//Y座標はファイルの先頭を0として数え,\n//X座標は一番左側の位置を0として数えた値です。
movetolineno=movetolineno \v##x,##y; //任意の位置へのカーソル移動\n//XY座標の代わりに「エディタ的」に計算した行番号と桁番号で\n//カーソルを移動します。\n//桁番号は、タブ文字は1つとして数えた番号です。\n//movetoと違い、桁番号も行番号も1から始まります。
nextfunc=nextfunc ;\t//次の関数に移動
nextpage=nextpage ;\t//次ページ
prevfunc=prevfunc ;\t//前の関数に移動
prevpage=prevpage ;\t//前ページ
right=right \v ;\t//カーソル右移動
rollup=rollup ;\t//スクロールアップ
rollup2=rollup2 ;\t//スクロールアップ2
rolldown=rolldown ;\t//スクロールダウン
up=up \v ;\t//カーソル上移動
wordleft=wordleft ;\t//単語左
wordright=wordright ;\t//単語右
wordrightsalnen=wordrightsalnen ;\t//単語右(サルネン風)
prevpos=prevpos ;\t//前のカーソル位置に移動
setmark=setmark ;\t//現在行のマーク/マーク解除
clearallmark=clearallmark ;\t//マークを全て解除
marklist=marklist ;\t//マーク一覧
nextmark=nextmark ;\t//マーク行の下検索
prevmark=prevmark ;\t//マーク行の上検索
clist=clist ;\t//強調の一覧
selectcfunc=selectcfunc ;\t//強調行の範囲選択
appendcopy=appendcopy ;\t//追加複写
appendcut=appendcut ;\t//追加切り抜き
beginrect=beginrect ;\t//BOX範囲選択開始
beginsel=beginsel ;\t//範囲選択開始
pasterect=pasterect ;\t//BOX貼り付け
copy=copy ;\t//複写
copy2=copy2 ;\t//コピー(範囲選択はそのまま)
copyline=copyline ;\t//行を複写
copyword=copyword ;\t//単語を複写
cut=cut ;\t//切り抜き
escape=escape ;\t//範囲選択を取り消す
paste=paste ;\t//貼り付け
refcopy=refcopy ;\t//引用付き複写
selectall=selectall ;\t//すべてを選択
selectline=selectline ;\t//行の選択
selectword=selectword ;\t//単語の選択
showcliphist=showcliphist ;\t//クリップボード履歴の表示
poppaste=poppaste ;\t//貼り付け+履歴戻し
getcliphist=getcliphist ;\t//クリップボード履歴からの取り出し
clearcliphist=clearcliphist ;\t//クリップボード履歴の消去
setclipboard=//式の値をクリップボードに設定します。\nsetclipboard $$a;\n//改行も含めてクリップボードに入れたい場合は\n//下記のように使う必要があります。\nsetclipboard $$a +"\\x0D\\x0A";\n
backspace=backspace ;\t//Backspace
delete=delete ;\t//Del
deleteafter=deleteafter ;\t//カーソルより後ろを削除
deletebefore=deletebefore ;\t//カーソルより前を削除
deleteline=deleteline ;\t//行削除
deleteword=deleteword ;\t//単語の削除(カーソルの後ろだけ)
deletewordall=deletewordall ;\t//単語の削除(全部)
deletewordfront=deletewordfront ;\t//単語の削除(カーソルより前の部分だけ)
tindent=if(selecting==1){\n\tindent ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}
tunindent=if(selecting==1){\n\tunindent ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}
casechange=casechange ;\t//大文字/小文字の変換
redo=redo ;\t//やり直しのやり直し
reopen=reopen ;\t//編集のやり直し
tab_indent=if(selecting==1){\n\ttab ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//選択範囲のタブによるインデント
shifttab=shifttab ;\t//行選択の補完
tohankaku=if(selecting==1){\n\ttohankaku ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//半角文字に変換
tolower=if(selecting==1){\n\ttolower ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//小文字に変換
tospace=if(selecting==1){\n\ttospace ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//タブ->空白変換
totab=if(selecting==1){\n\ttotab ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//空白->タブ変換
toupper=if(selecting==1){\n\ttoupper ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//大文字に変換
tozenkakuhira=if(selecting==1){\n\ttozenkakuhira ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//全角ひらがなに変換
tozenkakukata=if(selecting==1){\n\ttozenkakukata ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n//全角カタカナに変換
undo=undo ;\t//やり直し
capslockforgot=capslockforgot ;\t//CapsLockしわすれの是正
imeconvforgot=imeconvforgot ;\t//かな漢字変換しわすれの是正
finddown=finddown ;\t//下候補
findup=findup ;\t//上候補
getsearch=getsearch ;\t//検索文字列の取得
gosearchstarted=gosearchstarted ;\t//検索開始位置へ戻る
searchdown=searchdown \v$$1,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//下方向検索
searchup=searchup \v$$1,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//上方向検索
replacedown=replacedown \v$$1 ,$$2 ,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//下方向置換
replaceup=replaceup \v$$1 ,$$2 ,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//上方向置換
replaceall=replaceall \v$$1 ,$$2 ,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//全置換
replaceallfast=$$1 = "" ;\n$$2 = "" ;\nreplaceallfast \v$$1 ,$$2 ,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//高速全置換
setsearch=setsearch "\v", 0;\t//setsearch 文字列, フラグ\n//秀丸が内部で保持している検索バッファの内容を設定します
searchbuffer=$$wk = searchbuffer ;\t//検索バッファの内容を表します。\n//検索バッファは、以前に実行された検索コマンドまたは\n//置換コマンドで検索対象となる文字列を記憶していて、\n//「次候補」または「前候補」コマンドで利用されるものです。
searchoption=##so = \vsearchoption \n//\t0x0001 | //単語の検索(ビット0)\n//\t0x0002 | //大文字/小文字の区別(ビット1)\n//\t0x0004 | //置換かどうか(ビット2)(置換の場合に1)\n//\t0x0008 | //置換の場合、問い合わせの有無(ビット3)\n//\t0x0010 | //正規表現(ビット4)\n//\t0x0020 | //あいまい検索(ビット5)\n//\t0x0040 | //ファイル名一覧だけ作成(ビット6)(grep用)\n//\t0x0080 | //次の秀丸も続けて検索\t(ビット7)\n//\t0x0100 | //サブフォルダも検索\t(ビット8)(grep用)\n//\t0x0200 | //最小化状態で実行\t(ビット9)(grep用)\n//\t0x0400 | //ファイル名をフルパスで出力\t(ビット10)(grep用)\n//\t0x0800 | //検索文字列の強調\t(ビット11)(検索,grep用)\n//\t0x1000 | //検索文字列の強調\t(ビット12)(置換用)\n//\t0x2000 | //検索文字列の強調を変更\t(ビット13)\n//\t0x0000 ;\n//検索フラグは、以前に実行された検索コマンドまたは\n//置換コマンドのダイアログボックスで指定された各種\n//のオプションを記憶しています。\n//参照:setsearch\n
goupdatedown=goupdatedown ;\t//編集マークの下検索
goupdateup=goupdateup ;\t//編集マークの上検索
clearupdates=clearupdates ;\t//編集マークのクリア
grep=grep "\v","*.txt",".";\t//grepの実行(パラメタ付き)\n//grep 検索文字列, 検索するファイル, カレントフォルダ \n//[,word] [,casesense] [,regular] [,fuzzy] [,subdir] [,icon] [,filelist]\n//grep "##include", "*.cpp;*.c", ".", regular;
grepdialog=grepdialog ;\n//grepdialog文は、「grepの実行...」のダイアログボックスを出します。\n//ちなみにgrepdialog文を実行すると、現在の秀丸が新規作成状態でない場合\n//は新規に秀丸エディタが立ち上がります。
localgrep=localgrep "\v",regular;\t//現在の内容からgrepを実行\n//localgrep文は、現在の内容を対象にしてgrepを実行します。\n//パラメタは以下のように指定してください。\n//localgrep 検索文字列 [,word] [,casesense] [,regular] [,fuzzy] [,icon]
nexthidemaru=nexthidemaru ;\t//次の秀丸
prevhidemaru=prevhidemaru ;\t//前の秀丸
nexthidemaruicon=nexthidemaruicon ;\t//次の秀丸(アイコンも含む)
prevhidemaruicon=prevhidemaruicon ;\t//前の秀丸(アイコンも含む)
restoredesktop=restoredesktop ;\t//デスクトップ復元
savedesktop=savedesktop ;\t//デスクトップ保存
scrolllink=scrolllink ;\t//他の秀丸と同時スクロール
split=split ;\t//ウィンドウを2つに分割
splitswitch=splitswitch ;\t//分割ウィンドウ切り替え
windowcascade=windowcascade ;\t//秀丸を重ねて表示
windowhorz=windowhorz ;\t//秀丸を横に並べる
windowtiling=windowtiling ;\t//秀丸を並べて表示
windowvert=windowvert ;\t//秀丸を縦に並べる
windowlist=windowlist ;\t//ウィンドウ一覧表示
compfile=compfile ;\t//他の秀丸と内容比較
backtagjump=backtagjump ;\t//バックタグジャンプ
directtagjump=directtagjump ;\t//ダイレクトタグジャンプ
freecursorswitch=freecursorswitch ;\t//フリーカーソルモードの切り替え
imeswitch=imeswitch ;\t//かな漢字変換の切り替え
imeregisterword=imeregisterword ;\t//かな漢への単語登録
help=help ;\t//外部ヘルプ
help2=help2 ;\t//外部ヘルプ2
help3=help3 ;\t//外部ヘルプ3
msdnlibrary=msdnlibrary ;\t//MSDNライブラリ
hidemaruhelp=hidemaruhelp ;\t//秀丸ヘルプ
macrohelp=macrohelp ;\t//秀丸マクロヘルプ
readonlyswitch=readonlyswitch ;\t//ファイルの書換え禁止/許可の切り替え
showcode=showcode ;\t//カーソルの文字コードの表示
showlineno=showlineno ;\t//行番号の表示/非表示
tagjump=tagjump ;\t//タグジャンプ
redraw=redraw ;\t//秀丸ウィンドウの再描画
browsemodeswitch=browsemodeswitch ;\t//閲覧モードの切り替え
message=//メッセージ系\nmessage \v ;\t//メッセージボックスを出します。\n//パラメタでメッセージの文字列を指定します。\n//数値型の値は文字列型に変換して指定してください。
question=//メッセージ系\nquestion "\v" ;\nif( result == yes ) {\n\t\n}\n// 質問のメッセージを出します。メッセージボックスには「はい」と\n//「いいえ」のボタンがあります。\n//question "これでいいですか?";\n
beep=//メッセージ系\nbeep ;\t//beep文は,ピッという音を出します。
play=//メッセージ系\nplay "\v" ;\t//play文は、パラメタで指定されたWAVファイルを再生します。\n//play文はWAVファイルの再生の終了を待たずにマクロの実行を継続します。\n//play "d:\\windows\\chord.wav";
playsync=//メッセージ系\nplaysync "\v" ;\t//playsync文は、パラメタで指定されたWAVファイルを再生します\n//playsync文はWAVファイルの再生が終了するまで待ちます。\n//playsync "d:\\windows\\chord.wav";
title=//メッセージ系\ntitle "\v";\n//title文の種類:\n//title 文字列  キャプションの設定\n//title  0      現在の秀丸のキャプションを元に戻す\n//title  1      すべての秀丸のキャプションを元に戻す\n//title -1      現在設定されているキャプションをマクロ終了時も残す
run=//プログラム実行系\nrun "\v";\t//他のプログラムを実行します。\n//run "winfile.exe";\n// run文はプログラムを起動したあとで,すぐにマクロの実行を続行します。
runsync=//プログラム実行系\nrunsync "\v" ;\n//runsync "cl -c -AS -G2scw -W3 " + $$filename ;\n//runsync文はrunと同様にプログラムを実行しますが,\n//runと異なる点は起動したコマンドが終了するまでマクロの実行を待機させる\n//点です。runsyncは秀丸をアイコン状態にして待機させます
runsync2=//プログラム実行系\nrunsync2 "\v" ;\n//runsync2 "cl -c -AS -G2scw -W3 " + $$filename ;\n//rynsync2文はrunと同様にプログラムを実行しますが,\n//runと異なる点は起動したコマンドが終了するまでマクロの実行を待機させる\n//点です。runsync2は秀丸をアイコンにせずに待機させます。
endmacro=endmacro ;\t//現在のマクロの実行を終了します。
endmacroall=endmacroall ;\n//execmacroの呼び出し元も含めてすべてのマクロの実行を終了させます。
execmacro=execmacro "\v" ;\t//マクロの中から、さらに別のマクロを実行します。\n//execmacro "test.mac";
disabledraw=disabledraw ;\t//画面の書き換えを禁止します。
enabledraw=enabledraw ;\t//画面書き換えを許可します。
disablebreak=disablebreak ;\t//マクロの中断を禁止します。
disableinvert=disableinvert ;\t//範囲選択のときの反転表示を禁止します。
enableinvert=enableinvert ;\t//disableinvertを解除します。
if=if(result == \v){\n\t\n}\nelse{\n\t\n}
while=//while文\n//その直後にある条件式の値が0以外である間,処理をくりかえします。\n//ブロックと組み合わせて使用できます｡\n//break文 ,continue文 との併用も可能です｡\n##i = 0;\nwhile( ##i < 10 ) {\n\tmessage "count=" + str(##i);\n\t##i = ##i + 1;\n}\n
break=break ;\t//whileのループの中から強制的に外に出ます。
continue=continue ;\t//while文の先頭まで戻って条件式の評価からやりなおします。
goto=goto \vlabel ;\nlabel:\n//飛びたい先にラベルを置いておき,\n//gotoでそのラベルを指定するとそこに飛びます。
call=call sub \v$$par1 ,$$par2 ;\n$$ret = $$return ;\n\nsub:\n//引数渡し\n$$wk1 = $$1;$$wk2 = $$2;\n//処理\n//サブルーチン処理を記述\n//引数戻し指定\nreturn $$wk2;
disableerrormsg=disableerrormsg ;\n//各種のコマンドの中でエラーが発生しても\n//エラーメッセージを表示しないようにします。
enableerrormsg=enableerrormsg ;\n//エラーメッセージを表示するようにします。
inputpos=inputpos "カーソル位置を入力してください";\n//ユーザからカーソル位置を入力してもらうための文です。\n//inputpos "削除の開始位置を指定してください。";\n##startx = x;\n##starty = y;
menu=menu "選択0", "選択1", "選択2";\nif( result == 0 ) {\n\tendmacro ;\n}\nelse if( result == 1 ) {\n\tmessage "選択0";\n} \nelse if( result == 2 ) {\n\tmessage "選択1";\n} else {\n\tmessage "選択2";\n}
mousemenu=mousemenu "選択0", "選択1", "選択2";\nif( result == 0 ) {\n\tendmacro ;\n}\nelse if( result == 1 ) {\n\tmessage "選択0";\n} \nelse if( result == 2 ) {\n\tmessage "選択1";\n} else {\n\tmessage "選択2";\n}
menuarray=$$a[0] = "sel0" ;\n$$a[1] = "sel1" ;\n$$a[2] = "sel2" ;\nmenuarray $$a, \v3;\nif( result == 0 ) {\n\tendmacro ;\n}\nelse if( result == 1 ) {\n\tmessage "選択0";\n} \nelse if( result == 2 ) {\n\tmessage "選択1";\n} else {\n\tmessage "選択2";\n}
mousemenuarray=$$a[0] = "sel0" ;\n$$a[1] = "sel1" ;\n$$a[2] = "sel2" ;\nmousemenuarray $$a, \v3;\nif( result == 0 ) {\n\tendmacro ;\n}\nelse if( result == 1 ) {\n\tmessage "選択0";\n} \nelse if( result == 2 ) {\n\tmessage "選択1";\n} else {\n\tmessage "選択2";\n}
input=$$wk = "文字列を入力してください";\n$$wk = input($$wk);\nmessage $$wk ;
inputchar=##key = inputchar( "A-Z, 0-9, Esc/終了" );\nmessage "キャラクタ="+char(##key)+","+"文字コード="+str(##key);\n//inputchar( s1 ) 関数\n//s1をタイトルバーに表示し,ユーザから文字を入力してもらい,\n//その文字コードを返します。
iskeydown=if( iskeydown(0x25) ) {\n\tmessage "カーソル左が入力されました";\n}\n//iskeydown( n1 ) 関数
writeinistr=$$ini = hidemarudir + "\\\\" + "cmd.ini";\nwriteinistr \v$$ini, "Command", "RefMark", ">" ;\n//INIファイルにデータを書きこむ文です。\n//writeinistr INIファイル名, セクション名, キー名, 文字\n//writeinistr "HIDEMARU.INI", "Option", "RefMark", ">> ";
writeininum=$$ini = hidemarudir + "\\\\" + "cmd.ini";\nwriteininum \v$$ini, "Command", "count", 10 ;\n//INIファイルにデータを書きこむ文です。\n//writeinistr INIファイル名, セクション名, キー名, 数値\n//writeininum "HIDEMARU.INI", "Option", "count", ##a + 10;
getinistr=$$ini = hidemarudir + "\\\\" + "cmd.ini";\n$$mac_path = getinistr($$ini,"Command","RefMark");\n//INIファイルから文字列を取りだします。\n//getinistr( s1, s2, s3 )\n//s1がiniファイル名、s2がセクション名、s3がキー名です。
getininum=$$ini = hidemarudir + "\\\\" + "cmd.ini";\n##count = getininum($$ini,"Command","count");\n//INIファイルから数値を取りだします。\n//getininum( s1, s2, s3 )\n//s1がiniファイル名、s2がセクション名、s3がキー名です。
openreg=openreg "CURRENTUSER", "\vSoftware\\\\Hidemaruo\\\\Hidemaru\\\\Env";\nif(!result){message "レジストリーをopen出来ませんでした!" ;endmacro;}\n//レジストリをopenします\n//第1パラメタでルートとなるキー名を指定し\n//第2パラメタでサブキー名を指定します
createreg=createreg "CURRENTUSER", "\vSoftware\\\\Hidemaruo\\\\Hidemaru\\\\Env";\nif(!result){message "レジストリをopen出来ませんでした!" ;endmacro;}\n//レジストリをopenします\n//第1パラメタでルートとなるキー名を指定し\n//第2パラメタでサブキー名を指定します
closereg=closereg ;\t//オープンしたレジストリをクローズします。
deletereg=deletereg "CURRENTUSER", "Software\\\\Hidemaruo\\\\Hidemaru\\\\Default\\\\Orikaeshi";\n//レジストリのキーを削除します。\n//第一パラメタでルートとなるキー名を指定し、\n//第2パラメタでサブキー名を指定します。
writeregstr=writeregstr "\vPath", "c:\\users\hm32" ;\n//レジストリに値を書き込みます。\n//第一パラメタで値の名前を指定し、\n//第二パラメタで値を指定します。\n//writeregstr文はREG_SZ型の値を書き込みます
writeregnum=writeregnum "\vCache", 0;\n//レジストリに値を書き込みます。\n//第一パラメタで値の名前を指定し、\n//第二パラメタで値を指定します。\n//writeregnum文はREG_DWORD型の値を書き込みます
getregstr=$$s = getregstr( "\vPath" );\n//オープンされたレジストリから値を取り出して\n//指定された変数に代入します。\n//getregstr( s1 )関数:s1に値の名前を指定します。\n//返す値は文字列型です。
getregnum=##n = getregnum( "\vCount" );\n//オープンされたレジストリから値を取り出して\n//指定された変数に代入します。\n//getregnum( s1 )関数:s1に値の名前を指定します。\n//返す値は数値型です。
config=config "\vr+";\t//\n//config文は,秀丸の各種の設定を変更します。\n//設定の内容を文字列で指定してください。\n//r+  r- フリーカーソルモードを指定します。\n//       +でフリーカーソルモードです。
loadkeyassign=loadkeyassign "\v.key";\n//キー割り当てファイルを読込みます。\n//パラメタでキー割り当てファイルの名前を指定してください。\n//loadkeyassign "default.key";
envchanged=envchanged ;\n//レジストリから「設定・動作環境」の内容を再読込みし、現在の秀丸の動作環境を変更します
setwindowsize=setwindowsize \v80, 20 ;\n//現在のウィンドウサイズを文字数単位で指定します。\n//setwindowsize 80, 20  といった風に使います。\n//この場合は横80桁×縦20行となります。
setwindowpos=setwindowpos \v100, 200 ;\n//現在のウィンドウをパラメタで指定された位置に移動します。\n//パラメタを2つ指定した場合はウィンドウの左上の位置を指定できます。\n//setwindowpos 100, 200;\n//setwindowpos 100, 100, 300, 300;
showwindow=showwindow 1;\n// 現在のウィンドウをパラメタで指定された状態で表示/非表示します
loadhilight=loadhilight "\v.hilight";\n//パラメータで指定された強調表示ファイルを読み込み,\n//画面を最描画します。\n//loadkeyassign "C-language.hilight";
filename=$$file = filename ;\n//現在編集中のファイル名をドライブ文字も含めた\n//フルパスで表します。\n//ファイル名はすべて小文字に変換されています。
basename=$$file = basename ;\n//ファイル名の、パスを含まない、ベース名だけを\n//表します。すべて小文字に変換されています。
directory=$$file = directory ;\n//カレントフォルダをドライブ名も含めたパス名で表します。\n//ルートフォルダでない場合は最後に「\」が付いていません。\n//すべて小文字です。
hidemarudir=$$file = hidemarudir ;\n//hidemaru.exeのフォルダを表します。すべて小文字です。
windir=$$file = windir ;\n//Windowsのフォルダを表します。
winsysdir=$$file = winsysdir ;\n//Windowsのシステムフォルダを表します。
filename2=$$file = filename2 ;\n//filenameの小文字に変換しないバージョンです。
basename2=$$file = basename2 ;\n//basenameの小文字に変換しないバージョンです。
directory2=$$file = directory2 ;\n//directoryの小文字に変換しないバージョンです。
filename3=$$file = filename3 ;\n//filenameの短縮ファイル名バージョンです。
basename3=$$file = basename3 ;\n//basenameの短縮ファイル名バージョンです。
directory3=$$file = directory3 ;\n//directoryの短縮ファイル名バージョンです。
linelen=##wk = linelen ;\n//現在のカーソル位置の行の長さを表します。\n//この値は画面上での1行の長さで、右端で折り返している場合は、\n//行頭から折り返している位置までの長さだけ計算します。\n//タブ文字も、画面上での文字数として計算します。
linelen2=##wk = linelen2 ;\n//現在のカーソル位置の行の、エディタ的に計算した長さを返します。\n//つまり、論理行頭から改行文字(または[EOF])までの文字数を計算します。\n//タブ文字は1文字として計算します。
selecting=if(selecting==1){\v} ;\n//範囲選択中かどうかを表します。\n//範囲選択中の場合は1、そうでない場合は0です。
rectselecting=if(rectselecting==1){\v} ;\n//BOX範囲選択中かどうかを表します。\n//範囲選択中の場合は1、そうでない場合は0です。
seltopx=##s_topx = seltopx ;//範囲選択開始位置のx座標を表します。\n##s_topy = seltopy ;//範囲選択開始位置のy座標を表します。\n##s_endx = selendx ;//範囲選択終了位置のx座標を表します。\n##s_endy = selendy ;//範囲選択終了位置のy座標を表します。
seltopy=##s_topy = seltopy ;//範囲選択開始位置のy座標を表します。
selendx=##s_endx = selendx ;//範囲選択終了位置のx座標を表します。\n##s_endy = selendy ;//範囲選択終了位置のy座標を表します。
selendy=##s_endy = selendy ;//範囲選択終了位置のy座標を表します。
windowwidth=##wk = windowwidth ;\n//ウィンドウの横幅を文字数で表します。\n//左側の余白やスクロールバーなどの外側の部分は含まれていません。\n//行番号表示がonの場合はその部分を含んでいます。
windowheight=##wk = windowheight ;\n//ウィンドウの高さを文字数で表します。\n//キャプションやメニューなどの外側の部分は含まれていません。
windowcx=##wk = windowcx ;\n//ウィンドウ全体の横幅をピクセル単位で表します。
windowcy=##wk = windowcy ;\n//ウィンドウ全体の高さをピクセル単位で表します。
windowposx=##wk = windowposx ;\n//ウィンドウの左上の位置のx座標をピクセル単位で表します。
windowposy=##wk = windowposy ;\n//ウィンドウの左上の位置のy座標をピクセル単位で表します。
splitstate=##wk = splitstate ;\n//ウィンドウの分割の状態を表します。分割されてない場合は0、\n//分割されていて、カーソルが上側にある場合は1、\n//カーソルが下側にある場合は2です。
windowstate=##wk = windowstate ;\n//ウィンドウの表示の具合を表します。\n//非表示の場合は0、通常の表示状態の場合は1、\n//アイコン化されている場合は2、最大化されている場合は3です。
cxscreen=##wk = cxscreen ;\n//画面の横サイズをピクセル単位で表します。
cyscreen=##wk = cyscreen ;\n//画面の縦サイズをピクセル単位で表します。
xworkarea=##wk = xworkarea ;\n//画面の作業領域(タスクバーやOfficeショートカットバーを除いた領域)\n//の左上の位置のx座標をピクセル単位で表します。
yworkarea=##wk = yworkarea ;\n//画面の作業領域の左上の位置のy座標をピクセル単位で表します。
cxworkarea=##wk = cxworkarea ;\n//画面の作業領域の横サイズをピクセル単位で表します。
cyworkarea=##wk = cyworkarea ;\n//画面の作業領域の縦サイズをピクセル単位で表します。
overwrite_state=##wk = overwrite ;\nif(##wk==1){message "上書きモードです" ;};\n//上書きモードか挿入モードかを表します。\n//上書きモードの場合は1、挿入モードの場合は0です。
updated=##wk = updated ;\nif(##wk==1){message "更新されています" ;};\n//更新されたかどうかを表します。\n//更新された場合は1、そうでない場合は0です。
anyclipboard=##wk = anyclipboard ;\nif(##wk==1){message "クリップボードに文字列があります" ;};\n//クリップボードに文字列があるかどうかを表します。\n//ある場合は1、無い場合は0です。
imestate=##wk = imestate ;\nif(##wk==1){message "かな漢字変換on" ;};\n//かな漢字変換の状態を表します。\n//かな漢字変換がonなら1、offなら0です。
browsemode=##wk = browsemode ;\nif(##wk==1){message "閲覧モード" ;};\n//閲覧モードかどうかを表します。\n//閲覧モードの場合は1、そうでない場合は0です。
keypressed=##wk = keypressed ;\nif(##wk!=0){message "キーが押された" ;};\n//キーが押されたかどうかを表します。\n//disablebreakされた状態でのみ利用可能です。\n//キーが押されていた場合はそのキーコード、押されてなかった場合は0です。
replay=##wk = replay ;\nif(##wk==1){message "連続実行中" ;};\n//現在のマクロが連続実行されてるものかどうかを表します。\n//連続実行である場合1、そうでない場合0です。\n
hidemarucount=##wk = hidemarucount ;\nif(##wk==1){message "起動されている秀丸の数:"+str(##wk) ;};\n//現在起動されている秀丸の数を表します。常駐秀丸は数えません。
readonly=##wk = readonly ;\nif(##wk==1){message "上書き禁止" ;};\n//上書き禁止かどうかを表します。\n//上書き禁止の場合は1、そうでない場合は0です。
charset=##wk = charset ;//現在の文字コードと改行を表します。\n//ビット0〜ビット5(charset & 63 した値)が文字コードです。\n//新規作成直後(SHIFT-JIS)\t0\n//SHIFT-JIS\t1\n//Unicode\t2\n//EUC\t3\n//JIS\t4\n//bit6が1の場合、改行=LF\n//bit7が1の場合、改行=CR
freecursor=##wk = freecursor ;\nif(##wk==1){message "フリーカーソルモード" ;};\n//フリーカーソルモードかどうかを表します。
tabcount=##wk = tabcount ;\nmessage "タブの文字数:"+str(##wk) ;\n//タブの文字数を表します。2、4、8のいずかの値になります。
width=##wk = width ;//折り返し文字数を返します。\nmessage "折り返し文字数:"+str(##wk) ;
indentstate=##wk = indentstate ;\n//インデントの状態を表します。\n//インデント無しなら0、普通のインデントなら1、\n//全角インデントなら3、C言語インデントなら5、\n//全角インデント&C言語インデントなら7です。
kinsokustate=##wk = kinsokustate ;//禁則処理がonかどうかを表します。
hilightstate=##wk = hilightstate ;\n//C言語キーワード強調表示がonかどうかを表します。
linespace=##wk = linespace ;\nmessage "行間:"+str(##wk) ;\n//行間の広さを表します。行間無しなら0、1/10なら1、\n//1/8なら2、1/6なら3、1/4なら4、1/3なら5、1/2なら6です。
linenostate=##wk = linenostate ;//行番号の表示がonかどうかを表します。\nmessage "行番号の表示:"+str(##wk) ;
pagestate=##wk = pagestate ;//ページ番号の表示がonかどうかを表します。\nmessage "ページ番号の表示:"+str(##wk) ;
showtab=##wk = showtab ;//タブ文字を表示するかどうかを表します。\nmessage "タブ文字の表示:"+str(##wk) ;
tcolor=##wk = tcolor ;\nif(##wk == 0x00FFFFFF) {message "文字の色は白です";};\n//文字の色をRGB値で表します。\n//例えば白なら0x00FFFFFF、黒なら0になります。\n//具体的な色と値の対応は自分でサンプルマクロを作るなどして調べてください。
bcolor=##wk = bcolor ;//背景の色をRGB値で表します。
lcolor=##wk = lcolor ;\nif(##wk==-1){message "下線無し" ;};\n//カーソル行の下線の色を表します。\n//下線が無い場合は-1となります。
ccolor=##wk = ccolor ;\n//カーソル行の色を表します。\n//カーソル行が色指定ではなく下線指定の場合は-1となります。\nif(##wk==-1){message "カーソル行の色指定は、下線です。" ;};
rcolor=##wk = rcolor ;//改行文字の色を表します。
fontname=$$wk = fontname ;//フォントのフェース名を表します。\nmessage "フォント名:"+$$wk ;
fontsize=##wk = fontsize ;\nmessage "フォントサイズ:"+str(##wk) ;\n//フォントのサイズ(高さ)を表します。単位はピクセル数(ドット数)です。
boldstate=##wk = boldstate ;//太文字かどうかを表します。\nif(##wk==1)message "太文字です";
backup=##wk = backup ;//バックアップファイルの作成がonかどうかを表します。\nif(##wk==1){message "バックアップ作成on" ;}
showruler=##wk = showruler ;//ルーラー表示がonかどうかを表します。\nif(##wk == 1){message "ルーラー表示";}
tabruler=##wk = tabruler ;\n//ルーラー表示が8単位のとき1、10単位のとき0になります。\nif(##wk==0){message "ルーラー表示=10単位";}
rulercolor=##wk = rulercolor ;\nif(##wk==-1){message "ルーラーと文字は同じ色です" ;}\n//ルーラーの色をRGB値で表します。\n//文字と同じの場合は-1になります。
rulerbackcolor=##wk = rulerbackcolor ;\nif(##wk==-1){message "背景色とルーラーの背景色は同じ色です" ;}\n//ルーラーの背景の色をRGB値で表します。\n//背景と同じの場合は-1になります。
correctlineno=##wk = correctlineno ;\nif(##wk==0){message "行番号計算方法=ワープロ";}\n//行番号の計算方法がエディタ的のとき1になります。\n//ワープロ的の場合は0になります。
ignoreeof=##wk = ignoreeof ;//読込むときにEOFを無視するかどうか。\nif(##wk==1){message "読込むときにEOFを無視" ;};
savewitheof=##wk = savewitheof ;//保存するときにEOFを付けるかどうか。\nif(##wk==0){message "保存するときにEOFを付けない" ;} ;
hilighttitle=$$wk = hilighttitle ;\nmessage "強調ファイル名:"+$$wk;\n//強調表示ファイルのファイル名(直前に保存/読込みされた\n//強調表示ファイル)を返します。
getclipboard=beginclipboardread;\n##i = 0;\n$$a[##i] = getclipboard;\nwhile( $$a[##i] != "" ) {\n\t##i = ##i + 1;\n\t$$a[##i] = getclipboard;\n}\n//クリップボードから1行分の文字列を取り出して、それを表します。
date=$$wk = date ;\nmessage "今日の日付:"+$$wk;\n//現在の日付を表します。\n//"92/10/22(月)"のような文字列形式で返します。
time=$$wk = time ;\nmessage "現在の時刻:"+$$wk;\n//現在の時刻を表します。\n//"22:30:45"のような文字列形式で返します。
tickcount=##wk = tickcount ;\nmessage "windows起動からの経過時間:"+str(##wk)+"[ms]";\n//Windowsが起動されてからの経過時間をミリ秒単位で表します。
leftstr=$$wk = leftstr( $$s1, ##n1 ) \n//s1の左側のn1文字を返します。全角文字は2文字として数えます。\n//str1の長さがnum1より小さい場合は,str1がそのまま返されます。\n//返す値は文字列型です。
rightstr=##wk = rightstr(\v,1);\n//##wk = rightstr( s1, n1 ) ;\n//文字列の右側部分\n//s1の右側のn1文字を返します。\n//s1の長さがn1より小さい場合は,s1がそのまま返されます。\n//返す値は文字列型です。
midstr=$$wk = midstr( $$s1, ##n1, ##n2 ) ;\n//s1の左側からn1番目のn2文字を返します。\n//n1は0から数えてください。\n//n1が0の場合はleftstr(s1,n2)と同じ結果となります。\n//返す値は文字列型です。
strlen=##wk = strlen(\v) ;\n//文字列の長さ\n//##wk = strlen( s1 ) ;\n//str1の長さを返します。返す値は数値型です。
gettext=$$wk = gettext( seltopx,seltopy,selendx,selendy ) ;\n$$wk = gettext( ##x, ##y, ##x2, ##y2 ) ;\n##select_keep = 1;\n$$wk = gettext( ##x, ##y, ##x2, ##y2,##select_keep ) ;\n//gettext( x1, y1, x2, y2, n1 ) 関数\n//文字列取り込み\n//x1,y1からx2,y2の範囲にある文字列を返します。\n//x,y座標の指定のしかたはmoveto文と同じです。\n//返す値は文字列型です。\n//第5パラメタ n1 に 1 を指定すると、範囲選択を維持することができます。\n
char=$$wk = char(\v) ;\n//数値から文字への変換\n//n1の文字コードの文字を文字列にして返します。\n//char( 0x41 )        … "A"が返ってきます。\n//$$wk = char( n1 ) ;
ascii=##wk = ascii(\v);\n//##wk = ascii( s1 ) ;\n//文字から数値への変換\n//s1の先頭の文字の文字コード(数値)を返します。\n//charと逆の関数です。
str=##wk = str(\v) ;\n//##wk = str( n1 ) ;\n//数値を文字列に変換\n//n1を文字列に変換します。\n//例えばn1が100の場合,返す値は"100"となります。
val=##wk = val(\v) ;\n//##wk = val( s1 ) ;\n//文字列を数値に変換\n//s1を数値に変換します。\n//例えばs1が"100"の場合,返す値は100となります。
strstr=##i = strstr($$wk,$$2);\n//str1からstr2を検索し,見つかった場合はその位置を返します。\n//先頭が0です。見つからなかった場合は-1を返します。 返す値は数値型です。\nif(##i == -1){\n\tmessage "Not Found!";endmacro ;\n}
getenv=$$path = getenv("path");\n//##wk = getenv( s1 ) ;\n//DOS環境変数の取得\n//str1に対応する環境変数の値を返します。\n//$$path = getenv( "include" );
findhidemaru=##wk = findhidemaru( hidemarudir + "\\\\" + \v$$kwdfile ) ;\n//##wk = findhidemaru( s1 ) ;\n//秀丸の検索\n//ファイル名で指定して秀丸がいるかどうかを調べ、\n//いる場合はそのウィンドウの番号を返します。
hidemaruorder=##order = hidemaruorder( ##handle );\n//##wk = hidemaruorder( n1 ) ;\n//秀丸の番号の取得\n//hidemaruhandleの逆で、ハンドルからウィンドウ番号を得る関数です。\
hidemaruhandle=##fh = hidemaruhandle( 0 );\nif( findhidemaru( hidemarudir + "\\\\" + \v$$1 ) == -1 ) {\n\topenfile "/r " + "/h " + hidemarudir  + "\\\\" + $$1 ;\n}\n##backfh = hidemaruhandle( 0 );\nsetactivehidemaru ##fh ;\nclosehidemaru ##backfh;\n//秀丸のハンドルの取得
findwindow=##wk = findwindow(\v) ;\n//ウィンドウの検索\n//findwindow( $$name ) 関数\n//$$nameで指定される文字列と同じキャプションのウィンドウを\n//探してそのウィンドウハンドルを返します。
findwindowclass=##wk = findwindowclass(\v) ;\n//ウィンドウをクラス名で検索\n//findwindowclass( $$name ) 関数\n//$$nameで指定される文字列と同じクラス名のウィンドウを探して\n//そのウィンドウハンドルを返します。
sendmessage=##result = sendmessage( \v##handle, , ,  );\n//sendmessage=メッセージの送信\n//sendmessage( ##handle, ##message, ##wParam, ##lParam ) 関数\n//例(WM_SYSCOMMAND SC_CLOSEを送る例)\n//##result = sendmessage( ##handle, 0x0112, 0xF060, 0 );
existfile=##wk = existfile( hidemarudir + "\\\\" + $$kwdfile );\nif( !##wk ){\n\tmessage "$$kwdfileが存在しません。";\n}\n//existfile=ファイルが存在するかどうか\n//existfile( s1 ) 関数\n//s1というファイルが存在するかどうかを返します。
return=##wk = return ;\nif(##wk == 1){message "折り返し無し" ;}\n//現在のカーソルの後ろが改行してるかどうかを表します。\n//カーソルの位置する行の右側に改行文字があれば1になり、\n//無ければ(次の行に折り返している場合)0になります。
linecount=##wk = linecount ;\n//現在のファイルの、ワープロ的に計算した行数を表します。\n//新規作成状態の場合は1を返します。
dderequest=$$wk = dderequest( \v ) ;\n//$$wk = dderequest( s1 ) ;\n//DDEのデータの要求\n//DDE
macrodir=$$wk = macrodir ;//マクロファイル用のフォルダを表します。動作環境で指定されていない場合は、hidemaru.exeのhidemarudirと同じフォルダを返します。すべて小文字です。
searchmode=##wk = searchmode ;//「検索での表示」の状態を表します。\n//点滅表示のとき0、範囲選択のときは1です。
linecount2=##wk = linecount2 ;\n//現在のファイルの、エディタ的に計算した行数を表します。\n//新規作成状態の場合は1を返します。
year=$$wk = year ;//年を返します。4桁の文字列です。
month=$$wk = month;//月を返します。2桁の文字列です。
day=$$wk = day ;//日を返します。2桁の文字列です。
hour=$$wk = hour ;//時間を返します。2桁の文字列です。
minute=$$wk = minute ;//分を返します。2桁の文字列です。
second=$$wk = second ;//秒を返します。2桁の文字列です。
dayofweek=$$wk = dayofweek ;//曜日を返します。"日" "月"といった文字列です。
dayofweeknum=##wk = dayofweeknum ;//曜日を返します。数値です。(日曜=0 月曜=1 ...)
refreshdatetime=refreshdatetime ;//文を実行した時点で(日付と時刻を表すキーワードに)時間を返す
x=##x = x ;\t//カーソルのx座標を表します。カーソルが一番左にいる時が0です。
y=##y = y ;\t//カーソルのy座標を表します。y座標は、現在編集中のテキストの先頭行からワープロ的に行番号を計算した値で、一番上にいる時が0です。
column=##col = column ;\t//カーソルのカラム位置を表します。カラム位置は、論理行頭(直前の改行文字の次)から現在のカーソル位置までの文字数を数えた値です。タブ文字は1文字として数えられます。
lineno=##line = lineno ;\t//カーソル位置の、エディタ的に計算した行番号を表します。ファイルの先頭が1です。
filetype=//filetype\t現在編集中のファイルのファイルタイプを表します。すべて小文字です。ファイルの拡張子を表すときは必ず先頭にピリオド(.)が入ります。\n$$filetype = filetype;\n
colorcode=//カーソル位置の文字の色コードを返します。色コードの意味はHelp参照。\n##n = colorcode ;\n
marked=//カーソル位置がマークされているかどうかを返します。\n##n = marked ;\n
unicode=//カーソル位置のUnicodeのコードを表します。\n##n = unicode ;\n
monitor=//マルチモニタ環境において、現在のモニタ番号を表します。ちなみにsetminitor文を使うと指定したモニタに移動できます。\nif(monitor == 0){\n\t\tsetmonitor 1;\n}else{\n\tsetmonitor 0;\n}\n
setmonitor=//現在のウィンドウをパラメタで指定されたモニタに移動します。\n//マルチモニタ環境でないと何も起きません。\nif(monitor == 0){\n\t\t\vsetmonitor 1;\n}else{\n\tsetmonitor 0;\n}\n
monitorcount=//マルチモニタ環境において、モニタの数を表します。\n##n = monitorcount ;\n
code=//カーソル位置の文字コードを表します。\nif(code == eof){\n\tbreak;\n}\n
version=//秀丸のバージョン番号です。\n//Version2.11の場合、211という値になります。このキーワードはVersion 2.11から追加されたキーワードです。2.10以下ではエラーになってしまいます。\nif ( version < 410 ) {\n\tmessage "秀丸がVer4.10より古いです\\n" ;\n\tgoto LEND;\n}\n
basic=$$ver  = "1.00";\n$$date = "xxxx/xx/xx";\n$$author = "" ;\n$$fname = currentmacrobasename ;\n$info = "\\n" + $$fname + " Ver " + $$ver+ "\\n最終更新日付:"+$$date ;\n$info = $info + "\\n作者:"+$$author ;\n\n\t$sbuf = searchbuffer ;\t//マクロ終了時に、検索条件を復元するため記憶\n\t#sopt = searchoption ;\n\t$rbuf = replacebuffer;\n//sample\n\t//\vsearchdown $$1 ;\n\t//call Res_check , result ,"文字列"+$$1+"をできませんでした。" ;\n\t//call Str_check , $$1 , "文字列を取得できませんでした。" ;\n//sample end\n\n\n\nLEND:\n\tsetsearch $sbuf, #sopt; //開始時の検索文字,optionに戻す\n\tsetreplace $rbuf ;\n\tfreedll;\n\tendmacro;\n\nRes_check:\n//処理:処理の判定&メッセージ表示\n\t//引数渡し\n\t//第一引数: 数値型,result\n\t//第二引数: 文字列型,表示メッセージ\n\t##num = ##1;\t$$mes = $$2 ;\n\t//結果が"1"でないとき、メッセージを表示して終了\n\tif(##num != 1){\n\t\tmessage $$mes ;\n\t\tgoto LEND;\n\t}\nreturn ;\n\nStr_check:\n//処理:文字列の判定&メッセージ表示\n\t//引数渡し\n\t//第一引数: 文字列型,チェック文字列\n\t//第二引数: 文字列型,表示メッセージ\n\t$$str = $$1;\t$$mes = $$2 ;\n\t//文字列がないときメッセージを表示して終了\n\tif($$str == ""){\n\t\tmessage $$mes ;\n\t\tgoto LEND;\n\t}\nreturn ;\n
currentmacrofilename=$$wk = currentmacrofilename ;\t//現在実行中のマクロのファイル名をフルパスで表します。すべて小文字です。\n
currentmacrobasename=$$wk = currentmacrobasename ;\t//現在実行中のマクロのファイル名の、パスを含まない、ベース名だけを表します。すべて小文字です。\n
currentmacrodirectory=$$wk = currentmacrodirectory ;\t//現在実行中のマクロのフォルダを表します。すべて小文字です。
tabmode=//ウィンドウ一覧のタブ(タブモード)が有効であるかを表します。\n//参照:settabmode\n##n = tabmode ;\n
tabgroup=//タブモードのとき、グループIDを表します。\n//グループIDとは、タブを分離しているとき、見た目上のウィンドウに与えられる固有の識別番号です。\n//通常、0 から順番に割り当てられていますが、ウィンドウを閉じたりすると飛び飛びの番号になったりもします。\n//自分自身は 0 とは限りません。\n//グループIDは、hidemaruhandleに似ています。ウィンドウの重なり具合によって変化することはありません。\n//角カッコで添え字を付けて、他の秀丸からも値を得ることができます。\n//参照:settabgroup\n##n = tabgroup ;\n
taborder=//タブモードのとき、自身のタブを、同じグループにあるタブの0から数えた順番を表します。\n//角カッコで添え字を付けて、他の秀丸からも値を得ることができます。\n//参照:settaborder\n##n = taborder ;\n
tabtotal=//タブモードのとき、同じグループにあるタブの総数を表します。\n//角カッコで添え字を付けて、他の秀丸からも値を得ることができます。\n//tabcountと間違えやすいので注意してください。\n##n = tabtotal ;\n
settabmode=//ウィンドウ一覧のタブ（タブモード）の状態を変更します。\n//値に0 を指定すると、タブモードを解除します。\n//値に1 を指定すると、タブモードになります。\n//値を省略すると、タブモードを切り替えます。\n//例\n//\tsettabmode 値 ;\n\t##mode = \n\t//\t1 |\\t//タブモード有効\n\t//\t0 |\\t//タブモード無効\n\t\t0 ;\n\tsettabmode ##mode ;\n
settabgroup=//タブモードのとき、タブを分離/移動します。\n//例\n//\tsettabgroup 秀丸の番号,グループ番号 ;\n//秀丸の番号は、hidemaruorderで示されるウィンドウの番号またはウィンドウハンドルを指定します。\n//グループ番号は、タブを分離しているとき、見た目上のウィンドウに与えられる番号です。\n//例：\n##i =0;\n\twhile(##i<hidemarucount){\n\t\tif(filetype[##i]==".cpp"){\n\t\t\tsettabgroup ##i,0;\n\t\t}else if(filetype[##i]==".h"){\n\t\t\tsettabgroup ##i,1;\n\t\t}else {\n\t\t\tsettabgroup ##i,2;\n\t\t}\n\t\t##i =##i +1;\n\t}\n\n
settaborder=//タブモードのとき、タブの順番を変更します。\n//\tsettaborder 秀丸の番号,数値\n//秀丸の番号は、hidemaruorderで示されるウィンドウの番号またはウィンドウハンドルを指定します。\n//数値は、同じグループ内のタブを0 から数えた順番です。\n//参照:taborder\n//例:\n\t##i =0;\n\twhile(##i<hidemarucount){\n\t\tif(filetype[##i]==".cpp"){\n\t\t\tsettaborder ##i,0;\n\t\t}else if(filetype[##i]==".h"){\n\t\t\tsettaborder ##i,tabtotal[##i]-1;\n\t\t}\n\t\t##i =##i +1;\n\t}\n
tabgrouptotal=//タブモードのとき、グループの総数を表します。\n##n = tabgrouptotal ;\n
tabgrouporder=//タブモードのとき、グループの順番を表します。\n//グループの順番とは、タブを分離しているとき、ウィンドウの重なりを上から数えた番号です。\n//グループの順番は、hidemaruorderに似ています。ウィンドウの重なり具合によって変化します。\n//角カッコで添え字を付けて、他の秀丸からも値を得ることができます。\n##n = tabgrouporder ;\n
gettabhandle=//gettabhandle(n1,n2,n3 )関数\n//タブモードのとき、各タブのウィンドウハンドルを取得します。\n//グループとタブの順番を指定して、二次元配列を扱うかのように取得することができます。\n//n1 は、n2 の値がグループの順番かどうかを指定します。\n//n1 が0のとき、n2 はグループIDを示します。\n//n1 が1のとき、n2 はグループの順番を示します。\n//n3 は、グループ内のタブの順番を示します。\n//返す値は、秀丸のウィンドウハンドルです。\n##n = gettabhandle(\v0,0,0) ;\n
getcurrenttab=//getcurrenttab(n1,n2 )関数\n//タブモードのとき、グループ内の選択されているタブのウィンドウハンドルを取得します。\n//n1 は、n2 の値がグループの順番かどうかを指定します。\n//n1 が0のとき、n2 はグループIDを示します。\n//n1 が1のとき、n2 はグループの順番を示します。\n//返す値は、秀丸のウィンドウハンドルです。\n##n = getcurrenttab(\v0,0) ;\n
foundbuffer=//「検索文字列の強調」されているとき、強調のために使われている検索文字列を表します。\n//searchbufferは全ての秀丸で共通ですが、foundbufferはそれぞれの秀丸ごとに記憶しています。\n$$a = foundbuffer ;\n
foundoption=//「検索文字列の強調」されているとき、強調のために使われている検索フラグを表します。\n##n = foundoption ;\n
insertreturn=insertreturn ;\t//改行の挿入
closehidemaru=//closehidemaru 番号\n//番号（ハンドルも可）で指定した秀丸を終了させます。ただし、自分自身を指定することはできません。\n//指定した秀丸がまだファイルを保存してない場合はclosehidemaruは失敗します。\n//closehidemaruは終了コードとして、成功した場合はtrue、失敗した場合はfalseを返します。\n//例：\n##a =findhidemaru("abc.txt");\nif(##a ==-1 ){\n\tmessage "abc.txtはいません";\n\tendmacro;\n}\n\vclosehidemaru ##a;\nif(!result )message "abc.txtの終了失敗です。";\n
closehidemaruforced=//closehidemaruforced 番号\n//closehidemaruと同様に秀丸を終了させます。ただし、こちらは「(更新)」のついたファイルの場合でもエラーにならずに強制的に（保存せずに）終了させます。\n//例：\n##a =findhidemaru("abc.txt");\nif(##a ==-1 ){\n\tmessage "abc.txtはいません";\n\tendmacro;\n}\nclosehidemaruforced ##a;\nif(!result )message "abc.txtの終了失敗です。";\n
setactivehidemaru=//setactivehidemaru 値\n//アクティブな秀丸を指定します。マクロの実行もそちらのウィンドウに移動します。\n//パラメタとしてウィンドウの番号か、またはハンドルが指定できます。\n//例：\n\vsetactivehidemaru 1;\nsetactivehidemaru findhidemaru("client.cpp");\n
hilightfound=//検索文字列の強調を切り替えます。パラメタに 0 を指定すると強調オフ、 1 を指定すると強調オンになります。\n//パラメタを省略すると、オンとオフを切り替えます。\n//例\nhilightfound 1 ;\t//強調on\n
columntox=//columntox( c1, l1 ) 関数\n//カラム位置からx座標への変換をします。\n//c1はカラム位置、l1は行番号を指定します。\n//戻り値:数値型\n##n = columntox(1,1) ;\n
linenotoy=//linenotoy( c1, l1 ) 関数\n//行番号からy座標への変換\n//c1はカラム位置、l1は行番号を指定します。\n//戻り値:数値型\n##n = linenotoy(1,1) ;\n
foundhilighting=//「検索文字列の強調」が表示状態にあるかどうかを表します。\n//1:検索文字列の強調表示/0:強調非表示\n##n = foundhilighting ;\n
nexttab=//ウィンドウ系文コマンド\n//次のタブ\nnexttab ;\n
prevtab=//ウィンドウ系文コマンド\n//前のタブ\nprevtab ;\n
selendcolumn=//範囲選択関連\n//範囲選択終了位置のカラム位置を表します。\n##n = selendcolumn ;\n
selendlineno=//範囲選択関連\n//範囲選択終了位置のエディタ的に計算した行番号を表します。\n##n = selendlineno ;\n
seltopcolumn=//範囲選択関連\n//範囲選択開始位置のカラム位置を表します。\n##n = seltopcolumn ;\n
seltoplineno=//範囲選択関連\n//範囲選択開始位置のエディタ的に計算した行番号を表します。\n##n = seltoplineno ;\n
xtocolumn=//xtocolumn( x1, y1 ) 関数\n//x座標からカラム位置への変換をします。\n//x1はx座標、y1はy座標を指定します。\n//戻り値=数値型\n##n = xtocolumn(1,1) ;\n
ytolineno=//ytolineno( x1, y1 ) 関数\n//y座標から行番号への変換をします。\n//x1はx座標、y1はy座標を指定します。\n//x座標は本当は計算には必要ありませんが、他の変換関数と合わせています。\n//戻り値=数値型\n##n = ytolineno ;\n
gettext2=$$wk = gettext2( ##x, ##y, ##x2, ##y2 ) ;\n##select_keep = 1;\n$$wk = gettext2( ##x, ##y, ##x2, ##y2,##select_keep ) ;\n//gettext( x1, y1, x2, y2, n1 ) 関数\n//文字列取り込み\n//x1,y1からx2,y2の範囲にある文字列を返します。\n//x,y座標の指定のしかたはmovetolineno文と同じです。\n//返す値は文字列型です。\n//第5パラメタ n1 に 1 を指定すると、範囲選択を維持することができます。\n
indent=//インデント\nif(selecting==1){\n\tindent ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n
unindent=//逆インデント\nif(selecting==1){\n\tunindent ;\n}\nelse{\n\tmessage "Not Selecting!" ;\n}\n
windowstate2=//ウィンドウの表示の具合その2\n//以下の値の論理和です。\n//\t常に手前に表示\t0x0001(ビット0)\n//現在はビット0しかありませんが将来的に拡張されるかもしれないので、(windowstate2 & 0x01)をして判定してください。\n//角カッコで添え字を付けて、他の秀丸からも値を得ることができます。\n##wk = windowstate2 & 0x01 ;\n
getfilehist=//getfilehist( n1 )関数\n//ファイルヒストリの文字列を取得します。n1には、0からはじまるヒストリの番号を入れます。\n##n = 0 ;\nwhile(1) {\n\t$$wk = getfilehist( ##n ) ;\n\tif($$wk == "") break ;\n\t$$menu[##n] = $$wk ;\n\t##n = ##n + 1;\n}\nmenuarray $$menu ,##n;\n
setfilehist=//setfilehist文は、ファイルのヒストリを設定します。数値は0からはじまるヒストリの番号、文字列は内容を指定します。\n//setfilehist 数値,文字列\nsetfilehist 0 , filename2 ;\n
getpathhist=//getpathhist( n1 )関数\n//フォルダヒストリの文字列を取得します。n1には、0からはじまるヒストリの番号を入れます。\n##n = 0 ;\nwhile(1) {\n\t$$wk = getpathhist( ##n ) ;\n\tif($$wk == "") break ;\n\t$$menu[##n] = $$wk ;\n\t##n = ##n + 1;\n}\nmenuarray $$menu ,##n;\n
setpathhist=//setpathhist文は、フォルダのヒストリを設定します。数値は0からはじまるヒストリの番号、文字列は内容を指定します。\n//setpathhist 数値,文字列\nsetpathhist 0 , directory ;\n
replacebuffer=//置換バッファの内容を表します\n$$wk = replacebuffer ;
grepfilebuffer=//grepの「検索するファイル」の内容を表します。\n$$wk = grepfilebuffer ;
foundtopx=//検索にヒットした文字列の開始位置のx座標を表します。\n\t##f_topx = foundtopx ;\n\t##f_topy = foundtopy ;\n\t##f_endx = foundendx ;\n\t##f_endy = foundendy ;\n
foundtopy=//検索にヒットした文字列の開始位置のy座標を表します。\n\t##f_topx = foundtopx ;\n\t##f_topy = foundtopy ;\n\t##f_endx = foundendx ;\n\t##f_endy = foundendy ;\n
foundendx=//検索にヒットした文字列の終了位置のx座標を表します。\n\t##f_topx = foundtopx ;\n\t##f_topy = foundtopy ;\n\t##f_endx = foundendx ;\n\t##f_endy = foundendy ;\n
foundendy=//検索にヒットした文字列の終了位置のy座標を表します。\n\t##f_topx = foundtopx ;\n\t##f_topy = foundtopy ;\n\t##f_endx = foundendx ;\n\t##f_endy = foundendy ;\n
forceinselect=//forceinselect文は、引数に 1 を指定すると、検索ダイアログを出すときに明示的に「選択した範囲内のみ」にチェックしたり、下候補、上候補するときに明示的に「選択した範囲内のみ」で動作させます。\n//0 を指定すると、通常の動作になります。\n//searchdown等の引数でinselectが指定できるものには有効ではありません。\n//find文では有効ではありません。find2文では有効です。\n//例:\n\tforceinselect 1;\n\tfinddown;\n
inselecting=//「選択した範囲のみ」で動作中かどうか\n##n = inselecting ;\n
loaddllfile=//loaddllされている場合、ロードされているDLLのファイル名を返します。\n//ロードされていない場合は何もない文字列を返します。\n$$wk = loaddllfile ;\n
getsearchhist=//getsearchhist( n1 )関数\n//検索ヒストリの文字列を取得します。n1には、0からはじまるヒストリの番号を入れます。\n##n = 0 ;\nwhile(1) {\n\t$$wk = getsearchhist( ##n ) ;\n\tif($$wk == "") break ;\n\t$$menu[##n] = $$wk ;\n\t##n = ##n + 1;\n}\nmenuarray $$menu ,##n;\n
setsearchhist=//setsearchhist文は、検索ダイアログの検索文字列のヒストリを設定します。数値は0からはじまるヒストリの番号、文字列は内容を指定します。\n//setsearchhist 数値,文字列\nsetsearchhist 0 , "endmacro" ;\n
getreplacehist=//getreplacehist( n1 )関数\n//置換ヒストリの文字列を取得します。n1には、0からはじまるヒストリの番号を入れます。\n##n = 0 ;\nwhile(1) {\n\t$$wk = getreplacehist( ##n ) ;\n\tif($$wk == "") break ;\n\t$$menu[##n] = $$wk ;\n\t##n = ##n + 1;\n}\nmenuarray $$menu ,##n;\n
setreplacehist=//setreplacehist文は、置換ダイアログの置換文字列のヒストリを設定します。数値は0からはじまるヒストリの番号、文字列は内容を指定します。\n//setreplacehist 数値,文字列\nsetreplacehist 0 , "endmacro" ;\n
getconfig=//getconfig( s1 ) 関数\n//ファイルタイプ別の設定の値の取得をします。s1の名前はレジストリ互換です。\n//この名前はconfig "x"で指定できる名前と同じものを指定できます。\n//レジストリに保存されていない(一時的な設定) の値も取得できます。\n//返す値は基本的に文字列型ですが、文字列としても数値としても扱うことができます。\n//例:\n\tmessage getconfig( "Font" );\n\tmessage getconfig( "Tab" );\n\tmessage getconfig( "FreeCursor" );\n
fontcharset=//フォントの文字セットを表します。\n##n = fontcharset ;\n
hex=//数値を16進数の文字列に変換\n$$wk = hex( 10 ) ;\n
configcolor=//設定系\n//configcolor文は、ファイルタイプ別の設定のカラーとスタイルを変更します。\n//以下のような形式で文字列で指定します。\n//\tconfigcolor "[n1][n2]:n3"\n//\t詳細はHelp参照。\n//configcolorで指定する文字列は、空白で区切ってまとめて指定することができます。\n//例:\n\tconfigcolor "[0][1]:65536";\n\tconfigcolor "[0][0]:0xFFFFFF [0][1]:0x0 [0][2]:4 ";\n
getconfigcolor=//設定系\n//getconfigcolor( n1, n2 ) 関数\n//ファイルタイプ別の設定のカラーの取得\n//getconfigcolor関数は、ファイルタイプ別の設定のカラーを取得します。\n//n1,n2はconfigcolorのn1,n2と同じです。\n//返す値は数値で、configcolorのn3と同じです。\n\t##n = getconfigcolor(0,0) ;\n
setencode=//ファイル系文\n//エンコードの種類\n//setencode文は、エンコードの種類の変更または改行コードの変更をします。\n//\tsetencode 数値1, 数値2\n//数値1は、charsetキーワードで示される値と同じ、エンコードの種類を表す値です。0を指定すると、「自動判定で読み込みしなおし」と同じになります。\n//数値2は、0を指定すると、ファイルの読み込みし直しを行います。1を指定すると、テキストの内容を維持したまま変換を行います。\n//エンコードの種類が変更されると、エンコードの種類に適したフォントに自動的に切り替わります。\n\n\t//ビット0〜ビット5(charset & 63 した値)が文字コードです。\n\t##n1 = (\n\t//\t\t0x00 |  //新規作成直後(SHIFT-JIS)\t0\n\t//\t\t0x01 |  //SHIFT-JIS\t1\n\t//\t\t0x02 |  //Unicode\t2\n\t\t\t0x03 |  //EUC\t3\n\t//\t\t0x04 |  //JIS\t4\n\t\t\t0x10 |  //bit6が1の場合、改行=LF\n\t//\t\t0x20 |  //bit7が1の場合、改行=CR\n\t\t\t0x00 ) & 63 ;\n\t##n2 = \n\t\t\t0 | \t//0を指定すると、ファイルの読み込みし直しを行います\n\t//\t\t1 | \t//1を指定すると、テキストの内容を維持したまま変換を行います。\n\t\t\t0 ;\n\tsetencode ##n1 , ##n2 ;\n
closenew=//ファイル系文\n//「ファイルを閉じる」コマンド(Ctrl+F4)と同じ動作\n//ウィンドウの内容を空にする\nclosenew ;\n
endsel=//クリップボード系文\n//beginsel, beginrectによる範囲選択モードを解除（範囲選択はそのまま）\n\tendsel ;\n
escapeinselect=//検索系文\n//「選択した範囲内のみ」の動作を取り消す(検索系文)\nescapeinselect ;\n
refcopy2=refcopy2 ;	//引用付きコピー（範囲選択はそのまま）
copyurl=//クリップボード系文\n// ...をコピー\n// カーソル位置にあるURL情報をCOPYするようです。\ncopyurl ;\n
rolldown2=//カーソル移動系文\n//スクロールダウン2\nrolldown2 ;\n
find=//検索系文\n//検索ダイアログ\nfind ;\n
find2=//検索系文\n//検索ダイアログ(searchbufferとsearchoptionとforceinselectが有効)\nfind2 ;\n
findword=//検索系文\n//検索ダイアログ(単語の検索)\nfindword ;\n
searchdialog=//検索系文\n//検索ダイアログ(searchdownと同じパラメタ指定)\n$$1 = "abc" ;\nsearchdialog $$1,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//下方向検索\n
replace=//検索系文\n//置換ダイアログ\nreplace ;\n
replacedialog=//検索系文\n//置換ダイアログ(replacedownと同じパラメタ指定)\n$$1 = "a" ;\n$$2 = "b" ;\nreplacedialog $$1 ,$$2 ,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//下方向置換\n
setreplace=//検索系文\n//setreplace文は、秀丸が内部で保持している置換バッファの内容を設定します。\n//\tsetreplace 文字列\n//setsearchで検索バッファの内容と置換を有効(ビット2)にし、setreplaceで置換バッファの内容を設定してからfindup/finddownを実行すると、replaceup/replacedownを実行したのと同じ結果が得られます。\n//setreplaceと逆に、置換バッファの内容を参照するには、replacebufferという値を使います。\n//注意)\n//検索/置換文字列には上限があります。上限を超える可能性がある場合は事前に文字数をカウントして判断する必要があります。\n//例:\n\t$$s = searchbuffer;\n\t##f = searchoption;\n\t$$r = replacebuffer;\n\t//…\n\t//マクロ本体…\n\t//…\n\tsetsearch $$s, ##f;\n\tsetreplace $$r;\n\tendmacro;\n
setgrepfile=//検索系文\n//setgrepfile文は、grepの「検索するファイル」の内容を設定します。\n//\tsetgrepfile 文字列\nsetgrepfile "abc" ;\n
finddown2=//検索系文\n//下候補(その2)\n//findup2,finddown2,searchup2,searchdown2文はカーソル位置から検索を開始するバージョンです。使い方はfindup,finddown,searchup,searchdown文と同じです。\n//下方向の検索についてのみ意味があります。つまり、置換においてはfindup2,finddown2はfindup,finddownと同等で、上方向についてはfindup2,searchup2はfindup,searchupと同等です。\nfinddown2 ;\t//下候補\n
findup2=//検索系文\n//上候補(その2)\n//findup2,finddown2,searchup2,searchdown2文はカーソル位置から検索を開始するバージョンです。使い方はfindup,finddown,searchup,searchdown文と同じです。\n//下方向の検索についてのみ意味があります。つまり、置換においてはfindup2,finddown2はfindup,finddownと同等で、上方向についてはfindup2,searchup2はfindup,searchupと同等です。\nfindup2 ;\t//上候補\n
searchdown2=//検索系文\n//下方向検索(その2)\n//findup2,finddown2,searchup2,searchdown2文はカーソル位置から検索を開始するバージョンです。使い方はfindup,finddown,searchup,searchdown文と同じです。\n//下方向の検索についてのみ意味があります。つまり、置換においてはfindup2,finddown2はfindup,finddownと同等で、上方向についてはfindup2,searchup2はfindup,searchupと同等です。\nsearchdown2 $$1,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//下方向検索\n
searchup2=//検索系文\n//上方向検索(その2)\n//findup2,finddown2,searchup2,searchdown2文はカーソル位置から検索を開始するバージョンです。使い方はfindup,finddown,searchup,searchdown文と同じです。\n//下方向の検索についてのみ意味があります。つまり、置換においてはfindup2,finddown2はfindup,finddownと同等で、上方向についてはfindup2,searchup2はfindup,searchupと同等です。\nsearchup2 $$1,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//上方向検索\n
alwaystopswitch=//ウィンドウ系文\n//常に手前に表示切り替え\nalwaystopswitch ;\n
clearupdated=//その他のコマンド系文\n//編集マークを全て消去して「(更新)」状態を解除\nclearupdated ;\n
debuginfo=//メッセージ系\n//debuginfo文\n//debuginfo文には2つの使い方があります。\n//debuginfo文のパラメタに、0または0以外の数値を指定した場合、debuginfo文は、デバッグメッセージの表示の禁止/許可を行います。0を指定した場合禁止され、0以外を指定した場合許可されます。マクロ実行直後は禁止になっています。\n//debuginfo文のパラメタに文字列を指定した場合は、debuginfo文はOutputDebugString関数を使ってその文字列をデバッグアプリケーションに表示します。\n//デバッグアプリケーションが常駐していない時にこの文を実行すると、文字列はデバッグ端末に送られます。デバッグアプリケーションもデバッグ端末もない場合はWindowsの動作がおかしくなることがあるので注意してください。\n//デバッグアプリケーションは、フリーソフトでいろいろ公開されていたりするので、入手して使うことができます。「デバッガ」「OutputDebugString」等でWeb検索すると見付かるかもしれません。\n//改行文字を出力したい場合は、"\\x0A"を使って下さい。\n//例:\n\t\vdebuginfo 1;\n\tdebuginfo "##a = " + str(##a) + "\\x0a";\n
showvars=//メッセージ系\n//showvars文\n//現在の変数の一覧をデバッグアプリケーションに表示します。\n//実際に表示させるためには、debuginfo文でデバッグメッセージの表示が許可されている必要があります。\n
saveconfig=//設定系\n//saveconfigはファイルタイプ別の設定を保存します。ファイルタイプ別の設定ダイアログで「OK」を押したのと同じです。\n//たとえ(一時的な設定)になっていたとしても、強制的に保存します。\nsaveconfig ;\n
savekeyassign=//savekeyassign文は、現在のキー割り当てをキー割り当てファイルとしてファイルに保存します。パラメタでキー割り当てファイルの名前を指定してください。\n//第2パラメタには、0か1かの数字を指定します。\n//0にすると、キー割り当てのみの保存、1にすると、マクロ登録の内容も保存します。\n//第2パラメタは省略を省略すると0になります。\n//例:\n\tsavekeyassign "temp.key", 0;\n
savehilight=//savehilight文\n//パラメタで指定された強調表示ファイルに書き込みます。\n//例:\n\tsavehilight "C-language.hilight";\n
setfontchangemode=//setfontchangemode文\n//config文などでフォントの文字セットが変更されたときの動作を決めます。\n//パラメタに 0 か 1 を指定します。\n//0 を指定すると、config文でフォントの文字セットが変更されたとき、バイナリを維持したまま文字セットを適用します。\n//1 を指定すると、テキストの内容を維持したまま変換を行います。\n//例:\n\tsetfontchangemode 1;\n
eof=//結果コードと定数関連キーワード\n//eof(End of file):-1という値です。\nif(code == eof){\n\tendmacro; \n}\n
result=searchdown $$1,word,casesense,regular,fuzzy,inselect,linknext,hilight,nohilight;\t//下方向検索\nif(!result){\n\tmessage $$1 + ":Not Found" ;\n\tendmacro;\n}\n
yes=//結果コードと定数関連キーワード\n//yes:1という値です。\nquestion "" ;\nif( result == yes ) {\n\t\v\n}\nelse{\n}\n
no=//結果コードと定数関連キーワード\n//no:0という値です。\nquestion "" ;\nif( result == no ) {\n\t\v\n}\nelse{\n}\n
dengaku=call \vDengaku ;\nDengaku:\n\t//\t田楽DLLのロード\n\tif(existfile(hidemarudir+"\\\\DengakuDLL.dll"))loaddll hidemarudir+"\\\\DengakuDLL.dll";\n\telse {\n\t\t$$mes = "田楽DLLが見つかりませんでした。\\n" +\n\t\t\t\t"田楽DLLを秀丸エディタインストールディレクトリにおいてください。\\n" +\n\t\t\t\t"  秀丸エディタインストールディレクトリ:\\n\\t"+hidemarudir + "\\n\\n" +\n\t\t\t\t"田楽DLL ダウンロードURL\\n"+\n\t\t\t\t"  http://www.ceres.dti.ne.jp/~sugiura/hidemaru/macros/dgserver/\\n" + \n\t\t\t\t$info ;\n\t\tmessage $$mes ;\n\t\tgoto LEND ;\n\t}\n\n\tif (!result) {\n\t\tmessage "田楽DLL をロードできませんでした。"+$info;\n\t\tgoto LEND ;\n\t}\nreturn;\n
configset=//configset\n//configset文は、ファイルタイプ別の設定を、「設定のリスト」の名前を指定して変更します。　（V5.11以降）　第一パラメタには設定のリストの中にある名前を指定します。""を指定すると、「共通」の設定になります。　第二パラメタに 0 を指定すると、ファイルタイプ別の設定は一時的な設定になります。\n//例：\n\vconfigset "C言語ｿｰｽﾌｧｲﾙ", 1;\n//現在の設定のリストの名前は currentconfigsetキーワードで表されます。（ファイルタイプ別の設定関連）
setfocus=//setfocus文\n//指定したウィンドウに入力フォーカスを設定します。（V6.00以降）\n//以下の値を指定できます。\n1 　 編集エリア \n2 　 アウトライン解析の枠 \n3 　 ツールバーの検索ボックス \n--------------------------------------------------------------------------------\n//またはウィンドウハンドルを指定できます。ウィンドウハンドルは、他の秀丸エディタ\n//や他のプロセスのウィンドウは指定できません。将来的な拡張も考慮してのことで、\nV6.00現在においては使い道はありません。\n//参照：getfocusキーワード \n
getfocus=//getfocus現在の入力フォーカスのあるウィンドウを表します。（V6.00以降）\n//値は、setfocusで指定する値と同じです \n





hidemarumail=\t\vcall HidemaruMail ;\nLEND:\n\tfreedll;\n\tendmacro;\n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n\tloaddll "TKInfo.dll";\n\tif( !result ) {\n\tmessage "\\tDLLロードに失敗\\n"+$$info;\n\tendmacro;\n\t}\nreturn ;\n
MailType=//MailType関数(TKInfo.dll)\n//-1:何も無い場合\n//0:新規作成のメール\n//1:返信メール\n//2:転送メール\n//3:受信したメールの場合\n//4:送信済みメールの場合\n//5:未送信フォルダまたは草稿フォルダに保存された未送信メール\n//6:「添付ファイルとして転送」で作成されたメールで、まだ保存されてない段階の物。\n##n = dllfunc( "MailType" );\nif( ##n == 0 ) message "新規メールです。";\n
NewMailType=//NewMailType関数(TkInfo.dll)\n//0:新規作成のメールじゃない\n//1:普通に新規作成されたメールなど(2, 3以外の物すべて)\n//2:「mailto:XXXXX」のような形で起動されたメール\n//3:アドレス帳から起動されたメール\nif( dllfunc("NewMailType") == 2 ) {\n\tmessage "mailto:で起動されました。";\n}\n
CurrentHeader=//CurrentHeader関数(TkInfo.dll)\n//CurrentHeader関数は、現在のメールのヘッダ部分から任意のヘッダを検索して、その値部分を返します。編集途中であっても、その編集途中のヘッダ部分の値を返します。\n$$ReplyTo = dllfuncstr( "CurrentHeader", "Reply-To" );\n
CurrentHeader2=//CurrentHeader2関数(TkInfo.dll)\n//CurrentHeader2関数は、同じヘッダが複数ある場合に、追加パラメータで指定された位置のヘッダ内容を返します。CurrentHeader関数は先頭のヘッダの値のみを返します。\n$$Attach = dllfuncstr("CurrentHeader2", "X-Attach", 0 );\n
CountCurrentHeader=//CountCurrentHeader関数(TkInfo.dll)\n//CountCurrentHeaderは、パラメータ1で指定されたヘッダがメール中にいくつあるかを返します。まったく無い場合は0、1つある場合は1、…となります。\n##n = dllfunc("CountCurrentHeader", "X-Attach");\n
IsUnread=//IsUnread関数(TkInfo.dll)\n//この関数は、現在のメールが未読かどうかを返します。メールが複数選択されている場合には点線のフォーカス枠のついているメールについて未読かどうか返します。\n##unread = dllfunc( "IsUnread" );\n
IsMarked=//IsMarked関数(TkInfo.dll)\n//この関数は、現在のメールがマークされているかどうかを返します。メールが複数選択されている場合には点線のフォーカス枠のついているメールについての状態を返します。\n##marked = dllfunc( "IsMarked" );
IsOrikaeshi=//IsOrikaeshi関数(TkInfo.dll)\n//この関数は、現在のメールが「自動折り返し」になっているかどうかを返します。メールが複数選択されている場合には点線のフォーカス枠のついているメールについての状態を返します。\n##orikaeshi = dllfunc( "IsOrikaeshi" );\n
HeaderView=//HeaderView関数(TkInfo.dll)\n//HeaderView関数は、現在のヘッダ表示のモードを返します。\nif( dllfunc("HeaderView") == 2 ) ##n = dllfunc("SwitchHeaderView", 1);\n
IsHighPriority=//IsHighPriority関数(TkInfo.dll)\n//この関数は、現在のメールが「優先度:高」になっているかどうかを返します。メールが複数選択されている場合には点線のフォーカス枠のついているメールについての状態を返します。\n##HighPriority = dllfunc( "IsHighPriority" );
IsRequestNotification=//IsRequestNotification関数(TkInfo.dll)\n//この関数は、現在のエディタの「設定・開封通知を要求する」の状態を返します。\n##RequestNotification = dllfunc( "IsRequestNotification" );\n
MailFileName=//MailFileName関数(TkInfo.dll)\n//MailFileName関数は、現在表示しているメールの保存されているファイル名を返します。\nmessage dllfuncstr("MailFileName");\n
MailFilePath=//MailFilePath関数(TkInfo.dll)\n//MailFilePath関数は、ファイルのフルパスを返します。\nmessage dllfuncstr("MailFilePath");\n
MailFileOffset=//MailFileOffset関数(TkInfo.dll)\n//MailFileOffset関数は、現在のメールがファイル中でどの位置にあるかの情報\n//(ファイル先頭からのバイト数)を返します。\n//ここで返す位置には、「Ctrl-L! 」という形式の秀丸メールのメール区切り記号が入っています。メール本体は1行下からになります。\nmessage str( dllfunc("MailFileOffset") );\n
XMailer=//XMailer関数(TkInfo.dll)\n//XMailer関数は、秀丸メールが標準で送る「X-Mailer:」ヘッダの内容を返します。\n//この文字列には秀丸メールを表す「HidemaruMail」という文字列の他、秀丸メールの\n//バージョン番号とWindowsの種類についての情報が含まれます。\n##n = dllfunc("SetHeader", "X-Mailer", dllfuncstr("XMailer"));\n
SwitchMark=//SwitchMark関数(TkInfo.dll)\n//この関数は、現在のメールのマークを設定/解除します。マークの設定/解除コマンド自体は秀丸メール本体ウィンドウ上にしかありませんが、この関数はエディタ・ウィンドウ中でも実行可能です。\n##n = dllfunc( "SwitchMark" );
SwitchUnread=//SwitchUnread関数(TkInfo.dll)\n//この関数は、現在のメールの未読/既読を切り替えます。未読/既読の切り替えコマンド自体は秀丸メール本体ウィンドウ上にしかありませんが、この関数はエディタ・ウィンドウ中でも実行可能です。\n##n = dllfunc( "SwitchUnread" );\n
SwitchOrikaeshi=//SwitchOrikaeshi関数(TkInfo.dll)\n//この関数は、現在のメールの「自動折り返し」の設定のON/OFF切り替えをします。\n##n = dllfunc( "SwitchOrikaeshi" );\n
SwitchHeaderView=//SwitchHeaderView関数(TkInfo.dll)\n//SwitchHeaderViewは、ヘッダ表示のモードをパラメータにしたがって切り替えます。\n//ヘッダ表示の状態を指定します。\n//0の場合は表示しない、\n//1の場合は簡略表示、\n//2の場合は全体表示、\n//3の場合は「切り替え」コマンドの実行です。\n##n = dllfunc("SwitchHeaderView", 2);\t// 全体表示\n
SetHighPriority=//SetHighPriority関数(TkInfo.dll)\n//この関数は、現在のエディタのメニュー上の「優先度:高」の\n//チェック状態を切り換えます。メニューが灰色になっている時は何もせずにエラー\n//を返します。また、エディタ上でしか使えません。\n//0を渡すとOFF、1を渡すとONとなります。\n//"0"または"1"と指定することもできます(テンプレートからも呼び出せるようにするため)。\n##n = dllfunc( "SetHighPriority", 1 );\n
SetRequestNotification=//SetRequestNotification関数(TkInfo.dll)\n//この関数は、現在のエディタのメニュー上の「開封通知を要求する」のチェック状態を切り換えます。エディタ上で、メニューが選択できる状態の時しか使えません。\n##n = dllfunc( "SetRequestNotification", 1 );
GetMailFlag=//GetMailFlag関数(TkInfo.dll)\n//メール毎に存在する各種のフラグの値を取得します。\n##n = dllfunc("GetMailFlag", "hot");\n
SetMailFlag=//SetMailFlag関数(TkInfo.dll)\n//メール毎に存在する各種のフラグの値を書き換えます。\n//フラグをセットする場合は1、リセットする場合は0を指定します。\n//SetMailFlagできるフラグは、send, mark, orikaeshi, sent, reply, forward, unread, altered, hot\n//のみで、他のフラグは書き換えできません。\n//例(現在のメールを新着にする例)\n##n = dllfunc("SetMailFlag", "hot", 1);\n
GetMailColor=//GetMailColor関数(TkInfo.dll)\n//メールのメール一覧上での色を返します。\n//GetMailColor関数は、メールの色を返します。\n##n = dllfunc("GetMailColor");\n
SetMailColor=//SetMailColor関数(TkInfo.dll)\n//メールの色を書き換えます。\n//色を番号で指定します。番号は0〜15まで指定できます。\n//SetMailFlag関数は、色の書き換えに成功すると1、失敗すると0を返します。\n//例(現在のメールを赤色にする例)\n##n = dllfunc("SetMailColor", 1);\n
GetMailTransmitDate=//GetMailTransmitDate関数(TkInfo.dll)\n//メールの送受信日付/時刻を返します。返す値は文字列型で、「メールのプロパティ」ダイアログボックス上で表示されるのと同じ形式の文字列を返します。\n//GetMailTransmitDate関数は、メールの送受信日付/時刻を文字列形式で返します。何らかのエラーが起きた場合は""を返します。\n$$s = dllfuncstr("GetMailTransmitDate");\n
SetMailTransmitDate=//SetMailTransmitDate関数(TkInfo.dll)\n//メールの送受信日付/時刻を書き換えます。こちらでの文字列の指定方法も、「メールのプロパティ」ダイアログボックスと同じでないといけません。\n//SetMailTransmitDate関数は、書き換えに成功すると1、失敗すると0を数値型で返します。\n##n = dllfunc("SetMailTransmitDate", "2005/02/07" +  " " + "00:00:00.000");\n
SetCharSet=//SetCharSet関数(TkInfo.dll)\n//メールの文字コードを設定します。この関数は、エディタ上の「設定・文字コード」メニュー中のコマンドを実行するのとまったく同じ動作です。成功するとメール中の「Content-Type:」ヘッダが書き換えられます。\n##n = dllfunc("SetCharSet", "euro");\n
RootHeader=//RootHeader関数(TkInfo.dll)\n//元メールのヘッダ部分から任意のヘッダを検索して、その値部分を返します。\n$$ReplyTo = dllfuncstr( "RootHeader", "Reply-To" );\n//ちなみに、題名を取り出すには"Subject:"、宛先を取り出すには"From:"を指定します。\n
RootHeader2=//RootHeader2関数(TkInfo.dll)\n//同じヘッダが複数存在している場合に、追加パラメータで指定された場所のヘッダ内容を返します。\n$$Attach = dllfuncstr( "RootHeader2", "X-Attach", 0 );\n//ちなみに、題名を取り出すには"Subject:"、宛先を取り出すには"From:"を指定します。\n
CountRootHeader=//CountRootHeader関数(TkInfo.dll)\n//パラメータ1で指定したヘッダが元メール中にいくつあるかを返します。\n##n = dllfunc("CountRootHeader", "X-Attach");\n//ちなみに、題名を取り出すには"Subject:"、宛先を取り出すには"From:"を指定します。\n
RootBody=//RootBody関数(TkInfo.dll)\n//返信元メールまたは転送元メールの本文全体を返します。\n$$s = dllfuncstr("RootBody");\n
OrikaeshiRootBody=//OrikaeshiRootBody関数(TkInfo.dll)\n//折り返し禁止で返信元メールまたは転送元メールの本文全体を返します。\n$$s = dllfuncstr("OrikaeshiRootBody");\n
QuotedRootBody=//QuotedRootBody関数(TkInfo.dll)\n//返信元メールまたは転送元メールの本文を引用記号付きに変換して返します。ただし、エディタのマクロで扱える文字列の長さには制限があるため、実際には本文の先頭部分しか変数に代入されないことが多いです。\n//このQuotedRootBody関数は、テンプレート用に用意した物です。\n//返り値(文字列型)\n//返信元メールまたは転送元メールの本文の内容を引用記号付きに変換した文字列です。\n$$s = dllfuncstr("QuotedRootBody");\n
SelectedRootText=//SelectedRootText関数(TkInfo.dll)\n//返信元メールまたは転送元メールでの範囲選択された部分の文字列を返します。もし何も範囲選択されてなかった場合は""を返します。テンプレート用に用意した物です。\n$$s = dllfuncstr("SelectedRootText");\n
SelectedRootText2=//SelectedRootText2関数(TkInfo.dll)\n//範囲選択されていた場合はその文字列を返し、範囲選択されてなかった場合は本文全体を返します。テンプレート用に用意した物です。\n$$s = dllfuncstr("SelectedRootText2");\n
QuotedSelectedRootText=//QuotedSelectedRootText関数(TkInfo.dll)\n//SelectedRootTextの返す文字列にさらに引用を付けて返します。テンプレート用に用意した物です。\n$$s = dllfuncstr("QuotedSelectedRootText");\n
QuotedSelectedRootText2=//QuotedSelectedRootText2関数(TkInfo.dll)\n//同様にSelectedRootText2の返す文字列に引用記号を付けて返します。テンプレート用に用意した物です。\n$$s = dllfuncstr("QuotedSelectedRootText2");\n
RootBodyLineCount=//RootBodyLineCount関数(TkInfo.dll)\n//返信元メールまたは転送元メールの本文の行数を返します。ここで言う行数とは、改行文字の数を使って計算した行数であり、自動折り返しによって折り返された行数ではありません。\n//返り値(数値型)\n//返信元メールまたは転送元メールの本文の行数(0〜)です。\n##LineCount = dllfunc( "RootBodyLineCount" );\n
RootBodyLine=//RootBodyLine関数(TkInfo.dll)\n//返信元メールまたは転送元メールの本文の1行を返します。\n//例(返信元メールの本文をクリップボードに入れる場合)\nsetclipboard "";\n##LineCount = dllfunc( "RootBodyLineCount" );\n##i = 0;\nwhile( ##i < ##LineCount ) {\n\naddclipboard dllfuncstr( "RootBodyLine", ##i );\n\t##i = ##i + 1;\n}\n
RootFolder=//RootFolder関数(TkInfo.dll)\n//返信元メールまたは転送元メールの保存されているフォルダ名を返します。「返信メール」または「転送メール」コマンドでエディタを起動した場合にしか使えません。\n$$s = dllfuncstr("RootFolder");\n
RootFolder2=//RootFolder2関数(TkInfo.dll)\n//「返信メール」または「転送メール」コマンドでエディタを起動した場合には、RootFolder関数と同じく、返信元メールまたは転送元メールの保存されているフォルダ名を返し、「新規メール」で起動したエディタ上では、エディタ起動時に選択されていたフォルダを返します。\n$$s = dllfuncstr("RootFolder2");\n
SmallRootHeader=//SmallRootHeader関数(TkInfo.dll)\n//元メールのヘッダ部分を「簡略表示」に変換して返します。\n//返り値(文字列型)\n//ヘッダ部分文字列です。\n$$s = dllfuncstr("SmallRootHeader");\n
AllRootHeader=//AllRootHeader関数(TkInfo.dll)\n//元メールのヘッダ部分をそのまま返します。\n//返り値(文字列型)\n//ヘッダ部分文字列です。\n$$s = dllfuncstr("AllRootHeader");\n
QuotedSmallRootHeader=//QuotedSmallRootHeader関数(TkInfo.dll)\n//"SmallRootHeader"の返す値を引用付きにして返します。\n//返り値(文字列型)\n//ヘッダ部分文字列です。\n$$s = dllfuncstr("QuotedSmallRootHeader");\n
QuotedAllRootHeader=//QuotedAllRootHeader関数(TkInfo.dll)\n//"AllRootHeader"の返す値を引用付きにして返します。\n//返り値(文字列型)\n//ヘッダ部分文字列です。\n$$s = dllfuncstr("QuotedAllRootHeader");\n
OrikaeshiSmallRootHeader=//OrikaeshiSmallRootHeader関数(TkInfo.dll)\n//"SmallRootHeader"の返す値を、折り返し禁止でない形で文字列をメールに挿入します。\n//返り値(文字列型)\n//ヘッダ部分文字列です。\n$$s = dllfuncstr("OrikaeshiSmallRootHeader");\n
OrikaeshiAllRootHeader=//OrikaeshiAllRootHeader関数(TkInfo.dll)\n//"AllRootHeader"の返す値を、折り返し禁止でない形で文字列をメールに挿入します。\n//返り値(文字列型)\n//ヘッダ部分文字列です。\n$$s = dllfuncstr("OrikaeshiAllRootHeader");\n
RootReply=//RootReply関数(TkInfo.dll)\n//返信元メールまたは転送元メールの返信先を返します。元のメールに「Reply-To:」ヘッダが付いている場合はその内容、付いてない場合は「From:」ヘッダの内容を返します。\n//返り値(文字列型)\n//返信先の文字列です(メールアドレスのみの場合も、名前+メールアドレスの場合もありえます)。\n$$s = dllfuncstr("RootReply");\n
SetEmailOnly=//SetEmailOnly関数(TkInfo.dll)\n//パラメータで渡された「名前+Email」の形式の文字列から、Email部分のみを取り出して返します。\n//返り値(文字列型)\n//取り出されたEmail部分の文字列です。Email部分が見つからない場合は変換元の文字列をそのまま返します。\n$$from = dllfuncstr( "CurrentHeader", "From" );\n$$fromemail = dllfuncstr( "\vSetEmailOnly", $$from );\n
SetNameOnly=//SetNameOnly関数(TkInfo.dll)\n//パラメータで渡された「名前+Email」の形式の文字列から、名前部分のみを取り出して返します。\n//返り値(文字列型)\n//取り出された名前部分の文字列です。名前部分が見つからない場合はメールアドレスをそのまま返します。\n$$from = dllfuncstr( "CurrentHeader", "From" );\n$$fromname = dllfuncstr( "SetNameOnly", $$from );\n
UnDoubleQuote=//UnDoubleQuote関数(TkInfo.dll)\n//パラメータで渡された文字列がもしダブルクォーテーション記号で囲まれていた場合に、そのダブルクォーテーション記号(のセット)を除去します。\n//返り値(文字列型)\n//ダブルクォーテーション記号の除去された文字列を返します。ダブルクォーテーション記号で囲まれてなかった場合は元の文字列をそのまま返します。\n$$fromname = dllfuncstr("UnDoubleQuote", dllfuncstr( "SetNameOnly", $$from ) );\n
ToUpper_hmml=//ToUpper関数(TkInfo.dll)\n//パラメータで渡された文字列を大文字に変換します。\n$$info = "abc" ;\n$$upper = dllfuncstr( "ToUpper", $$info );\n
ToLower_hmml=//ToLower関数(TkInfo.dll)\n//ToLowerは小文字に変換します。\n$$info = "ABC" ;\n$$lower = dllfuncstr("ToLower", $$info );\n
CountEmailList=//CountEmailList関数(TkInfo.dll)\n//コンマで区切られたメールアドレス文字列の中から、メールアドレスの個数を返します。\n//返り値(数値型)\n//メールアドレスの個数です。\n##n = dllfunc("CountEmailList", "abc <abc@abc>, xyz <xyz@xyz>");\n
GetEmailList=//GetEmailList関数(TkInfo.dll)\n//コンマで区切られたメールアドレス文字列の中から、パラメータで指定された部分のメールアドレス部分を1つ取り出します。\n//返り値(文字列型)\n//取り出したメールアドレス部分です。ここは、abc <abc@abc> のように、名前 + メールアドレスとなっていることもあります。\n//この部分はコンマで区切られた内容をそのまま返す。\n$$s = dllfuncstr("GetEmailList", "abc <abc@abc>, xyz <xyz@xyz>", 1);\n
CurrentDate=//CurrentDate関数(TkInfo.dll)\n//現在の日付/時刻をパラメータで指定された形式で返します。\n//返り値(文字列型)\n//日付/時刻の文字列です。\n$$s = dllfuncstr("CurrentDate", "YYYY/MM/DD");\n
FormatDate=//FormatDate関数(TkInfo.dll)\n//メール中の「Date:」ヘッダに入っている日付文字列を、CurrentDate関数と同じようなフォーマットを使った文字列形式に変換します。\n$$s = dllfuncstr("FormatDate", dllfuncstr("RootHeader", "Date"), "YYYY/MM/DD");\n$$s = dllfuncstr("FormatDate", dllfuncstr("RootHeader", "Date"), "oYYYY/MM/DD hh:mm");\n
DecodeHeader=//DecodeHeader関数(TkInfo.dll)\n//受信ログ/送信ログなどのヘッダに入っているエンコードされた形式の文字列をデコードして返します。//備考\n//改行しているヘッダをデコードする場合には、改行を取り除いた形でDecodeHeader関数に渡す必要があります。\n//"範囲選択した部分を変換するマクロ"がhelpに記載されています。\n$$d = dllfuncstr( "DecodeHeader", $$s );\n
Quote=//Quote関数(TkInfo.dll)\n//パラメータで渡された文字列を引用記号付きに変換して返します。Quoteの処理は秀丸メール内部の引用の処理と同じなので、「全般的な設定・メール表示・フォント等...」の引用記号や引用行の折り返し桁数に従って処理されます。\n//返り値(文字列型)\n//引用された文字列です。\n$$s = dllfuncstr("Quote", $$s);\n
Quote2=//Quote2関数(TkInfo.dll)\n//第2パラメータで指定された文字列を引用記号として引用の処理をします。例えば「|」という記号を使って引用したい場合などに使います。\n//返り値(文字列型)\n//引用された文字列です。\n$$s = dllfuncstr("Quote2", $$s, ">");\n
MainWnd=//MainWnd関数(TkInfo.dll)\n//秀丸メール本体ウィンドウのウィンドウハンドルを返します。ウィンドウが存在しない時(メール用のエディタだけ起動している時)は0を返します。\n//返り値(数値型)\n//秀丸メール本体ウィンドウのウィンドウハンドルです。\n##main = dllfunc( "MainWnd" );\nsetactivehidemaru ##main;\n
SetMainWndTop=//SetMainWndTop関数(TkInfo.dll)\n//秀丸メール本体ウィンドウを強制的に表に出し、アクティブな状態にします。マクロの実行も秀丸メール本体ウィンドウに移動します。\n//秀丸メール本体ウィンドウが存在しない時は失敗して0を返します。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "SetMainWndTop" );\n
SelectPane=//SelectPane関数(TkInfo.dll)\n//秀丸メール本体ウィンドウ中の、アクティブな枠を切り替えます。秀丸メール本体ウィンドウ上でのみ実行できます。\n//返り値(数値型)\n//成功すると1、失敗すると(例えば、2枠区切りの時にメール内容枠をアクティブにしようとすると)0を返します。\n##n = dllfunc( "SelectPane", 0);\n
CurrentPane=//CurrentPane関数(TkInfo.dll)\n//秀丸メール本体ウィンドウ中の、現在のアクティブな枠の番号を返します。\n//返り値(数値型)\n//フォルダ枠がアクティブな時は0、メール一覧枠の時は1、メール内容枠の時は2、添付ファイル枠の時は3を返します。\n##pane = dllfunc( "CurrentPane");\n
ClearAllUnread=//ClearAllUnread関数(TkInfo.dll)\n//「編集・すべて既読にする」コマンドを実行します。これを実行すると、現在のフォルダ中の未読メールがすべて既読になります。\n//返り値(数値型)\n//返り値に意味はありません。\n##n = dllfunc("ClearAllUnread");\n
RemakeList=//RemakeList関数(TkInfo.dll)\n//パラメータで指定されたフォルダ用のメール一覧を作成し直します。何らかの理由でメール用のファイルを直接編集して保存した場合に使います。\n//この関数は秀丸メール本体側でのみ実行可能です。\n//返り値(数値型)\n//選択に成功すると1、失敗すると0を返します。\n##n = dllfunc( "RemakeList", "テストアカウント", "受信" );\n
OpenedEditorWnd=//OpenedEditorWnd関数(TkInfo.dll)\n//秀丸メール本体ウィンドウ上で現在選択しているメール(点線のフォーカスが付いてるメール)をエディタで開いている場合に、そのウィンドウハンドルを返します。選択しているメールがエディタで開いてない場合は0を返します。\n//この関数は、秀丸メール本体ウィンドウ上でしか実行できません。\n##wnd = dllfunc( "OpenedEditorWnd" );\nif( ##wnd != 0 ) {\n\tsetactivehidemaru ##wnd;\n}\n
NewMail=//NewMail関数(TkInfo.dll)\n//新規メールコマンドを実行します。マクロは新規メールで作成されたエディタ・ウィンドウ上で続行されます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します(普通、失敗することはありえませんが)。\n##n = dllfunc( "NewMail" );\n$$s = dllfuncstr( "NewEditorMacro" );\nif( $$s != "" ) execmacro $$s;\n
MakeReply=//MakeReply関数(TkInfo.dll)\n//この関数は、現在のメールに対する返信メールを作成します。マクロの実行は返信メール用のエディタ・ウィンドウ上で続行されます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "MakeReply" );\n$$s = dllfuncstr( "NewEditorMacro" );\nif( $$s != "" ) execmacro $$s;\n
MakeReplyCustom=//MakeReplyCustom関数(TkInfo.dll)\n//MakeReply関数と同じように、現在のメールに対する返信メールを作成します。ただし、返信時の宛先や添付ファイルの扱いなど、細かいオプションがパラメータで指定できます。他はMakeReply関数と同じです。\n//添付ファイルを付けるかどうかを指示します。\n##n = dllfunc( "MakeReplyCustom", "Single", "" );\n$$s = dllfuncstr( "NewEditorMacro" );\nif( $$s != "" ) execmacro $$s;\n
MakeForward=//MakeForward関数(TkInfo.dll)\n//現在のメールに対する転送メールを作成します。マクロの実行は転送メール用のエディタ・ウィンドウ上で続行されます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "MakeForward" );\n$$s = dllfuncstr( "NewEditorMacro" );\nif( $$s != "" ) execmacro $$s;\n
MakeAttachForward=//MakeAttachForward関数(TkInfo.dll)\n//「添付ファイルとして転送」コマンドを実行します。エディタ上で実行する事もできます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "MakeAttachForward" );\n$$s = dllfuncstr( "NewEditorMacro" );\nif( $$s != "" ) execmacro $$s;\n
MakeResentForward=//MakeResentForward関数(TkInfo.dll)\n//現在選択しているメールを対象に、「ファイル・そのまま転送」コマンドに相当する動作をします。\n##n = dllfunc("MakeResentForward", "PEH00775@nifty.ne.jp", "sendlater", "log");\n
OpenMail=//OpenMail関数(TkInfo.dll)\n//現在秀丸メールの本体ウィンドウで表示しているメールをエディタ・ウィンドウで開きます。秀丸メール本体ウィンドウ上でのみ実行できます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "OpenMail" );\n
OpenRootMail=//OpenRootMail関数(TkInfo.dll)\n//「関連するメール・返信元または転送元メール」コマンドを実行します。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "OpenRootMail" );\n
OpenReplyMail=//OpenReplyMail関数(TkInfo.dll)\n//「関連するメール・このメールへの返信メール」コマンドを実行します。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "OpenReplyMail" );\n
OpenForwardMail=//OpenForwardMail関数(TkInfo.dll)\n//「関連するメール・このメールを元にした転送メール」コマンドを実行します。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "OpenForwardMail" );\n
OpenLog=//OpenLog関数(TkInfo.dll)\n//「関連するメール・このメールのログ」コマンドを実行します。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。\n##n = dllfunc( "OpenLog" );\n
Sync=//Sync関数(TkInfo.dll)\n//現在エディタ・ウィンドウが開いているメールを秀丸メール本体側で選択した状態にします。エディタ・ウィンドウ上でのみ実行できます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。失敗する場合には、「現在のメールと一覧中のメールとの対応関係が分かりませんでした。」のようなメッセージが出てから復帰します。\n##n = dllfunc( "Sync" );\n
BackSync=//BackSync関数(TkInfo.dll)\n//秀丸メール本体ウィンドウで現在選択しているメールを、現在のエディタで表示させます。エディタ・ウィンドウ上でのみ実行できます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。失敗する場合には、「現在のメールと一覧中のメールとの対応関係が分かりませんでした。」のようなメッセージが出てから復帰します。\n##n = dllfunc( "BackSync" );\n
SyncGrep=//SyncGrep関数(TkInfo.dll)\n//現在エディタ・ウィンドウが開いているメールを検索結果の一覧上で選択した状態にします。エディタ・ウィンドウ上でのみ実行できます。\n//返り値(数値型)\n//成功すると1、失敗すると0を返します。失敗する場合には、「現在のメールと一覧中のメールとの対応関係が分かりませんでした。」のようなメッセージが出てから復帰します。\n##n = dllfunc( "SyncGrep" );\n
ClearUpdated_hmml=//ClearUpdated関数(TkInfo.dll)\n//現在のエディタ・ウィンドウ上での編集の操作による「編集マーク」を消去し、新規作成したかの状態に戻します。\n//返り値(数値型)\n//返り値に意味はありません。\n##n = dllfunc( "ClearUpdated" );\n
NewEditorMacro=//NewEditorMacro関数(TkInfo.dll)\n//新規メール/返信メール/転送メールコマンドで出てきたエディタ・ウィンドウの、自動実行用のマクロのファイル名を返します。\n//返り値(文字列型)\n//自動実行用のマクロが登録されている場合はそのファイル名、何も登録されてない場合は""を返します。\n##n = dllfunc( "NewMail" );\n$$s = dllfuncstr( "NewEditorMacro" );\nif( $$s != "" ) execmacro $$s;\n
SendMacro=//SendMacro関数(TkInfo.dll)\n//「あとで送信/今すぐ送信時」用に登録されたマクロファイル名を取り出します。\n//返り値(文字列型)\n//自動実行用のマクロが登録されている場合はそのファイル名、何も登録されてない場合は""を返します。\n$$s = dllfuncstr( "SendMacro" );\nif( $$s != "" ) execmacro $$s;\n
EnableEdit=//EnableEdit関数(TkInfo.dll)\n//送信済みメールや受信メールをエディタ・ウィンドウで開いている時に、「編集を許可」します。\n//エディタ・ウィンドウ上で、編集が禁止された状態になっている時にのみ有効な関数です。\n//編集できる状態かどうかは、秀丸マクロのreadonlyキーワードを使えば分かります。\n##n = dllfunc( "EnableEdit" );\n
BeginEditMail=//BeginEditMail関数(TkInfo.dll)\n//秀丸メール本体上で、マクロによるメールの書き換えを許可します。\n##n=dllfunc("BeginEditMail");\n##r=readonly;\n##b=browsemode;\nif(##r)readonlyswitch;\nif(##b) browsemodeswitch;\ngofiletop;\ninsert "テスト\\n";\n##n=dllfunc("SaveEditMail",0,1);\nif(##r)readonlyswitch;\nif(##b)browsemodeswitch;\n
SaveEditMail=//SaveEditMail関数(TkInfo.dll)\n//秀丸メール本体上で、マクロによるメールの書き換えを許可します。\n##n=dllfunc("BeginEditMail");\n##r=readonly;\n##b=browsemode;\nif(##r)readonlyswitch;\nif(##b) browsemodeswitch;\ngofiletop;\ninsert "テスト\\n";\n##n=dllfunc("SaveEditMail",0,1);\nif(##r)readonlyswitch;\nif(##b)browsemodeswitch;\n
CancelEditMail=//CancelEditMail関数(TkInfo.dll)\n##n=dllfunc("CancelEditMail");\n//BeginEditMailを呼んだけれども保存したくなかった場合に呼び出すための関数です。\n
SetHeader=//SetHeader関数(TkInfo.dll)\n//現在編集中のメールのヘッダ部分から指定されたヘッダを検索し、その内容を書き換えます。指定されたヘッダが見つからない場合は新たに追加します。\n//返り値\n//文字列型であり、常に""を返します。\n$$s = dllfuncstr( "SetHeader", "Reply-To", "abc@xyz" );\n
SetHeader2=//SetHeader2関数(TkInfo.dll)\n//書き換えたいヘッダが複数存在していた場合のための関数で、書き換えたいヘッダの番号を指定して、そのヘッダの内容を書き換える処理のみを行います。\n//返り値\n//数値型で、成功した場合は1、失敗した場合は0を返します。\n##n = dllfunc( "SetHeader2", "Received", "abc@xyz", 1 );\n
AddHeader=//AddHeader関数(TkInfo.dll)\n//現在編集中のメールにパラメータで指定されたヘッダおよび内容を追加します。\n//返り値\n//文字列型であり、常に""を返します。\n$$s = dllfuncstr( "AddHeader", "Bcc", "abc@xyz" );\n
DeleteHeader=//DeleteHeader関数(TkInfo.dll)\n//パラメータで指定されたヘッダを1つ削除します。\n//返り値\n//数値型で、実際にヘッダを削除した場合は1、削除しなかった場合(指定されたヘッダが無かった場合)は0を返します。DeleteHeader関数は同じヘッダを複数見つけても最初の1つしか削除しないので、すべて削除したい場合は返り値が0になるまで繰り返し呼び出す必要があります。\n##n = dllfunc( "DeleteHeader", "X-Priority" );\n
DeleteHeader2=//DeleteHeader2関数(TkInfo.dll)\n//削除したいヘッダが複数存在していた場合に、そのヘッダの番号を指定できる物です。\n//返り値\n//数値型で、実際にヘッダを削除した場合は1、削除しなかった場合(指定されたヘッダが無かった場合)は0を返します。DeleteHeader関数は同じヘッダを複数見つけても最初の1つしか削除しないので、すべて削除したい場合は返り値が0になるまで繰り返し呼び出す必要があります。\n##n = dllfunc( "DeleteHeader2", "X-Attach", 1 );\n
SetEditorAccount=//SetEditorAccount関数(TkInfo.dll)\n//現在のエディタが内部的に保持しているアカウントの情報を書き換えます。この関数で書き換えることができるのは、「新規メール」、「返信メール」、「転送メール」などで起動したエディタ上で、まだメールを保存する前の段階であることが必要です。既にメールを草稿フォルダなどに保存した場合や、送信済みメールを開いている場合にはアカウントの変更はできません。\n##n = dllfunc( "SetEditorAccount", "斉藤秀夫");\n
SetEditorAccount2=//SetEditorAccount2関数(TkInfo.dll)\n//現在編集中のメールの「From:」部分を他のアカウントのFrom部分相当に切り換えます。さらに、パラメータの指定により、このメールが所属するアカウントも変更します。\n##n = dllfunc( "SetEditorAccount2", "斉藤秀夫", 0);\n
AccountFrom=//AccountFrom関数(TkInfo.dll)\n//パラメータで指定されたアカウントに登録された個人情報から、新規メール作成時用の「From:」ヘッダの内容を生成して返します。\n//SetEditorAccountでアカウントを切り換えたときにメールのヘッダを書き換えるために用意されています。\n//返り値(文字列型)\n//「From:」の内容文字列です。中身が無い場合は""を返します。\n$$From = dllfuncstr( "AccountFrom", dllfuncstr("CurrentAccount") );\n
AccountReplyTo=//AccountReplyTo関数(TkInfo.dll)\n//AccountReplyTo関数は、同じくアカウントの情報から「Reply-To:」ヘッダの内容を生成して返します。\n//SetEditorAccountでアカウントを切り換えたときにメールのヘッダを書き換えるために用意されています。\n//返り値(文字列型)\n//「Reply-To:」の内容文字列です。中身が無い場合は""を返します。\n$$ReplyTo = dllfuncstr("AccountReplyTo", dllfuncstr("CurrentAccount") );\n
AddAttach=//AddAttach関数(TkInfo.dll)\n//パラメータで指定されたファイルを添付ファイルとして追加します。\n//送信用のメールのエディタ中でのみ実行可能です。それ以外で実行すると失敗します。\n##n = dllfunc("AddAttach", "c:\\\\temp.txt");\n
UndoAttach=//UndoAttach関数(TkInfo.dll)\n//パラメータで指定された添付ファイルを取り消します。\n//送信用のメールのエディタ中でのみ実行可能です。それ以外で実行すると失敗します。//受信したメールで添付ファイルを削除するには、DeleteAttach関数を使ってください。$$s = dllfuncstr("CurrentHeader", "X-Attach");\n##n = dllfunc("UndoAttach", $$s );\n
DeleteAttach=//DeleteAttach関数(TkInfo.dll)\n//現在メール中のパラメータで指定された添付ファイルを削除します。UndoAttachと違い、受信したメール中の添付ファイルを削除するのに使います。\n//返り値(数値型)\n//成功した場合は1、失敗した場合は0を返します。\n##n = dllfunc("DeleteAttach", dllfuncstr("CurrentHeader", "X-Attach"), 0);\n
RenameAttach=//RenameAttach関数(TkInfo.dll)\n//現在選択しているメール中の指定された添付ファイルのファイル名を変更します。\n//送信系のメールでも受信系のメールでもどこでも実行できます。ただし、受信系のメール上で実行した場合や秀丸メール本体ウィンドウ上で実行した場合には、メールが改変された扱いになることがあります。\n##n = dllfunc("RenameAttach", dllfuncstr("CurrentHeader", "X-Attach"), "aaa.txt");
GetDontOrikaeshi=//GetDontOrikaeshi関数(TkInfo.dll)\n//現在の行が折り返し禁止になっているかどうかを返します。範囲選択されている場合は選択された範囲全体について折り返し禁止かどうか(または混在しているかどうか)を返します。\n//返り値(数値型)\n//折り返し禁止の場合は1,折り返し禁止でない場合(普通の場合)は0を返します。\n//範囲選択している場合で、その選択された範囲内に折り返し禁止行と折り返し禁止でない行が混在している場合は2を返します。\n##n = dllfunc("GetDontOrikaeshi");\n
SwitchDontOrikaeshi=//SwitchDontOrikaeshi関数(TkInfo.dll)\n//エディタの「編集・現在行の折り返し禁止」コマンドを実行します。範囲選択した状態で呼び出せば、選択した範囲について折り返し禁止のON/OFF切り換えをします。\n//SwitchDontOrikaeshi関数は、編集可能なエディタ上でしか実行できません。\n//返り値(数値型)\n//返り値には意味がありません。正しく折り返し禁止を切り換えたかどうかも返しません。\n##n = dllfunc("SwitchDontOrikaeshi");\n
GetEncodedSize=//GetEncodedSize関数(TkInfo.dll)\n//現在のメールをエンコードした場合のサイズを返します。送信用のメールを作成している状態で、そのメールが送信した場合に何バイトになるのか知る必要がある場合に使います。\n//返り値(数値型)\n//メールのサイズを返します。内部的に一度エンコードして計算した値を返します。\n//サイズの計算に失敗した場合には0を返します。(エラーの内容は知ることができません)\n##n = dllfunc("GetEncodedSize");\n
CreateMessageId=//CreateMessageId関数(TkInfo.dll)\n//新しいメッセージIDを1つ生成します。\n//返り値(文字列型)\n//メッセージID文字列です。前後が<>で囲まれた形で返ります。\n$$from = dllfuncstr("CurrentHeader","From");\n$$from = dllfuncstr("SetEmailOnly",$$from);\n$$id = dllfuncstr("CreateMessageId",$$from);\n##n = dllfunc("SetHeader","Message-Id", $$id);\n
Account=//Account関数(TkInfo.dll)\n//現在の秀丸メールに登録されているアカウントの名前を返します。パラメータとしてアカウントの番号を指定します。この関数は秀丸メール本体側でのみ使えます。\n//返り値(文字列型)\n//アカウント名です。該当するアカウントが無い場合(例えば、2つ登録してある場合に2番を指定した場合)には""を返します。\n$$TopAccount = dllfuncstr( "Account", 0 );\n
CurrentAccount=//CurrentAccount関数(TkInfo.dll)\n//フォルダ枠中で、現在選択されているアカウント(または現在選択されているフォルダを含むアカウント)のアカウント名を返します。または、エディタ上で実行した場合には、現在のエディタが開いているメールのアカウントを返します。\n//返り値(文字列型)\n//アカウント名文字列を返します。\n$$s = dllfuncstr( "CurrentAccount" );\n
CurrentAccountGroup=//CurrentAccountGroup関数(TkInfo.dll)\n//同じく、フォルダ枠中では、現在何らかのアカウントグループが選択されていればそのアカウントグループ名を返し、その他が選択されてる場合は、現在選択されているアカウント(または現在選択されているフォルダを含むアカウント)の属するアカウントグループ名を返します。\n//返り値(文字列型)\n//CurrentAccountGroup関数は、アカウントグループ名を返します。アカウントグループに属してない場合は""を返します。\n$$s = dllfuncstr("CurrentAccountGroup");\n
CurrentFolder=//CurrentFolder関数(TkInfo.dll)\n//フォルダ枠中で現在選択しているフォルダの名前を返します。または、エディタ上で実行した場合には、現在のエディタが開いているメールのフォルダを返します。\n//返り値(文字列型)\n//現在選択しているフォルダの名前です。\n$$folder = dllfuncstr( "CurrentFolder" );\n
SelectFolder=//SelectFolder関数(TkInfo.dll)\n//フォルダ枠の中で、特定のフォルダまたはアカウントを選択します。パラメータは2つあり、1つ目がアカウント名、2つ目がフォルダ名です。\n//返り値(数値型)\n//選択に成功すると1、失敗すると0を返します。\n##n = dllfunc( "SelectFolder", "テストアカウント", "受信" );\n
ExpandFolder=//ExpandFolder関数(TkInfo.dll)\n///現在選択しているフォルダまたはアカウントの折りたたみ/展開状態を切り替えます。\n//アカウントを選択している状態でExpandFolderを使って展開した場合、自動的に「受信」フォルダが選択されます。\n//パラメータ1(数値型)\n//展開する場合は1、折りたたむ場合は0を指定します。\n//返り値(数値型)\n//返り値に意味はありません。\n##n = dllfunc( "ExpandFolder", 1 );\n
NextFolder=//NextFolder関数(TkInfo.dll)\n//「下のフォルダ」コマンドを実行します。このコマンドは現在選択しているフォルダより1つ下のフォルダを選択するコマンドです。//フォルダを選択せずに、下方向のフォルダの名前だけが知りたい場合には、GetNextFolder/GetPrevFolder関数を使います。\n//返り値(数値型)\n//成功すると1を返します。下にこれ以上フォルダがない場合は0を返します。\n##n = dllfunc("NextFolder");\n
PrevFolder=//PrevFolder関数(TkInfo.dll)\n//「上のフォルダ」を選択します。\n//フォルダを選択せずに、上方向のフォルダの名前だけが知りたい場合には、GetPrevFolder関数を使います。\n//返り値(数値型)\n//成功すると1を返します。上にこれ以上フォルダがない場合は0を返します。\n##n = dllfunc("PrevFolder");\n
GetNextFolder=//GetNextFolder関数(TkInfo.dll)\n//パラメータで指定されたフォルダの下にあるフォルダの名前を返します。\n$$s = dllfuncstr("GetNextFolder","テストアカウント","受信\\\\テスト");\n##x = strstr($$s,"\\\\");\nif(##x>= 0){\n\t$$account = leftstr($$s,##x);\n\t$$folder = midstr($$s,##x+1,256);\n}else{\n\t$$account = $$s;\n\t$$folder = "";\n}\n
GetPrevFolder=//GetPrevFolder関数(TkInfo.dll)\n//パラメータで指定されたフォルダの上にあるフォルダの名前を返します。\n$$s = dllfuncstr("GetPrevFolder","テストアカウント","受信\\\\テスト");\n##x = strstr($$s,"\\\\");\nif(##x>= 0){\n\t$$account = leftstr($$s,##x);\n\t$$folder = midstr($$s,##x+1,256);\n}else{\n\t$$account = $$s;\n\t$$folder = "";\n}\n
GetFolderExpandState=//GetFolderExpandState関数(TkInfo.dll)\n//パラメータで指定されたフォルダの配下にさらにフォルダがあるかどうか、ある場合はそれが折り畳まれているか、それとも展開されているかを返します。\n##n = dllfunc( "GetFolderExpandState");\n##n = dllfunc( "GetFolderExpandState", "", "受信");\n##n = dllfunc( "GetFolderExpandState", "テストアカウント", "受信\\テスト");\n
GetFolderHotState=//GetFolderHotState関数(TkInfo.dll)\n//パラメータで指定されたフォルダが未読フォルダ状態になっているかどうかを返します。\n##n = dllfunc( "GetFolderHotState");\n##n = dllfunc( "GetFolderHotState", "", "受信");\n##n = dllfunc( "GetFolderHotState", "テストアカウント", "受信\\テスト");\n
GetFolderMailCount=//GetFolderMailCount関数(TkInfo.dll)\n//パラメータで指定されたフォルダのメール数を返します。\n##n = dllfunc( "GetFolderMailCount");\n##n = dllfunc( "GetFolderMailCount", "", "", "unread");\n##n = dllfunc( "GetFolderMailCount", "テストアカウント", "受信\\テスト", "recent");\n
SelectAccountGroup=//SelectAccountGroup関数(TkInfo.dll)\n//パラメータで指定されたアカウントグループそのものを選択します。\n##n = dllfunc( "SelectAccountGroup", "テストグループ" );
Exit_hmml=//Exit関数(TkInfo.dll)\n//秀丸メールの本体ウィンドウを終了します。秀丸メール本体ウィンドウ上でのみ実行可能で、さらに、この関数を呼んだ後はすみやかにendmacroする必要もあります。\n##n = dllfunc( "Exit" );\nendmacro;
Delete_hmml=//Delete関数(TkInfo.dll)\n//現在選択しているメール(複数の場合は複数)を完全に削除します。この関数は秀丸メール本体ウィンドウ上でしか実行できません。\n//通常の削除(ゴミ箱フォルダへの移動)がしたい場合には、Move関数を使ってください。\n##n = dllfunc( "Delete", 0 );\n
Move=//Move関数(TkInfo.dll)\n//現在選択しているメール(複数の場合は複数)を他のフォルダに移動します。\n##n = dllfunc( "Move", "", "ゴミ箱" );\n##n = dllfunc( "Move", "", "受信\\テスト" );
Copy_hmml=//Copy関数(TkInfo.dll)\n//現在選択しているメール(複数の場合は複数)を他のフォルダにコピーします。コピー先に現在のフォルダを指定すると、現在のフォルダに二重にメールを作成します。\n##n = dllfunc( "Copy", "", "受信\\テスト" );\n
FilterDlg=//FilterDlg関数(TkInfo.dll)\n//振り分けダイアログボックスを表示します。秀丸メール本体ウィンドウ上でのみ実行できます。\n##n = dllfunc( "FilterDlg" );\n
DoFilter=//DoFilter関数(TkInfo.dll)\n//この関数は、パラメータで指定された各種の振り分けを実行します。秀丸メール本体ウィンドウ上でのみ実行できます。\n//パラメータ1:振り分けモードです。\n//パラメータ2: 受信したメールの中での対象です。パラメータ1に1または3を指定している場合のみ有効です。\n//パラメータ3: マークしたメールを除外するかどうかのフラグです。\n##n = dllfunc( "DoFilter", 0, 0, 0 );\n
RefreshMailList=//RefreshMailList関数(TkInfo.dll)\n//「メール一覧の作成し直し」を実行します。パラメータの指定によって、作成し直しのやり方が指定できます。\n//秀丸メール本体ウィンドウ上でのみ実行できます。また、対象となるのは現在選択しているフォルダのみです。\n//外部のソフトを使ってメール用のファイルを直接変更した場合には、この関数を使ってメール一覧の作成し直しするか、または秀丸メールを起動しなおすことが必要です。\n##n = dllfunc( "RefreshMailList");\n
MakeFolder=//MakeFolder関数(TkInfo.dll)\n//現在選択しているフォルダの配下に新しいフォルダを作成します。\n//この関数は秀丸メール本体ウィンドウ上でのみ実行できます。\n//MakeFolder関数でのパラメータ1(文字列型)\n// フォルダ名を指定します。\n// DeleteFolder関数にはパラメータはありません。\n##n = dllfunc( "MakeFolder", "test");\n
DeleteFolder=//DeleteFolder関数(TkInfo.dll)\n//DeleteFolder関数は、現在選択しているフォルダを削除します。\n//この関数は秀丸メール本体ウィンドウ上でのみ実行できます。\n// DeleteFolder関数は、現在選択しているフォルダに何もメールが無ければそのまま削除し、何かメールが残っている場合は確認メッセージを出してから削除します。\n##n = dllfunc( "DeleteFolder");\n
CheckDuplication=//CheckDuplication関数(TkInfo.dll)\n//重複メールのチェックコマンドを実行します。// この関数は秀丸メール本体ウィンドウ上でのみ実行できます。\n//パラメータ1(文字列型):動作についてのモードを指定します。\n//パラメータ2、パラメータ3(文字列型):パラメータ2およびパラメータ3で、チェック対象のフォルダを指定します。パラメータ2側ではアカウント名、パラメータ3側ではフォルダ名を指定します。\n##n = dllfunc( "CheckDuplication", "batch", dllfuncstr("CurrentAccount") );\n
NextUnread=//NextUnread関数(TkInfo.dll)\n//「下の未読メール」コマンドを実行します。エディタ・ウィンドウ中でも実行できます。\n##n = dllfunc( "NextUnread" );\n
PrevUnread=//PrevUnread関数(TkInfo.dll)\n//「上の未読メール」コマンドを実行します。\n//秀丸メール本体ウィンドウで実行する場合で、全般的な設定によってはフォルダをまたがって未読メールを表示する場合もあります。\n##n = dllfunc( "PrevUnread" );\n
NextMail=//NextMail関数(TkInfo.dll)\n//「下のメール」コマンドを実行します。エディタ・ウィンドウ中でも実行できます。\n##n = dllfunc( "NextMail" );\n
PrevMail=//PrevMail関数(TkInfo.dll)\n//「上のメール」コマンドを実行します。\n##n = dllfunc( "PrevMail" );\n
NextUnreadPage=//NextUnreadPage関数(TkInfo.dll)\n//「下の未読ページ」コマンドを実行します。エディタ・ウィンドウ中でも実行できます。　秀丸メール本体ウィンドウで実行する場合で、全般的な設定によってはフォルダをまたがって未読メールを表示する場合もあります。\n##n = dllfunc( "NextUnreadPage" );\n
PrevUnreadPage=//PrevUnreadPage関数(TkInfo.dll)\n//「上の未読ページ」コマンドを実行します。\n//秀丸メール本体ウィンドウで実行する場合で、全般的な設定によってはフォルダをまたがって未読メールを表示する場合もあります。\n##n = dllfunc( "PrevUnreadPage" );\n
NextPage2=//NextPage2関数(TkInfo.dll)\n//秀丸エディタのnextpageと同様に、「次のページ」コマンドを実行します。ただし、こちらの関数の場合は、１行しかスクロールできない場合でも確実に１ページ分スクロールさせます。\n//または、もし画面にメール末尾まで表示されていた場合には、スクロールせずに0を返します\n##n = dllfunc( "NextPage2" );
NextUnreadCustom=//NextUnreadCustom関数(TkInfo.dll)\n//秀丸メール側の「全般的な設定・メール一覧・閲覧関係」で「下の未読メール等で、下に未読が無かった場合」のオプションを一時的に変更して「下の未読メール」コマンドを実行します。\n##n = dllfunc( "NextUnreadCustom", "");\n
PrevUnreadCustom=//PrevUnreadCustom関数(TkInfo.dll)\n//秀丸メール側の「全般的な設定・メール一覧・閲覧関係」で「下の未読メール等で、下に未読が無かった場合」のオプションを一時的に変更して「上の未読メール」コマンドを実行します。\n##n = dllfunc( "PrevUnreadCustom", "");\n
NextPrevCustom=//NextPrevCustom関数(TkInfo.dll)\n//秀丸メールの閲覧関係の設定に関係なく、細かいオプション指定で「次のメール/次の未読メール/次の未読ページ/次のマーク」系および「前の××」系コマンドを実行します。\n##n = dllfunc( "NextPrevCustom", "unread", "next", "mail", "over");\n
IsGrepWndBrowseMode=//IsGrepWndBrowseMode関数(TkInfo.dll)\n//現在のエディタ上での「下の未読メール」などのコマンドが検索結果ウィンドウ上で動作するかどうかを返します。\nif( dllfunc( "IsGrepWndBrowseMode") ) {\n\tmessage "検索結果上では使えません。";\n}\n//備考\n//検索結果上で動作するモードから抜け出すには、検索結果ウィンドウよりも秀丸メール本体ウィンドウを手前に移動すればいいです。たとえばSetMainWndTop関数を実行してからエディタに戻るなどすればいいです。\n
IsThreadView=//IsThreadView関数(TkInfo.dll)\n//現在のメール一覧枠での表示がスレッド表示か一覧表示かを返します。\n##IsThreadView = dllfunc("IsThreadView");\n
SetThreadView=//SetThreadView関数(TkInfo.dll)\n//現在のメール一覧枠のスレッド表示か一覧表示かを切り替えます。\n//パラメータ1\n//\tスレッド表示にしたい場合は1、一覧表示にしたい場合は0を指定します。\n##n = dllfunc("SetThreadView", 1);\n
SortMethod=//SortMethod関数(TkInfo.dll)\n//現在のメール一覧枠の一覧のソート方法を返します。スレッド表示になっている場合でも一覧側のソート方法(内部的に持っている値)を返します。\n##n = dllfunc("SortMethod");\n
SetSortMethod=//SetSortMethod関数(TkInfo.dll)\n//メール一覧枠の一覧ページのソート方法を指定します。\n##n = dllfunc("SetSortMethod", 0);\n
ViewArea=//ViewArea関数(TkInfo.dll)\n//メール一覧枠の「範囲」の所の現在のモードを返します。\n##n = dllfunc("ViewArea");\n
SetViewArea=//SetViewArea関数(TkInfo.dll)\n//メール一覧枠の「範囲」を切り替えます。\n##n = dllfunc("SetViewArea", 0);
MailCount=//MailCount関数(TkInfo.dll)\n//現在一覧に表示されているメールの個数を返します。フォルダ中のメール総数を得るにはMailCountAll関数を使います。\n##n = dllfunc("MailCount");\n
MailCountAll=//MailCountAll関数(TkInfo.dll)\n//現在選択されているフォルダ中のメール個数を返します。\n##n = dllfunc("MailCountAll");\n
MailIndex=//MailIndex関数(TkInfo.dll)\n//現在のメール一覧枠の一覧側で、現在選択しているメールの先頭からの位置を返します。スレッド表示の場合はうまく動作しません。\n//メールを複数選択している場合には、一覧中のカーソル「四角い枠」の場所を返します。\n##n = dllfunc("MailIndex");\n
SetMailIndex=//SetMailIndex関数(TkInfo.dll)\n//メール一覧枠の一覧側で、特定のメールを選択します。スレッド表示の場合はうまく動作しません。\n##n = dllfunc("SetMailIndex", 0);
LockSelection=//LockSelection関数(TkInfo.dll)\n//これらの関数は、複数のメールを選択している時に、その選択されたメール1つ1つに対してマクロで処理するために使います。\n//複数選択しているメールを1つ1つ選択してマクロ処理させるには、まずLockSelectionを呼んで、次にEnumSelection関数が0を返すまでループし、最後にUnlockSelectionを呼ぶという手順になります。EnumSelection関数を1回呼ぶたびに、複数選択していたメールを1つずつ選択していきます。\n//現在選択しているメールについての情報を取得し、次に呼ばれるEnumSelectionに備えます。\n//パラメータはありません。\n//返り値は数値型で、選択しているメールの個数となります。0が返った場合はメールを何も選択していないことを意味し、1が返った場合は複数選択されてないことを意味します。\n//例(特定メールを削除する例)\n\nloaddll "tkinfo.dll";\n\n##count = dllfunc("SelectedMailCount");\n\nif( ##count == 0 ) {\n\tendmacro;\n}\n##n = dllfunc("LockSelection");\nwhile(1) {\n\t##n = dllfunc("EnumSelection", 1);\n\tif( ##n == 0 ) {\n\t\tbreak;\n\t}\n\tif( dllfuncstr("CurrentHeader", "Subject") == "削除せよ" ) {\n\t\t##n = dllfunc("Delete");\n\t}\n}\n##n = dllfunc("UnlockSelection", 0);\n\n
EnumSelection=//EnumSelection関数(TkInfo.dll)\n//これらの関数は、複数のメールを選択している時に、その選択されたメール1つ1つに対してマクロで処理するために使います。\n//複数選択しているメールを1つ1つ選択してマクロ処理させるには、まずLockSelectionを呼んで、次にEnumSelection関数が0を返すまでループし、最後にUnlockSelectionを呼ぶという手順になります。EnumSelection関数を1回呼ぶたびに、複数選択していたメールを1つずつ選択していきます。\n//複数選択していたメール1つ1つを選択します。最初は一番上のメールを選択し、その次はその下のメール、…というように、上から下方向に選択していきます。\n//数値型のパラメータが1つあります。現在のバージョンではここには必ず1を指定してください。0を指定すると、選択する動作をせずに、値だけ返します。しかし、現状ではその返り値を有効利用することはできません。\n//選択に成功した場合は0でも-1でも無く、何らかの値を返します。この値は秀丸メールの内部に持っているメールについての情報の先頭アドレスですが、現在の所、直接利用することはできません。\n//スレッド表示の場合、選択されたスレッドの中で折りたたまれた物はすべて展開されてしまいます。\n//例(特定メールを削除する例)\n\nloaddll "tkinfo.dll";\n\n##count = dllfunc("SelectedMailCount");\n\nif( ##count == 0 ) {\n\tendmacro;\n}\n##n = dllfunc("LockSelection");\nwhile(1) {\n\t##n = dllfunc("\vEnumSelection", 1);\n\tif( ##n == 0 ) {\n\t\tbreak;\n\t}\n\tif( dllfuncstr("CurrentHeader", "Subject") == "削除せよ" ) {\n\t\t##n = dllfunc("Delete");\n\t}\n}\n##n = dllfunc("UnlockSelection", 0);\n\n
UnlockSelection=//UnlockSelection関数(TkInfo.dll)\n//LockSelection関数が取得した内部データを解放すると同時に、パラメータの指定によっては元の選択状態を復元しようと努力します。\n//パラメータ1は数値型で、ここに0を指定すると単純に内部データの解放のみを行います。1を指定すると、元の選択状態を復元しようと努力します。たとえば複数選択していたメールの1つでも削除されている場合はパラメータ1に1を指定しても復元されませんが、メールが無くなってない場合は大抵うまく復元できるはずです。\n//UnlockSelect関数の返り値は、パラメータ1に1を指定して選択状態の復元に成功した場合は1、そうでない場合は0を返します。\n//UnlockSelection関数を呼ばずにマクロを終了しても、特に支障は無いはずです。でも念のために呼んでください。\n//LockSelection関数が0を返した場合はUnlockSelectionを呼ばなくても全く支障ありません。\n//例(特定メールを削除する例)\n\nloaddll "tkinfo.dll";\n\n##count = dllfunc("SelectedMailCount");\n\nif( ##count == 0 ) {\n\tendmacro;\n}\n##n = dllfunc("LockSelection");\nwhile(1) {\n\t##n = dllfunc("EnumSelection", 1);\n\tif( ##n == 0 ) {\n\t\tbreak;\n\t}\n\tif( dllfuncstr("CurrentHeader", "Subject") == "削除せよ" ) {\n\t\t##n = dllfunc("Delete");\n\t}\n}\n##n = dllfunc("UnlockSelection", 0);\n\n
SelectedMailCount=//SelectedMailCount関数(TkInfo.dll)\n//現在選択されているメールの数を返します。\n//例(特定メールを削除する例)\n\nloaddll "tkinfo.dll";\n\n##count = dllfunc("\vSelectedMailCount");\n\nif( ##count == 0 ) {\n\tendmacro;\n}\n##n = dllfunc("LockSelection");\nwhile(1) {\n\t##n = dllfunc("EnumSelection", 1);\n\tif( ##n == 0 ) {\n\t\tbreak;\n\t}\n\tif( dllfuncstr("CurrentHeader", "Subject") == "削除せよ" ) {\n\t\t##n = dllfunc("Delete");\n\t}\n}\n##n = dllfunc("UnlockSelection", 0);\n
StartTransmitAll=//StartTransmitAll関数(TkInfo.dll)\n//「すべて送受信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「すべて送受信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「すべて送受信」が実行されます。\n##n = dllfunc("StartTransmitAll");\n
StartReceive=//StartReceive関数(TkInfo.dll)\n//「受信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「受信」のコマンドを実行するためのメッセージをメッセージキューにPostします。 このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「受信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("StartReceive");\n\n
StartSendRemain=//StartSendRemain関数(TkInfo.dll)\n//「未送信メールの送信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「未送信メールの送信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「未送信メールの送信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("StartSendRemain");\n
StartReceiveAll=//StartReceiveAll関数(TkInfo.dll)\n//「すべて受信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「すべて受信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「すべて受信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("StartReceiveAll");\n
StartSendRemainAll=//StartSendRemainAll関数(TkInfo.dll)\n//「すべて送信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「すべて送信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「すべて送信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("StartSendRemainAll");\n
TransmitAll=//TransmitAll関数(TkInfo.dll)\n//「すべて受信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「すべて受信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「すべて受信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("TransmitAll");\n
Receive=//Receive関数(TkInfo.dll)\n//「受信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「受信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「受信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("Receive");\n
SendRemain=//SendRemain関数(TkInfo.dll)\n//「未送信メールの送信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「未送信メールの送信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「未送信メールの送信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("SendRemain");\n
ReceiveAll=//ReceiveAll関数(TkInfo.dll)\n//「すべて受信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「すべて受信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「すべて受信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("ReceiveAll");\n
SendRemainAll=//SendRemainAll関数(TkInfo.dll)\n//「すべて送信」のコマンドを起動するように秀丸メール側に指示します。専門的な言い方をすると、「すべて送信」のコマンドを実行するためのメッセージをメッセージキューにPostします。\n//このコマンドを実行した場合には、すみやかにマクロを終了してください。そうすると、マクロ終了と同時に「すべて送信」が実行されます。\n//マクロを待機させながら送受信するので、送受信の最中には他のマクロが実行できません。単純に送受信が起動すればいい場合には、なるべくこちらのStartXXXX系を使ってください。\n##n = dllfunc("SendRemainAll");\n
TransmitCustom=//TransmitCustom関数(TkInfo.dll)\n//アカウントを指定して送受信します。送受信が終わるまで待機します。\n//アカウントは複数指定でき、しかも、アカウント毎に「送信のみ/受信のみ/送受信/リモートメールの一覧取得」が指定できます。\n##n = dllfunc("TransmitCustom", "アカウント1:R,アカウント2:S");\n
StartTransmitCustom=//StartTransmitCustom関数(TkInfo.dll)\n//アカウントを指定して送受信します。送受信の開始を指示してすぐに関数から復帰します。\n//アカウントは複数指定でき、しかも、アカウント毎に「送信のみ/受信のみ/送受信/リモートメールの一覧取得」が指定できます。\n##n = dllfunc("StartTransmitCustom", "アカウント1:R,アカウント2:S");\n
SendNow=//SendNow関数(TkInfo.dll)\n//エディタ上で「今すぐ送信」のコマンドを実行し、終了するまでマクロを待機させます。\n//送信の結果については、SentMailCount、TransmitCanceled、TransmitErrorを使って得てください。\n//普通、「今すぐ送信」が終了するとエディタも終了しますが、SendNow関数で送信した場合、エディタは終了せずにマクロの処理も続行されます。このままエディタを放置してマクロだけ終了してしまうともう一度同じメールを「今すぐ送信」などできてしまうので、exit関数やclosehidemaruforced等を使ってエディタを終了させてください。\nloaddll "tkinfo.dll";\nmessage $$macro;\nif( $$macro != "" ) {\n\t##n = dllfunc("SetCancel", 0);\n\texecmacro $$macro;\n\t##n = dllfunc("GetCancel");\n\tif( ##n != 0 ) {\n\t\tendmacro;\n\t}\n}\n##n = dllfunc("\vSendNow");\nif( ##n != 0 ) {\n\texit;\n}\n
SendLater=//SendLater関数(TkInfo.dll)\n//現在のメールを未送信フォルダに保存し、そのままマクロ実行を続行します。「あとで送信」を実行しつつもマクロだけ続行するような感じです。\n//この関数でメールを「あとで送信」にした場合、マクロ登録の所で登録されている「あとで送信/今すぐ送信時」のマクロは自動実行されません。そこに登録されているマクロを実行したい場合には、別途、SetCancel/GetCancel/SendMacro関数を使って例のように処理してください。\nloaddll "tkinfo.dll";\nmessage $$macro;\nif( $$macro != "" ) {\n\t##n = dllfunc("SetCancel", 0);\n\texecmacro $$macro;\n\t##n = dllfunc("GetCancel");\n\tif( ##n != 0 ) {\n\t\tendmacro;\n\t}\n}\n##n = dllfunc("\vSendLater");\nif( ##n != 0 ) {\n\texit;\n}\n
SaveDraft=//SaveDraft関数(TkInfo.dll)\n//現在のメールを草稿フォルダに保存し、そのままマクロ実行を続行します。既に草稿フォルダ配下のサブフォルダに保存されているメールをSaveDraftした場合は、同じフォルダに上書き保存されます。\n//送信系メールを編集しているエディタ上でしか実行できません。\n##n = dllfunc("SaveDraft");\n
SaveDraft2=//SaveDraft2関数(TkInfo.dll)\n//草稿フォルダの下にさらにサブフォルダがある場合に、そのサブフォルダに保存するための関数です。パラメータとしてサブフォルダ名を指定します。こちらもSaveDraft関数と同様に、保存後もマクロ実行を続行します。\n//送信系メールを編集しているエディタ上でしか実行できません。\n##n = dllfunc("SaveDraft2", "sub");\n
SetTargetDraftFolder=//SetTargetDraftFolder関数(TkInfo.dll)\n//現在のメールをユーザーが「ファイル・草稿に保存」とした時に、パラメータで指定した草稿フォルダ配下のサブフォルダに保存するよう、保存先を予約します。関数を呼んだだけでは実際の保存はしません。\n//送信系メールを編集しているエディタ上でしか実行できません。\n##n = dllfunc("SetTargetDraftFolder", "sub");\n
AlterSave=//AlterSave関数(TkInfo.dll)\n//現在編集中のメール(受信系メールまたは送信済みメール)を改変保存します。\n//送信済みメールを保存すると勝手に草稿フォルダに保存されてしまいますが、そうではなくて、送信済みメールを改変保存したい時に使います。\n//この関数はメールを編集しているエディタ上でしか実行できません。\n##n = dllfunc("AlterSave");\n
RecvMailCount=//RecvMailCount関数(TkInfo.dll)\n//直前の送受信動作で受信したメールの数を返します。秀丸メール本体ウィンドウ上でのみ実行できます。\n//直前にリモートメールコマンドを実行している場合には、メール個数には0が返ってきてしまいます。\n//振り分け動作で「メールの受信をお知らせしない」となったメールについてもカウントの対象となります。従って、受信後のステータスバー部分に出る「n通受信しました」のnの値とRecvMailCount関数の返り値は一致しないことがあります。\n##n = dllfunc( "RecvMailCount" );\nmessage str(##n) + "通受信しました。"\n
RecvMailCountShow=//RecvMailCountShow関数(TkInfo.dll)\n//受信したメール数を返しますが、振り分けによって「メール受信をお知らせしない」となったメールについては除外してカウントします。メールを受信した直後にステータスバーに表示される「n通受信しました」と同じ値を返します。\n##n = dllfunc( "RecvMailCountShow" );\n
RecvMailCountExcludePartial=//RecvMailCountExcludePartial関数(TkInfo.dll)\n//RecvMailCountShowの返す関数の値から、さらに、分割されたメールについてのメール数を除外した値を返します。\n##n = dllfunc( "RecvMailCountExcludePartial" );\n
SentMailCount=//SentMailCount関数(TkInfo.dll)\n//直前の送受信動作で送信したメールの数を返します。この関数は秀丸メール本体上でしか実行できません。\n##n = dllfunc( "SentMailCount" );\nmessage str(##n) + "通送信しました。"\n
TransmitCanceled=//TransmitCanceled関数(TkInfo.dll)\n//直前の送受信系コマンドの最中にキャンセルされたかどうかを返します。キャンセルされた場合でも何通かのメールは送信または受信されていることがあります。\n##n = dllfunc("TransmitCanceled");
TransmitError=//TransmitError関数(TkInfo.dll)\n//直前の送受信系コマンドでエラーが起きたかどうかを返します。エラーは大抵送受信の途中の段階で起きるので、エラーの場合でも何通かのメールが受信または送信されていることがあります。\n##n = dllfunc("TransmitError");\n
SetCancel=//SetCancel関数(TkInfo.dll)\n//「あとで送信/今すぐ送信時」および「秀丸メール終了時」に呼び出された自動実行マクロで、「あとで送信/今すぐ送信」のコマンドまたは秀丸メール終了をキャンセルさせたり、またはキャンセルを取り消したりします。\n//SetCancel関数を呼ばない場合、コマンドは通常通り実行されます。\n##n = dllfunc("SetCancel", 1);\n
GetCancel=//GetCancel関数(TkInfo.dll)\n//SetCancelで設定された値を取り出します。パラメータはありません。\n##n = dllfunc("GetCancel");\n
ShowNotifyWnd=//ShowNotifyWnd関数(TkInfo.dll)\n//メールを受信した後に「n通受信しました」を表示する用のメッセージボックスを表示します。表示内容には任意の文字列が指定できるので、主に、メッセージを出したままマクロの実行も継続させたい時に便利です。\n//(message文やquestion文、Bypass_MessageBox関数では、メッセージボックス中のボタンを押すまでマクロが停止します)\n##n = dllfunc("ShowNotifyWnd", "新着の通知", "特殊な新着メールがあります。");\n
HideNotifyWnd=//HideNotifyWnd関数(TkInfo.dll)\n//「n通受信しました」のメッセージがもし出ていれば、そのウィンドウを消去します。\n##n = dllfunc("HideNotifyWnd");\n
GetNotifyWnd=//GetNotifyWnd関数(TkInfo.dll)\n//「n通受信しました」のメッセージがもし出ていれば、そのウィンドウのハンドルを返します。出ていなければ0を返します。\n##n = dllfunc("GetNotifyWnd");\n
RemoteMailReload=//RemoteMailReload関数(TkInfo.dll)\n//「リモートメール - 現在メールの再受信」を実行します。\n//複数のメールを選択して実行した場合には、最低1つでも受信または削除すると、成功した扱いとなります。\n##n = dllfunc( "RemoteMailReload" ) ;\n
RemoteMailDelete=//RemoteMailDelete関数(TkInfo.dll)\n//「リモートメール - 現在メールを削除」を実行します\n//複数のメールを選択して実行した場合には、最低1つでも受信または削除すると、成功した扱いとなります。\n##n = dllfunc( "RemoteMailDelete" ) ;\n
IsTransmitting=//IsTransmitting関数(TkInfo.dll)\n//現在秀丸メールが送受信の作業中かどうかを返します。送受信の作業中にさらに送受信系のコマンドを実行すると失敗します。\n//「全般的な設定」のダイアログボックスが出ている時など、送受信ができない状態の場合にも「送受信中」と同じ扱いとなります。\n//注意事項\n//IsTransmitting関数が0を返すまでマクロ待機(ループ)させて待つことはできません。送受信の最中にマクロが起動された場合、マクロが終了するまでIsTransmittingが0を返すことは無い作りになっていて、送受信が終わっても永久に待機し続けてしまいます。\nif( dllfunc( "IsTransmitting" ) ) {\n\tmessage "送受信できません。";\n\tendmacro;\n}\n
RecvMailCountInFolder=//RecvMailCountInFolder関数(TkInfo.dll)\n//現在選択しているフォルダの中で、直前の受信動作で受信したメールの数を返します。秀丸メール本体ウィンドウ上でのみ実行できます。\n//ただし、SelectRecvMailまたはSelectRecvMailInFolderで選択したメールはカウント対象からはずれます。SelectRecvMail等を連続実行していくと、そのうちこのRecvMailCountInFolderの返す値は0になります。\n##n = dllfunc( "RecvMailCountInFolder" );\nmessage "このフォルダでは、" + str(##n) + "通のメールを受信しています。";\n
SelectRecvMailInFolder=//SelectRecvMailInFolder関数(TkInfo.dll)\n//現在選択しているフォルダ中で、直前の受信動作によって受信したメールを1つ選択します。選択したメールは、「新着メール」のフラグがOFFになり、また、RecvMailCountInFolderの返す値も減っていきます。\n//「新着メール」のフラグがOFFになるのは、秀丸メール内部で「SelectRecvMail済みかどうか」を判定するのに仕方のない処置です。\nif( dllfunc( "SelectRecvMailInFolder" ) ) {\n\tmessage str(##n) + "受信したメールを選択しました。";\n}\n
SelectRecvMail=//SelectRecvMail関数(TkInfo.dll)\n//直前の受信動作によって受信したメールを1つ選択します。現在のフォルダにある場合はそれを、現在のフォルダに無い場合は他のフォルダを探して選択します。アカウントもまたがってメールを選択します。選択したメールは、「新着メール」のフラグがOFFになり、また、RecvMailCountInFolderの返す値も減っていきます。\n//「新着メール」のフラグがOFFになるのは、秀丸メール内部で「SelectRecvMail済みかどうか」を判定するのに仕方のない処置です。\nwhile( dllfunc( "SelectRecvMail" ) ) {\n\tmessage str(##n) + "受信したメールを選択しました。";\n}\n
IsTrayIcon=//IsTrayIcon関数(TkInfo.dll)\n//常駐秀丸メールが存在しているかどうかを返します。\n##n = dllfunc("IsTrayIcon");\n
IsIcon=//IsIcon関数(TkInfo.dll)\n//現在マクロを実行しているウィンドウが最小化されているかどうかを返します。\n##n = dllfunc("IsIcon");\n
RestoreWindow=//RestoreWindow関数(TkInfo.dll)\n//現在マクロを実行しているウィンドウの表示状態を変えます。\n//「元のサイズに戻す」を実施します。\n##n = dllfunc("RestoreWindow");\n
MaximizeWindow=//MaximizeWindow関数(TkInfo.dll)\n//現在マクロを実行しているウィンドウの表示状態を変えます。\n//「最大化」を実施します。\n##n = dllfunc("MaximizeWindow");\n
MinimizeWindow=//MinimizeWindow関数(TkInfo.dll)\n//現在マクロを実行しているウィンドウの表示状態を変えます。\n//「最小化」を実施します。\n##n = dllfunc("MinimizeWindow");\n
DisableDraw_hmml=//DisableDraw関数(TkInfo.dll)\n//秀丸メール本体ウィンドウの描画を全面的に禁止させ、マクロの処理速度を速くします。 秀丸エディタの場合はdisabledrawしてそのままマクロを終了すれば自動的にenabledrawされますが、秀丸メールの場合はそういうことはありません。DisableDrawしたら後で必ずEnableDrawしてください。\n//DisableDrawしている最中でも、一部画面が描画されてしまうことがあります。\n##n = dllfunc("DisableDraw");\n
EnableDraw_hmml=//EnableDraw関数(TkInfo.dll)\n//DisableDrawした状態を元に戻します。\n//秀丸エディタの場合はdisabledrawしてそのままマクロを終了すれば自動的にenabledrawされますが、秀丸メールの場合はそういうことはありません。DisableDrawしたら後で必ずEnableDrawしてください。\n//DisableDrawしている最中でも、一部画面が描画されてしまうことがあります。\n##n = dllfunc("EnableDraw");\n
EnableDraw2=//EnableDraw2関数(TkInfo.dll)\n//メール内容枠での表示位置をパラメータで指定できるバージョンのEnableDraw相当関数です。\n//秀丸エディタの場合はdisabledrawしてそのままマクロを終了すれば自動的にenabledrawされますが、秀丸メールの場合はそういうことはありません。DisableDrawしたら後で必ずEnableDrawしてください。\n//DisableDrawしている最中でも、一部画面が描画されてしまうことがあります。\n##n = dllfunc("EnableDraw2", -9999);\n
HomeDir=//HomeDir関数(TkInfo.dll)\n//秀丸メールのホームディレクトリを返します。返されるホームディレクトリの文字列の最後には必ず「\」マークが付加されています。\n//例(アドレス帳ファイルを開く例)\n$$path = dllfuncstr("HomeDir") + "AdrBook.txt";\nrun hidemarudir + "\\hidemaru.exe " + $$path;\n
NextHideTuru=//NextHideTuru関数(TkInfo.dll)\n//秀丸メールのエディタと秀丸エディタを同じ扱いとして「次のウィンドウ」を実行します。\n//秀丸エディタにアクティブウィンドウが切り替わってもマクロの実行は秀丸メール内で続行されます。\n//このコマンドを秀丸および秀丸メールの両方から呼び出すことで、秀丸と秀丸メールを同一次元の物であるかのように使えて便利かもしれないです。\n\n//秀丸エディタからtkinfo.dllをロードするためには、tkinfo.dllのインストールされたフォルダを探す必要があります。インストール先のフォルダは、レジストリの\n//  HKEY_CURRENT_USER\Software\Hidemaruo\TuruKame\Config\TuruKameDir\n//を参照してください。\n//例(次の秀丸/秀丸メールエディタ)\nopenreg "CURRENTUSER", "Software\\Hidemaruo\\TuruKame\\Config";\n$$path = getregstr("TuruKameDir") + "tkinfo.dll";\nclosereg;\nloaddll $$path;\n##n = dllfunc("NextHideTuru");\n
PrevHideTuru=//PrevHideTuru関数(TkInfo.dll)\n//秀丸メールのエディタと秀丸エディタを同じ扱いとして「前のウィンドウ」を実行します。\n//秀丸エディタにアクティブウィンドウが切り替わってもマクロの実行は秀丸メール内で続行されます。\n//このコマンドを秀丸および秀丸メールの両方から呼び出すことで、秀丸と秀丸メールを同一次元の物であるかのように使えて便利かもしれないです。\n\n//秀丸エディタからtkinfo.dllをロードするためには、tkinfo.dllのインストールされたフォルダを探す必要があります。インストール先のフォルダは、レジストリの\n//  HKEY_CURRENT_USER\Software\Hidemaruo\TuruKame\Config\TuruKameDir\n//を参照してください。\n//例(前の秀丸/秀丸メールエディタ)\nopenreg "CURRENTUSER", "Software\\Hidemaruo\\TuruKame\\Config";\n$$path = getregstr("TuruKameDir") + "tkinfo.dll";\nclosereg;\nloaddll $$path;\n##n = dllfunc("PrevHideTuru");\n
GetFindPack=//GetFindPack関数(TkInfo.dll)\n//秀丸メールの「現在の検索パック」の内容を文字列に変換して返します。この関数は、「検索して一覧作成」や「メールアドレス検索」、「上検索/下検索」のそれぞれの時にしか有効でないフラグの値も含めてすべての状態を返します。\n$$s = dllfuncstr("GetFindPack");\nmessage $$s;\n
SetFindPack=//SetFindPack関数(TkInfo.dll)\n//パラメータで指定した検索パック文字列を、秀丸メールの「現在の検索パック」として設定します。\n##n = dllfunc("SetFindPack", "(\"abc\", target=all), inmail=0" );\n
YenEncode=//YenEncode関数(TkInfo.dll)\n//秀丸エディタのinput関数などで入力された文字列をSetFindPack用に変換する関数です。具体的には、ダブルクォーテーション記号および「\」記号の前に、「\」を挿入する処理をします。\n\n$$s = input( "検索対象文字列は?" );\n$$s = dllfuncstr( "YenEncode", $$s );\n##n = dllfunc( "SetFindPack", "(\"" + $$s + "\", target=all)" );\n\n//のように使います。\n
FindDown_hmml=//FindDown関数(TkInfo.dll)\n//「下候補」を実行します。\n//FindUp/FindDownする前に、普通、SetFindPack関数を使って検索条件を指定しておいてくだたさい。\n//秀丸メールの上候補/下候補コマンドと少し動きが違う部分があります。秀丸メールの上候補/下候補コマンドは、検索対象文字列の指定が1つだけの場合、メールを見つけてさらにそのメール中の対象文字列を探して強調表示/反転表示します。しかし、FindUp/FindDown関数では強調表示しません。さらに、その状態でFindUp/FindDownすると、そのメール中を検索することなく、上下方向に他のメールを検索しに行きます。これは、秀丸メール内部でのマクロ多重実行ができないための処置です。\n//上記の制限のため、検索条件でinmail=1を指定した場合、検索は必ず失敗します。\n//現在選択しているメールをスキップして検索を実行します。\n##n = dllfunc("SetFindPack", "(\"abc\",target=subject)");\n##n = dllfunc("FindDown");\n
FindUp_hmml=//FindUp関数(TkInfo.dll)\n//秀丸メール本体上で、「上候補」を実行します。\n//FindUp/FindDownする前に、普通、SetFindPack関数を使って検索条件を指定しておいてくだたさい。\n//秀丸メールの上候補/下候補コマンドと少し動きが違う部分があります。秀丸メールの上候補/下候補コマンドは、検索対象文字列の指定が1つだけの場合、メールを見つけてさらにそのメール中の対象文字列を探して強調表示/反転表示します。しかし、FindUp/FindDown関数では強調表示しません。さらに、その状態でFindUp/FindDownすると、そのメール中を検索することなく、上下方向に他のメールを検索しに行きます。これは、秀丸メール内部でのマクロ多重実行ができないための処置です。\n//上記の制限のため、検索条件でinmail=1を指定した場合、検索は必ず失敗します。\n//現在選択しているメールをスキップして検索を実行します。\n##n = dllfunc("SetFindPack", "(\"abc\",target=subject)");\n##n = dllfunc("FindUp");\n
FindDownInclude=//FindDownInclude関数(TkInfo.dll)\n//FindUp/FindDown関数は、現在選択しているメールをスキップして検索を実行します。FindUpIncludeおよびFindDownInclude関数は、現在選択しているメールも検索対象として検索を実行します。\n##n = dllfunc("SetFindPack", "(\"abc\",target=subject)");\n##n = dllfunc("FindDownInclude");\n
FindUpInclude=//FindUpInclude関数(TkInfo.dll)\n//FindUp/FindDown関数は、現在選択しているメールをスキップして検索を実行します。FindUpIncludeおよびFindDownInclude関数は、現在選択しているメールも検索対象として検索を実行します。\n##n = dllfunc("SetFindPack", "(\"abc\",target=subject)");\n##n = dllfunc("FindUpInclude");\n
SetViewAreaFoundBefore=//SetViewAreaFoundBefore関数(TkInfo.dll)\n//FindUp/FindDown関数を実行してフォルダをまたがった場合、ヒットした先のフォルダでの「表示範囲」が必ず「全体」に切り替わります。こうなってしまった表示範囲を元にもとしたい時は、このSetViewAreaFoundBefore関数を呼び出してください。\n//この関数は、FindUp/FindDown関数を呼んで他のフォルダに移動させる前に呼んでください。他のフォルダに移動した後に呼ぶと、他のフォルダの表示範囲がおかしくなります。\n##n = dllfunc("SetFindPack", "(\"abc\",target=subject)");\n##n = dllfunc("FindUp");\n##n = dllfunc("SetViewAreaFoundBefore");\n
DoGrep=//DoGrep関数(TkInfo.dll)\n//現在の検索条件で「検索して一覧作成」または「メールアドレス検索」を実行します。\n//「検索して一覧作成」になるか「メールアドレス検索」になるかは、検索条件の設定によります。\n//備考\n//「メールアドレス検索」を実行したい場合には、SetFindPack関数でtarget=personと指定しておいてください。\n//「検索して一覧作成」の結果ウィンドウの中をマクロで参照することはできません。また、DoGrep関数は検索が終了(または中断)するまで返ってきません。DoGrepから復帰した後は、検索結果ウィンドウがアクティブになりますが、マクロの実行はそのままマクロ実行していたエディタ上で続行されます。\n##n = dllfunc("DoGrep", "テストアカウント", "受信+送信済み+ユーザー");
PushFindPack=//PushFindPack関数(TkInfo.dll)\n//現在の検索条件を検索履歴に入れます。この関数は、SetFindPackした検索条件を履歴に保存したい場合に使います。\n//補足\n//SetFindPackでのsubfolder=およびinmail=の指定についてはPushFindPackで履歴に入れることができません。\n##n = dllfunc("SetFindPack", "....");\n##n = dllfunc("PushFindPack");\n
EnsureOnline=//EnsureOnline関数(TkInfo.dll)\n//コントロールパネル側で指定されたダイヤルアップ接続の指定などを使って、秀丸メールをオンライン状態にします。\n//EnsureOnline関数が参照するのはあくまでコントロールパネル側の設定です。秀丸メール側の「全般的な設定・送受信・接続」での設定に関係なく動作します。\n##n = dllfunc("EnsureOnline");\n
Dialup=//Dialup関数(TkInfo.dll)\n//パラメータで指定された接続先にダイヤルアップ接続します。\n##n = dllfunc("Dialup", "Mitene Analog");\n
DialupSelect=//DialupSelect関数(TkInfo.dll)\n//ダイヤルアップ接続先一覧のダイアログボックスを表示してダイヤルアップ接続します。\n##n = dllfunc("DialupSelect");\n
Hangup=//Hangup関数(TkInfo.dll)\n//現在のダイヤルアップ接続を切断します。\n##n = dllfunc("Hangup");\n
CurrentDialup=//CurrentDialup関数(TkInfo.dll)\n//現在接続中のダイヤルアップ接続先の名前を返します。どこにも接続してない場合は""を返します。\n$$s = dllfuncstr("CurrentDialup");\n
IsDialupable=//IsDialupable関数(TkInfo.dll)\n//現在のコンピュータがダイヤルアップ接続用の設定がなされているかどうかを返します。ダイヤルアップ接続用の接続先が最低1つ以上登録されている場合に「接続可能である」と見なすようになっています。\nif( ! dllfunc("IsDialupable") ) message "ダイヤルアップ接続できません。";\n
LoadAccountProp=//LoadAccountProp関数(TkInfo.dll)\n//パラメータで指定されたアカウントのプロパティをメモリ上にロードします。\n##n = dllfunc("LoadAccountProp", "テストアカウント" );\n
SaveAccountProp=//SaveAccountProp関数(TkInfo.dll)\n//SetAccountProp関数で書き換えられたアカウントプロパティをファイルに保存します。秀丸メール本体上でもエディタ上ででも実行可能です。\n##n = dllfunc("SetAccountProp", "szName", "斉藤秀夫" );\n##n = dllfunc("SaveAccountProp");\n
GetAccountProp=//GetAccountProp関数(TkInfo.dll)\n//LoadAccountProp関数でメモリ上にロードされたプロパティをGetAccountProp関数で参照できます。\n//秀丸メール本体上でもエディタ上ででも実行可能です。\n##n = dllfunc("GetAccountProp","cbSizeLimit")\n
SetAccountProp=//SetAccountProp関数(TkInfo.dll)\n//LoadAccountProp関数でメモリ上にロードされたプロパティをSetAccountProp関数で書き換えれます。\n//秀丸メール本体上でもエディタ上ででも実行可能です。\n##n = dllfunc("SetAccountProp", "fExcludeFromAllTransmit", 0);\n
MakeAccount=//MakeAccount関数(TkInfo.dll)\n//パラメータで指定した名前の新規アカウントを作成します。秀丸メールは空っぽのアカウントプロパティと初期のフォルダのみを生成するので、正しいアカウントにするためには、後でLoadAccountProp/SetAccountProp/SaveAccountPropでアカウント情報を設定してやるか、またはユーザー自身が自分でアカウントプロパティを設定する必要があります。\n##n = dllfunc("MakeAccount", "abcd");\n
AdrBook=//AdrBook関数(TkInfo.dll)\n//アドレス帳を表示します。この関数は秀丸メール本体側でもエディタ側でも実行できます。\n//秀丸メール本体ウィンドウや閲覧中のエディタで実行すると、アドレス帳のモードが編集モードで起動し、メール作成中の所のエディタ上で実行すると選択モードで起動します。\n##n = dllfunc( "\vAdrBook");\n##n = dllfunc( "AdrBook", "test-group/test-sub-group");\n
SelectAdrBook=//SelectAdrBook関数(TkInfo.dll)\n//AdrBook関数と同じようにアドレス帳を起動しますが、そこで選択された宛先を関数の返り値として返します(エディタ中の「To:」欄などには反映しません)。\n//SelectAdrBook関数で起動したアドレス帳は必ず選択モードとなります。\n//パラメータ1(数値型):\n//アドレス帳ウィンドウの親ウィンドウのハンドルを指定します。特に特定のウィンドウハンドルを指定する必要が無い場合は0を指定してください。0を指定すると現在のアクティブウィンドウが親ウィンドウと見なされます。\n//田楽DLLでダイアログボックスを出している場合などで、そのダイアログボックスを出したままアドレス帳を出したい場合などは、その田楽DLLで出しているダイアログボックスのウィンドウハンドルを指定する必要があるかもしれません。\n$$s = dllfuncstr( "SelectAdrBook", 0 );\n
FindBook=//FindBook関数(TkInfo.dll)\n//パラメータで渡された電子メールアドレス(以下、"Email"と表記)をアドレス帳から検索し、見つかった場合は名前を返します。見つからない場合は""を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBook", "あああ <aaa@aaa.com>");\n
FindBook2=//FindBook2関数(TkInfo.dll)\n//パラメータで渡された名前+Emailの中からEmail部分を取り出し、そのEmailをアドレス帳から検索し、見つかった場合はその名前を返し、見つからなかった場合はパラメータで渡された文字列中の名前部分を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBook2", "あああ <aaa@aaa.com>");\n
FindBook3=//FindBook3関数(TkInfo.dll)\n//パラメータで渡された名前+Emailの中からEmail部分を取り出し、そのEmailをアドレス帳から検索し、見つかった場合はその名前+Emailを返し、見つからなかった場合はパラメータで渡された名前+Emailを返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBook3", "あああ <aaa@aaa.com>");\n
FindBookNote=//FindBookNote関数(TkInfo.dll)\n//アドレス帳に登録されている備考〜備考3の内容を返します。アドレス帳に登録されてない場合は""を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBookNote", "あああ <aaa@aaa.com>");\n
FindBookNote2=//FindBookNote2関数(TkInfo.dll)\n//アドレス帳に登録されている備考〜備考3の内容を返します。アドレス帳に登録されてない場合は""を返します。同様に、FindBookDate関数は、登録日を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBookNote2", "あああ <aaa@aaa.com>");\n
FindBookNote3=//FindBookNote3関数(TkInfo.dll)\n//アドレス帳に登録されている備考〜備考3の内容を返します。アドレス帳に登録されてない場合は""を返します。同様に、FindBookDate関数は、登録日を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBookNote3", "あああ <aaa@aaa.com>");\n
FindBookDate=//FindBookDate関数(TkInfo.dll)\n//アドレス帳に登録されている登録日を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBookDate", "あああ <aaa@aaa.com>");\n
FindBookGroup=//FindBookGroup関数(TkInfo.dll)\n//アドレス帳に登録されているその人のグループ名を返します。アドレス帳の直下の場合は"アドレス帳"という文字列を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBookGroup", "あああ <aaa@aaa.com>");\n
FindBookGroupPath=//FindBookGroupPath関数(TkInfo.dll)\n//アドレス帳に登録されているグループのパス名、つまり、グループの階層全体を返します。各グループ名の前には「\」の記号が付きます。先頭のグループ名は、"アドレス帳"か、またはLDAPサーバーの名前となります。\n//たとえば、"ABC"というグループ配下の"XYZ"というグループである場合、\n//\アドレス帳\ABC\XYZ\n//という文字列を返します。\n//パラメータにはEmailのみでも名前+Emailでもどちらでも受け付けます。\n//アドレス帳に同じEmailが複数登録されている場合は一番先頭に登録されているメンバーのみが対象となります。\n$$s = dllfuncstr( "FindBookGroupPath", "あああ <aaa@aaa.com>");
DoBookGrep=//DoBookGrep関数(TkInfo.dll)\n//FindBook系の関数とは違い、メールアドレスが一部分マッチしていればヒットしたものとして処理します。\nloaddll "tkinfo.dll";\n$$find = input( "検索する文字列は?");\nif( $$find == "" ) endmacro;\n//Ldapgrep\nif( dllfunc("DoLdapGrep", $$find, 0, "sample-ldap-server", "mail", 0 ) == 0 ) {\n\tmessage "エラー";\n\tendmacro;\n}\n//BookGrep\n//\tif( dllfunc("\vDoBookGrep", $$find, 0 ) == 0 ) {\n//\t\tmessage "エラー";\n//\t\tendmacro;\n//\t}\n##i = 0;\nwhile(1) {\n\t$$menu[##i] = dllfuncstr("GetGrepResult", ##i);\n\tif( $$menu[##i] == "" ) {\n\t\tbreak;\n\t}\n\t$$menu[##i] = dllfuncstr("GetBookItemPart", $$menu[##i], -1 );\n\t##i = ##i + 1;\n}\nmenuarray $$menu, ##i;\n
DoLdapGrep=//DoLdapGrep関数(TkInfo.dll)\n//アドレス帳に登録されているLDAPサーバーから文字列を検索します。結果はGetGrepResult関数で1つづつ返します。\nloaddll "tkinfo.dll";\n$$find = input( "検索する文字列は?");\nif( $$find == "" ) endmacro;\n//Ldapgrep\nif( dllfunc("\vDoLdapGrep", $$find, 0, "sample-ldap-server", "mail", 0 ) == 0 ) {\n\tmessage "エラー";\n\tendmacro;\n}\n//BookGrep\n//\tif( dllfunc("DoBookGrep", $$find, 0 ) == 0 ) {\n//\t\tmessage "エラー";\n//\t\tendmacro;\n//\t}\n##i = 0;\nwhile(1) {\n\t$$menu[##i] = dllfuncstr("GetGrepResult", ##i);\n\tif( $$menu[##i] == "" ) {\n\t\tbreak;\n\t}\n\t$$menu[##i] = dllfuncstr("GetBookItemPart", $$menu[##i], -1 );\n\t##i = ##i + 1;\n}\nmenuarray $$menu, ##i;\n
GetGrepResult=//GetGrepResult関数(TkInfo.dll)\n//DoBookGrep関数で取得した結果を1つづつ取得します。\nloaddll "tkinfo.dll";\n$$find = input( "検索する文字列は?");\nif( $$find == "" ) endmacro;\n//Ldapgrep\nif( dllfunc("DoLdapGrep", $$find, 0, "sample-ldap-server", "mail", 0 ) == 0 ) {\n\tmessage "エラー";\n\tendmacro;\n}\n//BookGrep\n//\tif( dllfunc("DoBookGrep", $$find, 0 ) == 0 ) {\n//\t\tmessage "エラー";\n//\t\tendmacro;\n//\t}\n##i = 0;\nwhile(1) {\n\t$$menu[##i] = dllfuncstr("\vGetGrepResult", ##i);\n\tif( $$menu[##i] == "" ) {\n\t\tbreak;\n\t}\n\t$$menu[##i] = dllfuncstr("GetBookItemPart", $$menu[##i], -1 );\n\t##i = ##i + 1;\n}\nmenuarray $$menu, ##i;\n
GetBookItemPart=//GetBookItemPart関数(TkInfo.dll)\n//GetGrepResult関数で取得した検索結果の1項目中からメールアドレス部分や名前部分などを取り出します。\nloaddll "tkinfo.dll";\n$$find = input( "検索する文字列は?");\nif( $$find == "" ) endmacro;\n//Ldapgrep\nif( dllfunc("DoLdapGrep", $$find, 0, "sample-ldap-server", "mail", 0 ) == 0 ) {\n\tmessage "エラー";\n\tendmacro;\n}\n//BookGrep\n//\tif( dllfunc("DoBookGrep", $$find, 0 ) == 0 ) {\n//\t\tmessage "エラー";\n//\t\tendmacro;\n//\t}\n##i = 0;\nwhile(1) {\n\t$$menu[##i] = dllfuncstr("GetGrepResult", ##i);\n\tif( $$menu[##i] == "" ) {\n\t\tbreak;\n\t}\n\t$$menu[##i] = dllfuncstr("\vGetBookItemPart", $$menu[##i], -1 );\n\t##i = ##i + 1;\n}\nmenuarray $$menu, ##i;\n
BookWnd=//BookWnd関数(TkInfo.dll)\n//アドレス帳ウィンドウのウィンドウハンドルを返します。アドレス帳が出てない時は0を返します。パラメータはありません。\nif( dllfunc( "BookWnd") != 0 ) {\nmessage "アドレス帳を閉じてからやり直してください。";\n\tendmacro;\n}\n
ExtractBookGroup=//ExtractBookGroup関数(TkInfo.dll)\n//アドレス帳・グループを含む宛先を、実際のアドレス帳・グループのメンバーに変換します。例えば、Group(/aaa)という文字列を、アドレス帳の「aaa」グループのメンバーのメールアドレス一覧に変換します。\n$$to = dllfuncstr("CurrentHeader", "To");\n$$to = dllfuncstr("ExtractBookGroup", $$to);\n##n = dllfunc("SetHeader", "To", $$to);\n
GetTemplateName=//GetTemplateName関数(TkInfo.dll)\n//「設定・テンプレート/署名の編集」で登録されたテンプレート/署名の名前を取得します。取得した名前はLoadTemplate関数やSwitchTemplate/SwitchSign関数で使います。\n##c = 0;\nwhile(1) {\n$$s[##c] = dllfuncstr("GetTemplateName", "newmail", ##c);\n\tif( $$s[##c] == "" ) break;\n\t##c = ##c + 1;\n}\nif( ##c != 0 ) menuarray $$s, ##c;\n
LoadTemplate=//LoadTemplate関数(TkInfo.dll)\n//「設定・テンプレート/署名の編集」で登録されたテンプレート/署名の内容を取得します。\n$$s = dllfuncstr("LoadTemplate", "newmail", "テストテンプレート");\n
GetTemplateAssociatedSign=//GetTemplateAssociatedSign関数(TkInfo.dll)\n//パラメータで指定されたテンプレートの「連動させる署名」を取得します。\n$$s = dllfuncstr("GetTemplateAssociatedSign", "newmail", "テストテンプレート");\n
SwitchTemplate=//SwitchTemplate関数(TkInfo.dll)\n//現在編集中のメールのテンプレートを切り替えます。SwitchSignは同様に署名を切り替えます。\n##n = dllfunc("SwitchTemplate", "テストテンプレート");\n
SwitchSign=//SwitchSign関数(TkInfo.dll)\n//現在編集中のメールのテンプレートを切り替えます。SwitchSignは同様に署名を切り替えます。\n##n = dllfunc("SwitchTemplate", "テストテンプレート");\n
CurrentTemplateName=//CurrentTemplateName関数(TkInfo.dll)\n//例(現在のエディタに適用されているテンプレートをアカウント毎の設定に指定する例)\n//AutoTemplateChange.mac--------------------------------------\nloaddll "tkinfo.dll";\n##type = dllfunc("MailType");\nif( ##type < 0 || ##type > 2 ) {\n\t// 新規メール、返信メール、転送メール の場合のみ。\n\tendmacro;\n}\n$$s = dllfuncstr("\vCurrentTemplateName");\nif( leftstr( $$s, 1 ) == "\\\\" ) {\n\t// アカウント毎/フォルダ毎のテンプレート指定の場合は何もしない\n\tendmacro;\n}\n##n = dllfunc("SetTemplateReference", dllfuncstr("CurrentAccount")\n\t\t\t, "", ##type, $$s );\n
CurrentSignName=//CurrentSignName関数(TkInfo.dll)\n//現在のエディタに適用された署名の名前を返します。\n//「新規メール」、「返信メール」などのコマンドでエディタが起動した時にのみ有効です。他のエディタ上や秀丸メール本体上で実行しても、何も返しません。\n$$s = dllfuncstr("CurrentSignName");\n
GetTemplateReference=//GetTemplateReference関数(TkInfo.dll)\n//アカウント毎またはフォルダ毎の設定で、参照指定されたテンプレート/署名の名前を返します。\nloaddll "tkinfo.dll";\n##type = dllfunc("MailType");\n$$s = dllfuncstr("GetTemplateReference", dllfuncstr("CurrentAccount")\n\t\t\t, "", ##type );\n
SetTemplateReference=//SetTemplateReference関数(TkInfo.dll)\n//アカウント毎またはフォルダ毎の設定での、参照指定する先のテンプレート/署名の指定を書き換えます。\n//備考、制限事項\n//SetTemplateReference関数でフォルダ毎の設定を書き換える場合、元々のフォルダ設定が「参照指定」になってないと、SetTemplateReference関数の動作は意味がなくなってしまいます。事実上、フォルダ毎の設定を書き換えるのには使い物になりません。アカウント毎の設定を書き換える用のみに使ってください。\n//例(現在のエディタに適用されているテンプレートをアカウント毎の設定に指定する例)//AutoTemplateChange.mac--------------------------------------\nloaddll "tkinfo.dll";\n##type = dllfunc("MailType");\nif( ##type < 0 || ##type > 2 ) {\n\t// 新規メール、返信メール、転送メール の場合のみ。\n\tendmacro;\n}\n$$s = dllfuncstr("CurrentTemplateName");\nif( leftstr( $$s, 1 ) == "\\\\" ) {\n\t// アカウント毎/フォルダ毎のテンプレート指定の場合は何もしない\n\tendmacro;\n}\n##n = dllfunc("\vSetTemplateReference", dllfuncstr("CurrentAccount")\n\t\t\t, "", ##type, $$s );\n
ExecAt=//ExecAt関数(TkInfo.dll)\n//現在のウィンドウとは別のウィンドウ上でTKInfo.dllの関数呼び出しを実行します。例えば、CurrentAccount関数は、現在のウィンドウでのアカウントを返しますが、例えばエディタが起動している状態で秀丸メール本体側のCurrentAccountの値を取り出したい時に使います。\n##main = dllfunc("MainWnd");\n$$account = dllfuncstr("\vExecAt", ##main, "CurrentAccount");\n##n = dllfunc("ExecAtMain", "SetFindPack", "(\"abc\", target=all), inmail=3");\nif( dllfunc("ExecAtMain", "FindDownInclude") ) message "ありました";\nelse message "ありません";\n
ExecAtMain=//ExecAtMain関数(TkInfo.dll)\n//エディタウィンドウ上から秀丸メール上でのtkinfo.dll呼び出しを行う専用の関数です。ExecAtMainは、ExecAtと違い、20秒の時間制限が無く、非常に時間のかかる処理でも「デッドロック」のエラーが起きることなく処理できます。\n##main = dllfunc("MainWnd");\n$$account = dllfuncstr("ExecAt", ##main, "CurrentAccount");\n##n = dllfunc("\vExecAtMain", "SetFindPack", "(\"abc\", target=all), inmail=3");\nif( dllfunc("ExecAtMain", "FindDownInclude") ) message "ありました";\nelse message "ありません";\n
EnvChanged_hmml=//EnvChanged関数(TkInfo.dll)\n//EnvChanged関数\n//V4.57以降で実行可能\n//秀丸メールの「全般的な設定」について、レジストリに保存された内容を読み込み直し、秀丸メール側に反映します。秀丸マクロのenvchanged文の秀丸メール版です。\n//全般的な設定は、秀丸マクロのopenreg/writeregstr/writeregnum/closereg文などを使って各自で書き換えてください。具体的にどこをどう書き換えればどこの設定が変わるのかについては、各自で「全般的な設定」を変更してレジストリエディタで調べてください。例(2枠区切りと3枠区切りを切り替える例)\nloaddll "tkinfo.dll";\nopenreg "CURRENTUSER", "Software\\Hidemaruo\\TuruKame\\Config";\n##pane = getregnum("pane");\nif( ##pane == 3 ) writeregnum "pane", 2;\nelse writeregnum "pane", 3;\nclosereg;\n##n = dllfunc("EnvChanged");
SetAutoPushTimer=//SetAutoPushTimer関数(TkInfo.dll)\n//メッセージボックスのボタンを一定時間後に押すためのタイマーをセットします。\n//何秒後にボタンを押すかの時間を指定します。SetAutoPushTimer関数の場合は秒単位、SetAutoPushTimerMilli関数の場合はミリ秒単位(1/1000秒単位)です。\n##n = dllfunc("\vSetAutoPushTimer", 10, "yes");\nquestion( "切断しますか?");\nif( result == yes ) ##n = dllfunc("Hangup");\n
SetAutoPushTimerMilli=//SetAutoPushTimerMilli関数(TkInfo.dll)\n//メッセージボックスのボタンを一定時間後に押すためのタイマーをセットします。\n//何秒後にボタンを押すかの時間を指定します。SetAutoPushTimerMilli関数の場合はミリ秒単位(1/1000秒単位)です。\n##n = dllfunc("\vSetAutoPushTimerMilli", 10, "yes");\nquestion( "切断しますか?");\nif( result == yes ) ##n = dllfunc("Hangup");\n
IsHidemaruMacroExecuting=//IsHidemaruMacroExecuting関数(TkInfo.dll)\n//秀丸メール上でのマクロ実行ではなく、別に動作している秀丸エディタ上で現在マクロ実行中かどうかを返します。\n//備考\n//秀丸エディタ側からtkinfo.dllの関数を呼び出すには、秀丸メールのレジストリから秀丸メールのインストールされたフォルダを調べる必要があります。具体的にはHKEY_CURRENT_USER\Software\Hidemaruo\TuruKame\ConfigのTuruKameDirキーを参照する必要があります。\n//例(秀丸メールから秀丸を起動してマクロで何か処理させる例)\nloaddll "tkinfo.dll";\nwhile( dllfunc("IsHidemaruMacroExecuting") ) {\n// 待機\n}\nrun hidemarudir + "\\hidemaru.exe /xtest.mac";\n
SetQuietMode=//SetQuietMode関数(TkInfo.dll)\n//秀丸メールが何らかのウィンドウを表示しても、そのウィンドウをアクティブにしないで静かに動作させる指定をします。例えば定期受信の後に自動起動されるマクロから、NewMail関数を呼ぶなどすると、新規メール用のウィンドウが前面に出てきてしまって都合が悪いです。QuietModeをONにしておくと、生成されたウィンドウが一番裏に出てくる動作となり、パソコンの利用者が何か別の作業をしていてもじゃまにならずに済みます。\n//備考\n//QuietModeをONにしたら、マクロ終了前にQuietModeをOFFに戻してください。ただし、大抵の場合はOFFに戻し忘れても自動的にOFFに戻ります。\n//例:\nloaddll "tkinfo.dll";\n##n = dllfunc("SetQuietMode", 1 );\n##n = dllfunc("NewMail");\n##n = dllfunc("SetHeader", "To", "test");\n##n = dllfunc("SetHeader", "Subject", "test");\n##n = dllfunc("SendNow");\n##n = dllfunc("SetQuietMode", 0 );\nexit;\n
ReasonMacroStarted=//ReasonMacroStarted関数(TkInfo.dll)\n//マクロがどのようにして起動されたのかを返します。具体的には、「マクロ・マクロ登録・自動起動」で登録されたマクロが起動されたのか、それとも普通にユーザー様のキーボード/マウス操作で起動されたのかを返します。\n//備考\n//自動起動されたマクロからexecmacro文によって起動されたマクロでも、自動実行の場合の値を返します。\n//あとで送信なのか今すぐ送信なのかを区別するには、Bypass_GetWindowText関数を使った以下のような処理で判定してください。\n$$s = dllfuncstr("Bypass_GetWindowText", hidemaruhandle(0) );\n\tif( leftstr( $$s, 6 ) == "今すぐ" ) {\n\t\tmessage "今すぐ送信";\n\t} else {\n\t\tmessage "あとで送信";\n\t}\n\nloaddll "tkinfo.dll";\n\tif( dllfunc("ReasonMacroStarted") != 0 ) {\n\t\tmessage "自動実行されました。";\n\t} else {\n\t\tmessage "手動実行されました。";\n\t}
EncryptSign=//EncryptSign関数(TkInfo.dll)\n//現在編集中のメール上で、「編集・暗号化/電子署名...」の処理をします。パラメータで暗号化/電子署名の処理内容および形式等が指定できます。\n//例(あとで送信/今すぐ送信の時に自動実行して電子署名する例)\nquestion "電子署名を付けて送信しますか?";\nif( result == yes ) {\n\tloaddll "tkinfo.dll";\n\t$$s = dllfuncstr("EncryptSign", 1, 3, 0, 0);\n\tif( $$s == "" ) {\n\t\t##n = dllfunc("SetCancel", 1);\n\t}\n}\n
PgpEncrypt=//PgpEncrypt関数(TkInfo.dll)\n//第1パラメータで指定された内容を暗号化して返します。第2パラメータで送り先メールアドレスを指定します。送り先が複数ある場合は、そのメールアドレスを空白区切りで複数指定してください。\n//この関数内ではShift-JIS/JIS変換などの余計な処理は一切しません。\nPgpEncrypt\n
PgpDecrypt=//PgpDecrypt関数(TkInfo.dll)\n//第1パラメータで指定された内容を復号して返します。第2パラメータでパスフレーズを指定してください。\n//この関数内ではShift-JIS/JIS変換などの余計な処理は一切しません。\nPgpDecrypt\n
PgpGetInfo=//PgpGetInfo関数(TkInfo.dll)\n//直前に実行したPgpEncrypt/PgpDecrypt関数の実行結果(PGP.exeの標準出力への出力結果)を返します。\n//PGP.exeの起動に失敗した場合または起動以前の問題が起きた場合は""が返ります。\nPgpEncrypt
PgpGetExitCode=//PgpGetExitCode関数(TkInfo.dll)\n//直前に実行したPgpEncrypt/PgpDecrypt関数時のPGP.exeの終了コードを返します。終了コードの意味についてはPGP側の説明を参照ください。\n//PGP.exeの起動にすら失敗した場合、またはPGP.exeの起動以前の問題が起きた時は-1が返ります。\nPgpGetExitCode\n
Import=//Import関数(TkInfo.dll)\n//「ファイル・インポート」コマンドと同じようにメール用のファイルをインポートします。\n##n = dllfunc("Import", "c:\\temp.eml", "eml");\n##n = dllfunc("Import", "c:\\temp.eml", "eml", "recv", "makelog");\n##n = dllfunc("Import", "c:\\temp.eml", "eml", "", "makelog");\n##n = dllfunc("Import", "c:\\temp.eml", "eml", "recv", "", "tdateheader", "mdnreply");\n##n = dllfunc("Import", "c:\\temp.eml", "eml", "", "makelog", "tcurrent", "mdnreply");\n
Export=//Export関数(TkInfo.dll)\n//「ファイル・エクスポート」コマンドと同じようにメール用のファイルをエクスポートします。\n##n = dllfunc("Export", "c:\\tempfolder", "eml-subject", "log");\n
LoadUnlhaDll=//LoadUnlhaDll関数(TkInfo.dll)\n//Unlha32.dll用。\n//Unlha32.dllをロードします。成功すると1、失敗すると0を返します。\n//返り値は数値、パラメータ無し。\nif( ! dllfunc("\vLoadUnlhaDll") ) {\n   message "Unlha32.dllがインストールされていません。";\n   endmacro;\n}\n##n = dllfunc("Unlha", hidemaruhandle(0), "a \"c:\\test.lzh\" abc.txt xyz.txt");\n$$s = dllfuncstr("GetUnlhaResult");\n##n = dllfunc("FreeUnlhaDll");\nmessage $$s;\n
FreeUnlhaDll=//FreeUnlhaDll関数(TkInfo.dll)\n//Unlha32.dll用。Unlha32.dllを解放します。\n//返り値もパラメータも無し。\nif( ! dllfunc("\vLoadUnlhaDll") ) {\n   message "Unlha32.dllがインストールされていません。";\n   endmacro;\n}\n##n = dllfunc("Unlha", hidemaruhandle(0), "a \"c:\\test.lzh\" abc.txt xyz.txt");\n$$s = dllfuncstr("GetUnlhaResult");\n##n = dllfunc("FreeUnlhaDll");\nmessage $$s;\n
Unlha=//Unlha関数(TkInfo.dll)\n//Unlha32.dll用。\n//Unlha関数を呼び出します。パラメータ1にはhidemaruhandle(0)を渡し、パラメータ2にlha用のコマンドラインをそのまま渡してください。\n//返り値は、Unlha32.dllのUnlha関数そのままです。詳しくはそちらを参照ください。\n//返り値は数値、パラメータ1が親ウィンドウハンドル、パラメータ2がコマンドライン。\nif( ! dllfunc("LoadUnlhaDll") ) {\n   message "Unlha32.dllがインストールされていません。";\n   endmacro;\n}\n##n = dllfunc("\vUnlha", hidemaruhandle(0), "a \"c:\\test.lzh\" abc.txt xyz.txt");\n$$s = dllfuncstr("GetUnlhaResult");\n##n = dllfunc("FreeUnlhaDll");\nmessage $$s;\n
GetUnlhaResult=//GetUnlhaResult関数(TkInfo.dll)\n//Unlha32.dll用。\n//Unlha関数を呼び出した結果文字列を返します。\n//返り値は文字列、パラメータ無し。\nif( ! dllfunc("LoadUnlhaDll") ) {\n   message "Unlha32.dllがインストールされていません。";\n   endmacro;\n}\n##n = dllfunc("Unlha", hidemaruhandle(0), "a \"c:\\test.lzh\" abc.txt xyz.txt");\n$$s = dllfuncstr("\vGetUnlhaResult");\n##n = dllfunc("FreeUnlhaDll");\nmessage $$s;\n
LoadZipDll=//LoadZipDll関数(TkInfo.dll)\n//Zip32J.dll用。\n//Zip32J.dllをロードします。成功すると1、失敗すると0を返します。\n//返り値は数値、パラメータ無し。\nif( ! dllfunc("\vLoadZipDll") ) {\n\tmessage "Zip32J.dllまたはZIP32.DLLがインストールされていません。";\n\tendmacro;\n}\n##n = dllfunc("Zip", hidemaruhandle(0), "-j \"c:\\test.zip\" abc.txt xyz.txt");\n$$s = dllfuncstr("GetZipResult");\n##n = dllfunc("FreeZipDll");\nmessage $$s;\n
FreeZipDll=//FreeZipDll関数(TkInfo.dll)\n//Zip32J.dll用。\n//Zip32J.dllを解放します。\n//返り値もパラメータも無し。\nif( ! dllfunc("LoadZipDll") ) {\n\tmessage "Zip32J.dllまたはZIP32.DLLがインストールされていません。";\n\tendmacro;\n}\n##n = dllfunc("Zip", hidemaruhandle(0), "-j \"c:\\test.zip\" abc.txt xyz.txt");\n$$s = dllfuncstr("GetZipResult");\n##n = dllfunc("\vFreeZipDll");\nmessage $$s;\n
Zip=//Zip関数(TkInfo.dll)\n//Zip32J.dll用。\n//Zip関数を呼び出します。パラメータ1にはhidemaruhandle(0)を渡し、パラメータ2にlha用のコマンドラインをそのまま渡してください。\n//返り値は数値、パラメータ1が親ウィンドウハンドル、パラメータ2がコマンドライン。返り値は、Zip32J.dllのZip関数そのままです。詳しくはそちらを参照ください。\nif( ! dllfunc("LoadZipDll") ) {\n\tmessage "Zip32J.dllまたはZIP32.DLLがインストールされていません。";\n\tendmacro;\n}\n##n = dllfunc("\vZip", hidemaruhandle(0), "-j \"c:\\test.zip\" abc.txt xyz.txt");\n$$s = dllfuncstr("GetZipResult");\n##n = dllfunc("FreeZipDll");\nmessage $$s;\n
GetZipResult=//GetZipResult関数(TkInfo.dll)\n//Zip32J.dll用。\n//Zip関数を呼び出した結果文字列を返します。\n//返り値は文字列、パラメータ無し。\nif( ! dllfunc("LoadZipDll") ) {\n\tmessage "Zip32J.dllまたはZIP32.DLLがインストールされていません。";\n\tendmacro;\n}\n##n = dllfunc("Zip", hidemaruhandle(0), "-j \"c:\\test.zip\" abc.txt xyz.txt");\n$$s = dllfuncstr("\vGetZipResult");\n##n = dllfunc("FreeZipDll");\nmessage $$s;\n
hidemaru_screentopy=//hidemaru_screentopy関数(TkInfo.dll)\n//現在のエディタ・ウィンドウ中でのウィンドウの1番先頭行に表示している行のy座標を返します。\n//ウィンドウが分割してる場合は、分割された2つのうちの、カーソルが乗ってる方の枠の先頭行についての値を返します。\n##top = dllfunc("\vhidemaru_screentopy");\ndisabledraw;\n//...\n//...\nenabledraw ##top;\n
GetCurrentMenuCheckState=//GetCurrentMenuCheckState関数(TkInfo.dll)\n//現在のマクロ実行しているウィンドウのメニューのチェック状態を取得します。\nloaddll "tkinfo.dll";\nif( dllfunc("GetCurrentMenuCheckState", 40051) == 0 ) {\n   ##n =sendmessage( hidemaruhandle(0), 0x0111, 40051, 0);\n}\n


Bypass_CopyFile=//Bypass_CopyFile関数(TkInfo.dll)\n//WindowsAPIを使用して、ファイルのcopyを実施します。\nif ( !dllfunc("Bypass_CopyFile", "e:\\\\a.mac", "e:\\\\c.mac") ){\n\tmessage "copy ng";\n}\n
Bypass_CreateDirectory=//Bypass_CreateDirectory関数(TkInfo.dll)\n//パラメータ1に作成したいフォルダ名を指定する。\n//成功すると0以外を返す。\n##n = dllfunc( "\vBypass_CreateDirectory", $$home + $$path) ;\n
Bypass_DeleteFile=//Bypass_DeleteFile関数(TkInfo.dll)\n//WindowsAPIのDeleteFile関数。パラメータ1にファイル名を指定する。\n//削除に成功すると0以外を返す。\n//失敗すると0を返す。\n##n = dllfunc("\vBypass_DeleteFile", $$path);\n
Bypass_GetFileAttributes=//Bypass_GetFileAttributes関数(TkInfo.dll)\n//パラメータ1にファイル名を指定する。返り値は属性。\n//エラーの場合は-1を返す。\nloaddll "tkinfo.dll";\n$$path = input("フォルダ名/ファイル名は?");\n##n = dllfunc("\vBypass_GetFileAttributes", $$path);\nif( ##n == 0xFFFFFFFF ) {\n\tmessage "ファイル存在せず";\n} else if( (##n & 0x10) != 0 ) {\n\tmessage "ディレクトリ";\n} else {\n\tmessage "ファイル";\n}\n
Bypass_GetFileSize=//Bypass_GetFileSize関数(TkInfo.dll)\n//WindowsAPIのGetFileSizeと少々違う。\n//パラメータ1にファイル名を指定すると、サイズが返る。\n//エラーの場合は-1を返す。\nloaddll "TKInfo.dll";\n$$name = "filter.txt" ;\n$$path = getregstr("HomeDir") + dllfuncstr("CurrentAccount") + "\\\\" + $$name;\n##size = dllfunc("\vBypass_GetFileSize", $$path);\nmessage $$name+"ファイルサイズ=" + str(##size) ;\n
Bypass_GetForegroundWindow=//Bypass_GetForegroundWindow関数(TkInfo.dll)\n##handle = dllfunc("\vBypass_GetForegroundWindow");
Bypass_GetLastError=//Bypass_GetLastError関数(TkInfo.dll)\n//WindowsAPIのGetLastError。\n//直前のWindowsAPI呼び出しで発生したエラーのコードを返す。\n##n = dllfunc("\vBypass_GetLastError") ;
Bypass_keybd_event=//Bypass_keybd_event関数(TkInfo.dll)\nloaddll "tkinfo.dll";\n##n = dllfunc("Bypass_PostMessage", hidemaruhandle(0)\n\t\t\t, 0x0111, 40013, 0 );\t//「検索」コマンドを実行\n##n = dllfunc("\vBypass_keybd_event", 0x28 );//下矢印キー\n##n = dllfunc("Bypass_keybd_event", 0x28 );//下矢印キー\n##n = dllfunc("Bypass_keybd_event", 0x0D );//エンターキー\n
Bypass_MoveFile=//Bypass_MoveFile関数(TkInfo.dll)\n//WindowsAPIを使用したファイルの移動。\nloaddll "TKInfo.dll";\n$$folder = dllfuncstr( "HomeDir" ) + dllfuncstr( "CurrentAccount" ) + "\\\\";\n$$file = "edit_file" ;\n##n = dllfunc( "\vBypass_MoveFile", \t$$folder + $$file + ".txt" ,\t//「検索」コマンドを実行\n\t\t\t\t\t\t\t\t\t$$folder + $$file + ".bak" ) ;\ncall Res_check ##n,"ファイルの移動に失敗しました。\n";\nLEND:\n\tfreedll;\n\tendmacro;\n\nRes_check:\n//処理:処理の判定&メッセージ表示\n\t//引数渡し\n\t##num = ##1;\t$$mes = $$2 ;\n\tif(##num != 1){\n\t\tmessage $$mes ;\n\t\tgoto LEND;\n\t}\nreturn ;\n
Bypass_PostMessage=//Bypass_PostMessage関数(TkInfo.dll)\nloaddll "tkinfo.dll";\n##n = dllfunc("\vBypass_PostMessage", hidemaruhandle(0)\n\t\t\t, 0x0111, 40013, 0 );\t//「検索」コマンドを実行\n##n = dllfunc("Bypass_keybd_event", 0x28 );//下矢印キー\n##n = dllfunc("Bypass_keybd_event", 0x28 );//下矢印キー\n##n = dllfunc("Bypass_keybd_event", 0x0D );//エンターキー\n
Bypass_RemoveDirectory=//Bypass_RemoveDirectory関数(TkInfo.dll)\n//パラメータ1にフォルダのパス名を指定する。(パラメータ2は省略)\n//成功すると0以外を返す。\n##n = dllfunc( "\vBypass_RemoveDirectory", $$home + $$path) \n
Bypass_SetFileAttributes=//Bypass_SetFileAttributes関数(TkInfo.dll)\n//パラメータ1にファイル名、パラメータ2に属性を指定する。\n//属性の例:\t0x00000020 ... 普通のファイル\n//\t\t\t0x00000021 ... 上書き禁止ファイル\n//参考情報\n//#define FILE_ATTRIBUTE_READONLY\t\t  0x00000001  \n//#define FILE_ATTRIBUTE_HIDDEN \t\t  0x00000002  \n//#define FILE_ATTRIBUTE_SYSTEM \t\t  0x00000004  \n//#define FILE_ATTRIBUTE_DIRECTORY\t\t  0x00000010  \n//#define FILE_ATTRIBUTE_ARCHIVE\t\t  0x00000020  \n//#define FILE_ATTRIBUTE_NORMAL \t\t  0x00000080  \n//#define FILE_ATTRIBUTE_TEMPORARY\t\t  0x00000100  \n//#define FILE_ATTRIBUTE_COMPRESSED \t  0x00000800  \n//#define FILE_ATTRIBUTE_OFFLINE\t\t  0x00001000  \n##n = dllfunc( "\vBypass_SetFileAttributes", $$home + $$path,0x00000021) ;\n
Bypass_MessageBox=//Bypass_MessageBox関数(TkInfo.dll)\n//WindowsのMessageBox関数をそのまま呼び出します。MessageBox関数のプロトタイプ(関数の型宣言)は、\n//int MessageBox( HWND hwnd, LPCSTR pszText, LPCSTR pszCaption, UINT uType );\n//となっていて、4つのパラメータ付きで呼び出される形になります。\n//-----メッセージボックス タイプ情報設定-----\n\t##msgbox = 0x0 ;\n\n\t//アイコンの種類と値\n//\t##msgbox = ##msgbox | 0x10 ;\t//エラーのアイコン\n//\t##msgbox = ##msgbox | 0x20 ;\t//質問のアイコン\n//\t##msgbox = ##msgbox | 0x30 ;\t//警告のアイコン\n\t##msgbox = ##msgbox | 0x40 ;\t//情報のアイコン\n\n\t//ボタンの種類と値は以下の通りです。\n//\t##msgbox = ##msgbox | 0x0 ;\t//OKボタンのみ\n\t##msgbox = ##msgbox | 0x1 ; //OK + キャンセル\n//\t##msgbox = ##msgbox | 0x2 ;\t//中断、再試行、無視\n//\t##msgbox = ##msgbox | 0x3 ;\t//はい、いいえ、キャンセル\n//\t##msgbox = ##msgbox | 0x4 ;\t//はい、いいえ\n//\t##msgbox = ##msgbox | 0x5 ;\t//再試行、キャンセル\n\n\t//デフォルトのボタン指定は以下の通りです。\n\t##msgbox = ##msgbox | 0x000 ;\t//1つ目のボタン\n//\t##msgbox = ##msgbox | 0x100 ; //2つ目のボタン\n//\t##msgbox = ##msgbox | 0x200 ; //3つ目のボタン\n\n\t//その他指定は以下の通りです。\n\t##msgbox = ##msgbox | 0x01000 ; //ウィンドウを最前面に出す\n\t##msgbox = ##msgbox | 0x10000 ; //ウィンドウをフォアグラウンドにする\n//-----メッセージボックス タイプ情報設定終了-----\n##n = dllfunc("\vBypass_MessageBox", 0, $$mes,"通知",##msgbox) ;\n
Bypass_SetForegroundWindow=//Bypass_SetForegroundWindow関数(TkInfo.dll)\n##wnd = findwindowclass("TuruKameOuterView");\n##n = dllfunc("\vBypass_SetForegroundWindow", ##wnd);\n
basic_hmml=$$ver = "1.00";\n$$date = "2005/xx/xx";\n$$author = "" ;\n$$fname = currentmacrobasename ;\n$info = "\\n" + $$fname + " Ver " + $$ver+ "\\n最終更新日付:"+$$date ;\n$info = $info + "\\n作者:"+$$author ;\n\n\tcall HidemaruMail ;\n\n\t$sbuf = searchbuffer ;\t//マクロ終了時に、検索条件を復元するため記憶\n\t#sopt = searchoption ;\n\t$rbuf = replacebuffer;\n//sample\n\n\t\v$$wk = dllfuncstr( "CurrentHeader", "To" );\n\tif($$wk == ""){\n\t\t##n = dllfunc( "AdrBook");\n\t}\n\t//サブルーチンRes_checkの使用例\n\t//変数が1であるかどうかを確認する。\n\t//第一引数 チェックを行う数値型変数\n\t//第二引数 第一引数がnot "1"の場合、表示するメッセージ\n\t//call Res_check ##res,"xxの処理に失敗しました" +"\\n" + $info ;\n\n\t//サブルーチンStr_checkの使用例\n\t//変数が""以外であるかどうかを確認する。\n\t//第一引数 チェックを行う文字列型変数\n\t//第二引数 第一引数が""の場合、表示するメッセージ\n\t//call Str_check $$str,"xxの処理に失敗しました" +"\\n" + $info ;\n\n//sample end\n\nLEND:\n\tsetsearch $sbuf, #sopt; //開始時の検索文字,optionに戻す\n\tsetreplace $rbuf ;\n\tfreedll;\n\tendmacro;\n\nHidemaruMail:\t//秀丸メール起動チェック&DLLロード\n//機能:TKInfo.dllをロードする\n//秀シリーズサポートHPより 抜粋\n\t// DLL を Load する\n\topenreg "CURRENTUSER","Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\n\t##res = result ;\n\tclosereg ;\n\tif( !##res ) {\n\t\tmessage "秀丸メールがインストールされてないです (^^;)\\n"+$info;\n\t\tendmacro;\n\t}\n\n\tloaddll "TKInfo.dll";\n\tif( !result ) {\n\t\tmessage "DLLロードに失敗\\n"+$info;\n\t\tendmacro;\n\t}\nreturn ;\n\nRes_check:\n//処理:処理の判定&メッセージ表示\n\t//引数渡し\n\t##num = ##1;\t$$mes = $$2 ;\n\tif(##num != 1){\n\t\tmessage $$mes ;\n\t\tgoto LEND;\n\t}\nreturn ;\n\nStr_check:\n//処理:文字列の判定&メッセージ表示\n\t//引数渡し\n\t$$str = $$1;\t$$mes = $$2 ;\n\tif($$str == ""){\n\t\tmessage $$mes ;\n\t\tgoto LEND;\n\t}\nreturn ;\n
//Bypass_GetWindow
//Bypass_GetWindowText

IsHidemaruMail=//IsHidemaruMail関数(TkInfo.dll)\n//現在のマクロが実行されているのが秀丸メールの中か、それとも秀丸の中なのかを返します。\nloaddll "tkinfo.dll";\n\tif( ! result ) goto HidemaruProcess;\n\tif( ! dllfunc( "IsHidemaruMail" ) ) goto HidemaruProcess;\n\t// 秀丸メールの場合の処理 ...\n\tendmacro;\nHidemaruProcess:\n\t// 秀丸エディタの場合の処理 ...\n
IsHidemaruMailGrep=//IsHidemaruMailGrep関数(TkInfo.dll)\n//現在のマクロが秀丸メールの検索結果ウィンドウ中のメール内容部分で実行されてるかどうかを返します。検索結果ウィンドウ上で間違って実行されてるかどうかのチェック用に使ってください。\n//返り値(数値型)\n//IsHidemaruMailGrep関数は、検索結果の一覧上またはリモートメールダイアログボックス中の場合は1、そうでない場合は0を返します。\n##n = dllfunc("IsHidemaruMailGrep") ;\n
IsHidemaruMailMacroExecuting=//IsHidemaruMailMacroExecuting関数(TkInfo.dll)\n//秀丸メール上で現在マクロ実行中かどうか返します。こちらについては秀丸エディタ側から呼び出されることを想定しています。\n//秀丸メールと秀丸エディタと連携して何かする場合に、相手側のソフトがマクロ実行中かどうか調べるのに使います。\n//備考\n//秀丸エディタ側からtkinfo.dllの関数を呼び出すには、秀丸メールのレジストリから秀丸メールのインストールされたフォルダを調べる必要があります。具体的にはHKEY_CURRENT_USER\\Software\\Hidemaruo\\TuruKame\\ConfigのTuruKameDirキーを参照する必要があります。\n##n = dllfunc("IsHidemaruMailMacroExecuting") ;\n
IsHidemaruMailMain=//IsHidemaruMailMain関数(TkInfo.dll)\n//秀丸メールの本体ウィンドウ中かどうか\nif(dllfunc("IsHidemaruMailMain")){\n\t##n = dllfunc("SwitchUnread");\n} else {\n\t##n = dllfunc("Sync");\n\t##hd = hidemaruhandle(0);\n\t##n = dllfunc("SetMainWndTop");\n\t##n = dllfunc("SwitchUnread");\n\tsetactivehidemaru ##hd;\n}\n
HidemaruMailVersion=//HidemaruMailVersion関数(TkInfo.dll)\n//秀丸メールのバージョン番号を返します。1.00の時は100、0.58の時は58のように、100倍した値を返します。\n//返り値(数値型)\n//秀丸メールのバージョン番号を100倍した値です。\n##ver = dllfunc("HidemaruMailVersion");\n
IsTuruKame=//IsTuruKame関数(TkInfo.dll)\n//現在のマクロが実行されているのが秀丸メールの中か、それとも秀丸の中なのかを返します。\nloaddll "tkinfo.dll";\n\tif( ! result ) goto HidemaruProcess;\n\tif( ! dllfunc( "IsHidemaruMail" ) ) goto HidemaruProcess;\n\t// 秀丸メールの場合の処理 ...\n\tendmacro;\nHidemaruProcess:\n\t// 秀丸エディタの場合の処理 ...\n
IsTuruKameGrep=//IsTuruKameGrep関数(TkInfo.dll)\n//現在のマクロが秀丸メールの検索結果ウィンドウ中のメール内容部分で実行されてるかどうかを返します。検索結果ウィンドウ上で間違って実行されてるかどうかのチェック用に使ってください。\n//返り値(数値型)\n//IsHidemaruMailGrep関数は、検索結果の一覧上またはリモートメールダイアログボックス中の場合は1、そうでない場合は0を返します。\n##n = dllfunc("IsHidemaruMailGrep") ;\n
IsTuruKameMacroExecuting=//IsTuruKameMacroExecuting関数(TkInfo.dll)\n//秀丸メール上で現在マクロ実行中かどうか返します。こちらについては秀丸エディタ側から呼び出されることを想定しています。\n//秀丸メールと秀丸エディタと連携して何かする場合に、相手側のソフトがマクロ実行中かどうか調べるのに使います。\n//備考\n//秀丸エディタ側からtkinfo.dllの関数を呼び出すには、秀丸メールのレジストリから秀丸メールのインストールされたフォルダを調べる必要があります。具体的にはHKEY_CURRENT_USER\\Software\\Hidemaruo\\TuruKame\\ConfigのTuruKameDirキーを参照する必要があります。\n##n = dllfunc("IsHidemaruMailMacroExecuting") ;\n
IsTuruKameMain=//IsTuruKameMain関数(TkInfo.dll)\n//秀丸メールの本体ウィンドウ中かどうか\nif(dllfunc("IsHidemaruMailMain")){\n\t##n = dllfunc("SwitchUnread");\n} else {\n\t##n = dllfunc("Sync");\n\t##hd = hidemaruhandle(0);\n\t##n = dllfunc("SetMainWndTop");\n\t##n = dllfunc("SwitchUnread");\n\tsetactivehidemaru ##hd;\n}\n
TuruKameVersion=//TuruKameVersion関数(TkInfo.dll)\n//秀丸メールのバージョン番号を返します。1.00の時は100、0.58の時は58のように、100倍した値を返します。\n//返り値(数値型)\n//秀丸メールのバージョン番号を100倍した値です。\n##ver = dllfunc("HidemaruMailVersion");\n
SelectAllMail=//SelectAllMail関数(TkInfo.dll)\n//Ver4.59以降で実行可能\n//メール一覧に現在表示しているメールをすべて選択します。\n##n = dllfunc("SelectAllMail") ;
SetInfoItemFolder=//SetInfoItemFolder関数(TkInfo.dll)\n//情報アイテムの保存先フォルダを指定します。\n//実際に情報アイテムとして保存するためには、To:ヘッダに「@.item」を書くような\n//命令も必要で、しかもそれはSetInfoItemFolder命令よりも先でないとダメです。\n//数値の所に\n//"1"を指定すると、情報アイテム保存時に保存先の確認メッセージを出さなくします。\n//"2"を指定すると、逆に確認メッセージを必ず出すという意味になります。\n//Ver4.68以降で使用可能\n##n = dllfunc("SetInfoItemFolder","",$$Folder,1);\n
GetMailSize=//GetMailSize関数(TkInfo.dll)\n//V4.55以降で実行可能\n//メールのサイズを取得します。\n//秀丸メール本体上でもメールエディタ上でも実行できます。\n//パラメータ1(数値型) \n//0を指定するか、またはパラメータを省略すると、添付ファイルも含んだメールの総\n//バイト数を返します。\n//0以外を指定すると、添付ファイルを含まないメールのサイズを返します。\n##n = dllfunc("GetMailSize");
GetTitleListTopIndex=//GetTitleListTopIndex関数(TkInfo.dll)\n//V4.57以降で実行可能\n//メール一覧上での、表示されているメールの中での一番上のメールの、一覧内での順序\n//（0〜）を返します。パラメータはありません。\n##n = dllfunc("GetTitleListTopIndex");
GetTitleListHeight=//GetTitleListHeight関数(TkInfo.dll)\n//V4.57以降で実行可能\n//メール一覧ウィンドウの高さを返します。何通のメールを表示可能かの、行数を返します。\n//切れが悪い行（上半分しか見えない行）も含めて行数を数えます。\n##n = dllfunc("GetTitleListHeight");
SetTitleListTopIndex=//SetTitleListTopIndex関数(TkInfo.dll)\n//V4.57以降で実行可能\n//メール一覧のスクロール制御 \n//メール一覧上での一番上に表示するメールの、メール一覧内での順序を指定します。\n//パラメータで番号を指定します。メール一覧に表示しているメール数よりも大きい番号を\n//指定した場合や、そのメールを一番上に表示するとスクロールしすぎてしまう場合には、\n//一番下のメールが見える限度までスクロールアップした表示となります。\n//\n//パラメータ1\n// メール一覧上でのメールの番号です。一番上が0、その下が1、…という具合の番号です。\n//例（メール一覧を一番下にスクロールさせる例） \n##n = dllfunc("SetTitleListTopIndex", 999999);
GetTransmitCommandCode=//GetTransmitCommandCode関数(TkInfo.dll)\n//V4.55以降で実行可能\n//「マクロ・マクロ登録・自動起動」の「送受信の開始直前」の所で指定されたマクロが\n//自動実行された時に、そのマクロが具体的にどういうコマンドによって起動されたのか\n//知るために用意されています。\n//返り値（数値型） \n//送受信系のコマンドコードを返します。この値は秀丸メール内部のコマンドコードそのままです。\n//具体的なコマンドコードと実際のコマンドとの対応は以下のようになっています。\n//受信 40003 \n//送受信 40216 \n//未送信メールの送信 40059 \n//すべて送受信 40024 \n//すべて受信 40143 \n//すべて送信 40144 \n//すべて送信の後終了 40210 　（このコマンドは、秀丸メール本体を終了する時に未送信メールが残っていて、それを送信するようユーザー様が指示した時に発生する。）  \n//リモートメール 40074 \n//リモートメール - 現在メールの再受信 40209 \n//リモートメール - 現在メールを削除 40211 \n//リモートメールその２ 40101 　（このコマンドは、定期受信でメール一覧の取得のみをする設定の時に、新着メールを見つけてリモートメール一覧のダイアログボックスを表示する時に発生する）\n//定期受信 1\n##n = dllfunc("GetTransmitCommandCode");
StartDoGrep=//StartDoGrep関数(TkInfo.dll)\n//Ver4.61以降で実行可能\n//DoGrep関数と同じく「検索して一覧作成」を実行する関数ですが、こちらの関数は、\n//マクロが終了するのを待ってから遅延して「検索して一覧作成」を実行します。\n//この関数は、「検索して一覧作成」の後に特にマクロで何かする目的が無い場合用で、\n//検索に時間がかかる場合に検索を実行してるのと平行して何らかの操作をして、その\n//過程で「マクロ実行中なので××が出来ない」のような不便なことが無いように用意してあります。\n//\n//StartDoGrep関数を呼び出した後は、すみやかにマクロを終了させてください。\n\n##n = dllfunc("StartDoGrep", "テストアカウント", "受信+送信済み+ユーザー");\nendmacro;\n
GetGrepResultGroup=//GetGrepResultGroup関数(TkInfo.dll)\n//パラメータ１（文字列型） \n//　GetGrepResult関数で取得した文字列をそのまま渡します。\n//返り値（文字列型） \n//　この検索結果が所属していたグループ名（グループのパス名）を、"Group(/.../...)"のような形式で返します。\n//Ver4.64以降で使用可能\nloaddll "tkinfo.dll";\n$$find = input( "検索する文字列は？");\nif( $$find == "" ) endmacro;\n\n// BookGrep\nif( dllfunc("DoBookGrep", $$find, 0 ) == 0 ) {\n\tmessage "エラー";\n\tendmacro;\n}\n\n##i = 0;\nwhile(1) {\n\t$$menu[##i] = dllfuncstr("GetGrepResult", ##i);\n\t$$menu_g[##i] = dllfuncstr("GetGrepResultGroup", $$menu[##i]);\n\n\t$$menu[##i] = dllfuncstr("GetGrepResult", ##i);\n\tif( $$menu[##i] == "" ) {\n\t   break;\n\t}\n\t$$menu[##i] = dllfuncstr("GetBookItemPart", $$menu[##i], -1 );\n\t##i = ##i + 1;\n}\nmenuarray $$menu, ##i;\nmenuarray $$menu_g, ##i;
SetAutoPushTimerEver=//SetAutoPushTimerEver関数(TkInfo.dll)\n//パラメータで指定されたウィンドウ配下に出てくるメッセージボックス／ダイアログ\n//ボックスについて、すべて自動的にボタンを押してしまう動作をします。メッセージ\n//ボックス／ダイアログボックス類による問い合わせが連続して出てくるようなケース\n//で、それらをすべて自動処理させたい場合に使います。\n##n = dllfunc("SetAutoPushTimerEver", hidemaruhandle(0), "yes");\n##n = dllfunc("SendNow");\n##n = dllfuc("StopAutoPushTimer");\n
StopAutoPushTimer=//StopAutoPushTimer関数(TkInfo.dll)\n//SetAutoPushTimer系関数でセットしたタイマーを止めます。\n//SetAutoPushTimer/SetAutoPushTimerMilli関数の場合は別に必要ありませんが、\n//SetAutoPushTimerEver関数を呼び出した場合は、マクロを終了する前に、必ずこの\n//関数を呼び出すようにしてください。でないとマクロを終了した後もタイマーが動作し\n//続けてしまい、余計な警告メッセージ類まで自動的に処理されてしまう恐れがあります。\n##n = dllfunc("SetAutoPushTimerEver", hidemaruhandle(0), "yes");\n##n = dllfunc("SendNow");\n##n = dllfuc("StopAutoPushTimer");\n
SaveConfig_hmml=//SaveConfig関数(TkInfo.dll)\n//秀丸メールの現在の設定をレジストリに保存します。\n//この関数は、一般に、内部的な設定値を調べるために使うか、または内部的な設定値の\n//中の一部だけを書き換えたい時に、他の設定値を壊さないようにするために、レジスト\n//リを書き換える直前に呼び出して使うことになります。\nloaddll "tkinfo.dll";\n##n = dllfunc("SaveConfig", 0);\nopenreg "CURRENTUSER", "Software\\\\Hidemaruo\\\\TuruKame\\\\Config";\nwriteregnum "FindPersonSel", 0;    // 検索対象フォルダを「すべてのアカウント」にする\nclosereg;\n##n = dllfunc("EnvChanged", 1);\n
IsFunctionExist=//IsFunctionExist関数(TkInfo.dll)\n//Ver4.61以降で動作可能\n//特定のDLLが特定の関数をエクスポートしているかどうかを調べます。\n//パラメータ１（文字列型） \n//　DLLのファイル名を指定します。ファイル名は、フルパスで指定してもいいし、ファイル名だけを指定してもいいです。\n//パラメータ２（文字列型） \n//　関数の名前を指定します。\nif( ! dllfunc("IsFunctionExist", "tkinfo.dll", "GetSpamFilterTitle") ) {\n\tmessage "秀丸メールのバージョンが古いです。";\n}
LoadAndGetSpamFilter=//LoadAndGetSpamFilter関数(TkInfo.dll)\n//全般的な設定にて指定された迷惑メールフィルターをロードして、ロードに成功した\n//場合はそのファイル名を返します。ロードに失敗した場合や、迷惑メールフィルター\n//の使用がOFFになっている場合は、""を返します。\n//　マクロからは、この関数を使って迷惑メールフィルターをロードして、その後、\n//迷惑メールフィルターがサポートしているマクロ用の関数を呼び出すことが出来ます。\nloaddll "tkinfo.dll";\n$$filter = dllfuncstr("LoadAndGetSpamFilter");\nif( $$filter == "" ) endmacro;\nloaddll $$filter;\n##n = dllfunc("AppendSpamWordFromFile", "c:\\\\temp.txt");\n
GetSpamFilterTitle=//GetSpamFilterTitle関数(TkInfo.dll)\n//Ver4.61以降で実行可能\n//迷惑メールフィルターのタイトル文字列を返します。\n//迷惑メールフィルターを使う設定でない場合は""を返します。\n//返す値は文字列型で、パラメータはありません。\nmessage dllfuncstr("GetSpamFilterTitle");
GetSpamFilterVersion=//GetSpamFilterVersion関数(TkInfo.dll)\n//Ver4.61以降で実行可能\n//迷惑メールフィルターのバージョン番号文字列を返します。\n//迷惑メールフィルターを使う設定でない場合は""を返します。\nmessage dllfuncstr("GetSpamFilterVersion");
EnterPrintMulti=//EnterPrintMulti関数(TkInfo.dll)\n//V4.16以降で実行可能\n//秀丸パブリッシャーによる印刷をマクロから制御する場合で、hidemaruapi.dllの\n//PrintDialog関数等を使う場合で、しかも、複数のメールをまとめて印刷する場合、\n//EnterPrintMultiしてからPrintDialog関数などを呼び出して、印刷が終わったら\n//LeavePrintMulti関数を呼んでください。\n//　EnterPrintMultiしている最中には、メールの選択状態を変更するようなマクロ命令は\n//一切入れないでください。\n//　LeavePrintMultiしないでマクロを終了すると、メモリリークしたり後々になって死ん\n//でしまったりすると思います。\nloaddll "tkinfo.dll";\n##tmp = dllfunc("EnterPrintMulti");\nloaddll "hidemaruapi.dll";\n//...\n//...\n##tmp = dllfunc("PrintDialog", .... );\n//...\n//...\nloaddll "tkinfo.dll";\n##tmp = dllfunc("LeavePrintMulti");
LeavePrintMulti=//LeavePrintMulti関数(TkInfo.dll)\n//V4.16以降で実行可能\n//秀丸パブリッシャーによる印刷をマクロから制御する場合で、hidemaruapi.dllの\n//PrintDialog関数等を使う場合で、しかも、複数のメールをまとめて印刷する場合、\n//EnterPrintMultiしてからPrintDialog関数などを呼び出して、印刷が終わったら\n//LeavePrintMulti関数を呼んでください。\n//　EnterPrintMultiしている最中には、メールの選択状態を変更するようなマクロ命令は\n//一切入れないでください。\n//　LeavePrintMultiしないでマクロを終了すると、メモリリークしたり後々になって死ん\n//でしまったりすると思います。\nloaddll "tkinfo.dll";\n##tmp = dllfunc("EnterPrintMulti");\nloaddll "hidemaruapi.dll";\n//...\n//...\n##tmp = dllfunc("PrintDialog", .... );\n//...\n//...\nloaddll "tkinfo.dll";\n##tmp = dllfunc("LeavePrintMulti");
AddSama=//AddSama関数(TkInfo.dll)\n//Ver4.61以降で実行可能\n//パラメータとして「名前+Email」の文字列を受け取って、その名前部分に「様」を\n//付けて返します。\n//パラメータ１（文字列型） \n//　「様」を付けて欲しい、名前+Email形式の（To:ヘッダなどで指定する形式の）文字列です。\n//パラメータ２（文字列型） \n//　"様"じゃなくて何か他の文字列を付けたい場合は、パラメータ２にその文字列を指定します。"様"でいい場合はパラメータ２を省略してください。\n//返り値（文字列型） \n//　「様」付きになった文字列を返します。\n//例 \n$$s = dllfuncstr("AddSama", "斉藤秀夫 <aaa@bbb.ccc>");
IsFunctionExist=//IsFunctionExist関数(TkInfo.dll)\n//IsFunctionExist関数\n//Ver4.61以降で実行可能\n//特定のDLLが特定の関数をエクスポートしているかどうかを調べます。\n//パラメータ１（文字列型） \n//　DLLのファイル名を指定します。ファイル名は、フルパスで指定してもいいし、\n//ファイル名だけを指定してもいいです。\n//パラメータ２（文字列型） \n//　関数の名前を指定します。\n//返り値（数値型） \n//　関数が存在する場合は１、そうでない場合は０を返します。\nif( ! dllfunc("IsFunctionExist", "tkinfo.dll", "GetSpamFilterTitle") ) {\n\tmessage "秀丸メールのバージョンが古いです。";\n}\n
SetFolderIcon=//SetFolderIcon関数(TkInfo.dll)\n//V4.59以降で実行可能\n//現在選択しているフォルダのアイコンをパラメータで指定されたアイコンに変更します。\n//SetFolderIcon関数のパラメータ１（数値型） \n// アイコンの種類を0〜7の数値で指定します。0が標準のアイコン、1が赤、\n//2が緑、他、フォルダ毎の設定でのアイコンの並び順と同じです。\n//返り値（数値型） \n//現在選択しているフォルダのアイコンの種類を数値で返します。\n##n = dllfunc("SetFolderIcon", 2);
GetFolderIcon=//GetFolderIcon関数(TkInfo.dll)\n//V4.59以降で実行可能\n//現在選択しているフォルダのアイコンの種類を返します。\n//返り値（数値型） \n//現在選択しているフォルダのアイコンの種類を数値で返します。\n##n = dllfunc("GetFolderIcon");
RefreshFolder=//RefreshFolder関数(TkInfo.dll)\n//V4.59以降で実行可能\n//アカウント一覧／フォルダ一覧をもう一度読み込み直しして、それを元に、フォルダ枠を\n//再構築します。\n//メール用のアカウントやフォルダ類を秀丸メールのコマンドを経由せずに作成／削除した\n//あとに、その変更されたことを秀丸メールに反映させるのに使います。\n//返り値（数値型） \n//　返り値には意味がありません。\n##n = dllfunc("RefreshFolder");
SetHotIcon=//SetHotIcon関数(TkInfo.dll)\n//V4.55以降で実行可能\n//秀丸メール本体およびタスクトレー中の常駐秀丸メールのアイコンを、「新着メール\n//あり」のアイコンにしたり、逆に新着メールありアイコンから普通のアイコンに戻し\n//たりします。\n//パラメータ１（数値型） \n//　新着メールあり状態にするなら１、新着メールあり状態を解除するなら０を指定します。\n//返り値（数値型） \n//　秀丸メール本体ウィンドウが送受信系コマンド実行中の場合は、アイコンを変化\n//させることなく０を返します。\n//　送受信中でない場合は１を返しますが、この場合は必ずしもアイコンが変化して\n//いるとは限りません。具体的には、秀丸メール本体ウィンドウがアクティブな状態で\n//「新着メールあり」を指示しても、それはそれでキャンセルされつつ、返り値は１となります。\n//　新着メールあり状態を解除する指示については、送受信中でない限り、必ず成功します。\n##n = dllfunc("SetHotIcon", 0);
IsPasswordProtected=//IsPasswordProtected関数(TkInfo.dll)\n//V4.50以降で実行可能\n//秀丸メール起動時のパスワードが設定されているかどうか、および「アイコンから復帰\n//する時にもパスワードを要求する」がONかどうかを返します。\n//返り値（数値型） \n//　パスワードが設定されてない場合は0を返します。\n//パスワードが設定されていて、「アイコンから復帰する時にもパスワードを要求する」\n//がOFFの場合は1を返します。\n//パスワードが設定されていて、「アイコンから復帰する時にもパスワードを要求する」\n//がONの場合は2を返します。\nif( dllfunc("IsPasswordProtected") ) {\n\tmessage "パスワードが設定されているのでこのマクロは使えません。";\n}
ShiftDate=//ShiftDate関数(TkInfo.dll)\n//V4.17以降で実行可能\n// ShiftDate関数は、Date:ヘッダ中にあるような日付文字列から相対的な日付の計算を\n// し、結果を、同じくDate:ヘッダにあるような形式の文字列で返します。\n// パラメータの指定によって時間や分の足し引きも出来ます。(V4.72から)\n//パラメータ1(文字列型) \n// 変換したい日付文字列です。一般には返信メールや転送メールでの元メールの日付を\n//指定することがほとんどだと思います。\n//例えばテンプレートの場合なら、$(RootHeader,Date)を指定します。\n//パラメータ2(文字列型または数値型) \n// 数値型を指定する場合、シフトさせる日数を指定します。+1を指定すれば明日って\n//意味になり、-1を指定すれば昨日って意味になります。\n//文字列型を指定する場合、"+1"や"1"や"-2"などの数値そのままの文字列を指定すると、\n//その通りで計算します。ただし、"+1-2"のような計算式は指定できません。\n//"月"などの曜日を指定すると、パラメータ1の属する週の中でのその曜日の日を計算\n//します。例えば今日が1月3日の火曜日だとすると、"水"が指定されれば明日の1月4日\n//という計算結果になります。\n//日付の「+1」や「-1」等の数値の後ろにピリオド区切りで時間を指定することも出来\n//ます。さらにはその後ろにピリオド区切りで分も指定できます。例えば2時間後を計算\n//したい場合は"+0.2"を指定し、30分前ならば、"-0.0.30"と指定すればいいです。\n//返り値(文字列型) \n// 変換された日付/時刻文字列です。\n$$date = dllfuncstr("CurrentDate");\n$$date = dllfuncstr("ShiftDate", $date, "-7");\t  // 一週間前。\n$$date = dllfuncstr("ShiftDate", $date, "月");\t  // 先週の月曜日。\n$$date = dllfuncstr("ShiftDate", $date, "+0.2.30");    // ２時間３０分後\n

Fuzzy_OptionDialog=//HmJre.dllを利用\nloaddll "HmJre.dll" ;\n//Fuzzy_OptionDialog関数 \n//あいまい検索の設定ダイアログボックスを表示します。\n//第1パラメータ(数値型):ダイアログボックスの親となるウィンドウのハンドルを指定します。\n//普通はhidemaruhandle(0)を指定してください。\n//返り値(数値型): OKボタンを押して設定を完了した場合は1、\n//キャンセルボタンを押した場合は0を返します。\n##n = dllfunc( "Fuzzy_OptionDialog", \n\thidemaruhandle(0));\nmessage str(##n) ;\nfreedll;\n
JreGetVersion=//HmJre.dllを利用\nloaddll "HmJre.dll" ;\n//JreGetVersion関数 \n//HmJre.dllのバージョン番号を返します。dllfunc関数で呼び出し可能です。\n//パラメータはありません。\n//返り値(数値型): \n//返り値は、下位の２バイトのみが有効で、上位ワードにはでたらめな値が入って\n//しまいます。以下のようにしてバージョン番号を取得してください。\n##ver = (((dllfunc("JreGetVersion") & 0xFF00) / 256) * 100) +\n\t\t((dllfunc("JreGetVersion") & 0xF0) / 16 * 10) + \n\t\t(dllfunc("JreGetVersion") & 0xF) ;\t\n$$mes = \n\t"現在のHmJre.DLL版数=" + \n\tleftstr(str(##ver),1) + "." + \n\tmidstr(str(##ver),1,1) + "." + \n\tmidstr(str(##ver),2,1) + "\\n" ;\nmessage $$mes ;\nfreedll;\n
FindRegular=//HmJre.dllを利用\nloaddll "HmJre.dll" ;\n//FindRegular(V1.50以降から)\n//特定の文字列から特定の正規表現パターンのマッチングをして、ヒットした場合は\n//その位置を返します。\n//第1パラメータ(文字列型): 検索したい正規表現文字列を指定します。 \n//第2パラメータ(文字列型): 検索対象の文字列を指定します。 \n//第3パラメータ(数値型): 検索を開始する桁位置を指定します。\n//先頭から検索したい場合は0を指定します。 \n//返り値(数値型): ヒットした場合は桁位置(0以上の値)を返します。\n//ヒットしなかった場合は-1を返します。\n//正規表現の解釈その他でエラーが起きた場合は-2を返します。 \n//例:\n\t$$reg_str = "(教授|部長|次長|課長|係長|主任|補佐|局長|事務長|センター長|先生|様|殿|さん|御中)" ;\n\t$$target = "太郎さん" ;\n\t##n = dllfunc( "FindRegular", \n\t\t$$reg_str,\n\t\t$$target, 0 );\n\t//敬称文字列が一致\n\tif (##n > 0) {\n\t\tmessage "match" ;\n\t}\n\telse if(##n == -1){\n\t\tmessage "Not match" ;\n\t}\n\telse if(##n == -2){\n\t\tmessage "正規表現の解釈その他でエラーが発生" ;\n\t}\nfreedll;\n
FindRegularNoCaseSense=//HmJre.dllを利用\nloaddll "HmJre.dll" ;\n//FindRegularNoCaseSense関数(V1.50以降から) \n//大文字／小文字を区別しないで検索する以外は、FindRegular関数とまったく同じです。\n//FindRegular(V1.50以降から)\n//特定の文字列から特定の正規表現パターンのマッチングをして、ヒットした場合は\n//その位置を返します。\n//第1パラメータ(文字列型): 検索したい正規表現文字列を指定します。 \n//第2パラメータ(文字列型): 検索対象の文字列を指定します。 \n//第3パラメータ(数値型): 検索を開始する桁位置を指定します。\n//先頭から検索したい場合は0を指定します。 \n//返り値(数値型): ヒットした場合は桁位置(0以上の値)を返します。\n//ヒットしなかった場合は-1を返します。\n//正規表現の解釈その他でエラーが起きた場合は-2を返します。 \n//例:\n\t$$reg_str = "(教授|部長|次長|課長|係長|主任|補佐|局長|事務長|センター長|先生|様|殿|さん|御中)" ;\n\t$$target = "太郎さん" ;\n\t##n = dllfunc( "FindRegularNoCaseSense", \n\t\t$$reg_str,\n\t\t$$target, 0 );\n\t//敬称文字列が一致\n\tif (##n > 0) {\n\t\tmessage "match" ;\n\t}\n\telse if(##n == -1){\n\t\tmessage "Not match" ;\n\t}\n\telse if(##n == -2){\n\t\tmessage "正規表現の解釈その他でエラーが発生" ;\n\t}\nfreedll;\n
GetLastMatchLength=//HmJre.dllを利用\nloaddll "HmJre.dll" ;\n//GetLastMatchLength関数(V1.50以降から) \n//FindRegularまたはFindRegularNoCaseSense関数で0以上の値が返った場合に、\n//マッチした文字列の長さを返します。\n//パラメータはありません。\n//返り値(数値型): マッチした文字列の長さを返します。\n//全角一文字も半角一文字も長さを1と返す模様。\n//HmJre.dllを利用\nloaddll "HmJre.dll" ;\n\t$$reg_str = "(教授|部長|次長|課長|係長|主任|補佐|局長|事務長|センター長|先生|様|殿|さん|御中)" ;\n\t$$target = "太郎さん" ;\n\t##n = dllfunc( "FindRegular", \n\t\t$$reg_str,\n\t\t$$target, 0 );\n\t//敬称文字列が一致\n\tif (##n > 0) {\n\t\tmessage "match" ;\n\t\t##len = dllfunc( "GetLastMatchLength") ;\n\t}\n\telse if(##n == -1){\n\t\tmessage "Not match" ;\n\t}\n\telse if(##n == -2){\n\t\tmessage "正規表現の解釈その他でエラーが発生" ;\n\t}\n\t\nfreedll;\n//全角に対応するため田楽DLLを利用する。\nloaddll "DengakuDLL.dll" ;\n\t//文字列の途中から指定文字数分の文字列を抜き出します。\n\t$$s = dllfuncstr("MIDSTR",$$target,##n,##len);\n\tmessage $$target + "\\n" + $$s ;\nfreedll;\n
LoadRootMail=//LoadRootMail関数（TKInfo.dll）\n//返信元メールまたは転送元メールを検索して、そのメール内容をメモリ上に読\n//み込んで、\n//RootXXXX系関数がうまく動作するようにします。\n//返信メール/転送メールコマンドで起動されたエディタ上で一度メールを保存\n//して終了\n//してしまった場合で、そのメールをもう一度エディタで開いた時に、そのエデ\n//ィタ上で\n//RootXXXX系関数（RootBody/SmallRootHeader関数など）を使いたい時に呼び出\n//す用です。\n//普通に「返信メール」や「転送メール」等のコマンドで起動されたエディタ上\n//では最初\n//から返信元/転送元メールが読み込まれているので、別にLoadRootMailする必\n//要はあり\n//ません。\n//返り値（数値型） \n//　読み込みに成功した場合は1、失敗した場合は0を返します。\n//例 \n##n = dllfunc("LoadRootMail");\nif( ##n == 0 ) {\n\tmessage "返信元/転送元メールが見つかりませんでした。";\n}\n
CallByEmailList=//CallByEmailList関数（TKInfo.dll）\n//コンマで区切られたメールアドレス文字列の中から、１つ１つのメールアドレスを\n//取り出して、その１つ１つについて指定された関数を呼び出し、それの結果を再び\n//コンマ区切りの形にして返します。\n//この関数を使うと、CountEmailList/GetEmailList関数でループさせていた処理が\n//一発で実行できます。\n//\n//パラメータ1 \n//\t呼び出したい関数名です。\n//パラメータ2 \n//\tメールアドレスを含む文字列です。\n//パラメータ3以降 \n//\tパラメータ1で指定する関数に追加で渡したいパラメータがある場合は、それを\n//\tパラメータ3以降で指定してください。(最高8個まで指定できます)\n//返り値（文字列型） \n//\tパラメータ１で指定された関数を呼び出した結果（複数の結果）をコンマ区切りにして返します。\n//例 \n$$s = dllfuncstr("CallByEmailList", "FindBook2", "abc <abc@abc>, xyz <xyz@xyz>");\n
DontOrikaeshi=//DontOrikaeshi関数（TKInfo.dll）\n//パラメータで渡された文字列を自動折り返し禁止扱いの文字列に変換して返します。\n//具体的には改行コードを「CR CR LF」の形式に変換して返します。\n//パラメータ１（文字列型） \n// 自動折り返し禁止にしたい文字列です。\n//返り値（文字列型） \n// 自動折り返し禁止になった文字列です。\n//備考 \n// DontOrikaeshi関数の内部処理に長さの制限はありませんが、マクロの文字列変数は\n// ８キロバイト程度までしか扱うことができないので注意してください。\n// この関数はテンプレートで使う用に用意されている関数です。\n//例 \n$$s = dllfuncstr("DontOrikaeshi", dllfuncstr("QuotedRootBody"));\n
StopAutoPushTimer=//StopAutoPushTimer関数（TKInfo.dll）\n//SetAutoPushTimer系関数でセットしたタイマーを止めます。\n//SetAutoPushTimer/SetAutoPushTimerMilli関数の場合は別に必要ありませんが、\n//SetAutoPushTimerEver関数を呼び出した場合は、マクロを終了する前に、必ず\n//この関数を呼び出すようにしてください。でないとマクロを終了した後もタイマー\n//が動作し続けてしまい、余計な警告メッセージ類まで自動的に処理されてしまう\n//恐れがあります。\n//例 \n##n = dllfunc("SetAutoPushTimerEver", hidemaruhandle(0), "yes");\n##n = dllfunc("SendNow");\n##n = dllfunc("StopAutoPushTimer");\n

SETVAR_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//SETVAR\n//使い方:#n = dllfunc("SETVAR",$s1,$s2);\n//説明:DengakuDLL.DLL を使用する全てのプロセス(秀丸ウィンドウ)で共有\n//される、 (永続的な)グローバル変数を定義します。\n//引数:\n//\t$s1:変数の名前\n//\t変数名の先頭に "@" を付けるとその変数は永続的なものになり、 DLL がアンロードされた後も保存され、 次回の DLL のロード時に自動的に読み込まれます。\n//\tなお、変数用に用意されているメモリは変数名とその値を合わせて 16MB \n//\t程度なので、 大量のデータを定義する際はその制限に十分注意して下さい。\n//\t$s2:変数の値\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//備考:Ver.2.20 からグローバル変数の実装を変更したため、 それ以前のバージョンの田楽ＤＬＬ/サーバとグローバル変数の共有が できなくなりました。したがって、 ２つのウィンドウ(プロセス)間で変数を共有する場合は 両者共に Ver.2.20 以降のＤＬＬ/サーバを利用してください。\n//例:\n//\t元ウィンドウで DLL をロード\nloaddll hidemarudir + "\\\\DengakuDLL.dll";\n//\tグローバル変数の定義\nif (dllfunc("SETVAR","arg0","this is arg 0.") == 0\t||\n\tdllfunc("SETVAR","arg1","this is arg 1.") == 0\t||\n\tdllfunc("SETVAR","arg2","this is arg 2.") == 0) {\n\tmessage "変数の定義に失敗!!";\n\t//...\n}\n//\t別ウィンドウのオープン\nopenfile "foo.txt";\n//\t別ウィンドウで新たに DLL をロード\nloaddll hidemarudir + "\\\\DengakuDLL.dll";\n//\t定義しておいたグローバル変数を読み込む\n##a = 0;\nwhile (##a < 3) {\n\t$arg[##a] = dllfuncstr("GETVAR","arg" + str(##a));\n\tif (dllfunc("DELVAR","arg" + str(##a))) break;\n\t##a = ##a + 1;\n}\n//...\n//\t永続的なグローバル変数の定義(マクロ終了後も保存される)\nif (dllfunc("SETVAR","@super_global","this is super-global var.") == 0) {\n\tmessage "永続的変数の定義に失敗!!";\n}\n//\t別ウィンドウでロードした DLL のアンロード\n//\t(この時点では全てのグローバル変数がメモリ上に残った状態になる)\nfreedll;\nclosehidemaruforced hidemaruhandle(0);\n//\t元ウィンドウでロードした DLL のアンロード\n//\t(この時点で @super_global の値(のみ)が保存される)\nfreedll;\n//...\n
GETVAR_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//GETVAR\n//使い方:$s = dllfuncstr("GETVAR",$s1);\n//説明:SETVAR 関数 で定義した変数の値を取り出します。\n//引数:\n//\t$s1:変数の名前\n//返り値:変数の値\n//(未定義の変数に対しては "" を返しますが、 これだけでは "" という値\n//を持つ変数と区別ができません。 変数が定義されているかどうかの判断は EXISTVAR 関数 で行って下さい。)\n//例:(SETVAR 関数 の例を参照して下さい。)\n
DELVAR_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//DELVAR\n//使い方:#n = dllfunc("DELVAR",$s1);\n//説明:変数を削除します。\n//引数:\n//\t$s1:変数の名前\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(SETVAR 関数 の例を参照して下さい。)\n
EXISTVAR_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//EXISTVAR\n//使い方:#n = dllfunc("EXISTVAR",$s1);\n//説明:変数が定義されているかどうかを調べます。\n//引数:\n//\t$s1:変数の名前\n//返り値:変数が定義されている場合は 1 を、そうでなければ 0 を返します。\n//例:(省略)\n
ENUMVAR_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//ENUMVAR\n//使い方:#n = dllfunc("ENUMVAR");\n//説明:現在定義されている変数名を列挙します。 列挙された変数名を取得するには NEXTVAR 関数 を使用します。\n//引数:\n//\t(なし)\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\nif (dllfunc("ENUMVAR") == 0) {\n\tmessage "変数の列挙に失敗!!";\n\t//...\n}\nwhile (dllfunc("HASMOREVARS")) {\n\t$name = dllfuncstr("NEXTVAR");\n\t$value = dllfuncstr("GETVAR",$name);\n\t//...\n}\n//...\n
NEXTVAR_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//NEXTVAR\n//使い方:$s = dllfuncstr("NEXTVAR");\n//説明:ENUMVAR 関数 で列挙された変数名を 順に取り出します。\n//引数:\n//\t(なし)\n//返り値:変数名。列挙が終了したら "" を返します。 なお、列挙の順序は不定です。 あと、NEXTVAR 関数の呼出しの途中で SETVAR 関数 を呼び出して、 新しく変数を追加した場合の動作も不定になります。\n//例:(ENUMVAR 関数 の例を参照して下さい。)\n
HASMOREVARS_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//HASMOREVARS\n//使い方:#n = dllfunc("HASMOREVARS");\n//説明:ENUMVAR 関数 の呼出しの後、 まだ取り出されていない変数があるかどうかを調べます。\n//引数:\n//\t(なし)\n//返り値:まだ変数が残っている場合は 1 を、そうでなければ 0 を返します。\n//例:(ENUMVAR 関数 の例を参照して下さい。)\n
ATOI_dg=//田楽dllの機能を利用\n//田楽DLLVer1.7x〜にて対応\n//ATOI\n//使い方:#n = dllfunc("ATOI",$s1);\n//説明:数値の文字列表\現 $s1 を数値に変換します。\n//引数:\n//\t$s1:数値の文字列表\現\n//\t文字列の先頭が "0x" (または "0X") で始まる場合は１６進数、\n//\t"0b" または "0B" で始まる場合は２進数、\n//\tそうでなく先頭が "0" で始まる場合は８進数、\n//\tそれ以外の場合は１０進数とみなして変換します。\n//返り値:数値\n//例:\n#n = dllfunc("ATOI","0xC");    //  #n == 12  (１６進数)\n#n = dllfunc("ATOI","0b1100"); //  #n == 12  (２進数)\n#n = dllfunc("ATOI","014");    //  #n == 12  (８進数)\n#n = dllfunc("ATOI","12");\t   //  #n == 12  (１０進数)\n
ITOA_dg=//田楽dllの機能を利用\n//田楽DLLVer1.7x〜にて対応\n//ITOA\n//使い方:$s = dllfuncstr("ITOA",#n1,#n2);\n//説明:整数 #n1 の #n2 進数表\現を返します。\n//引数:\n//\t#n1:数値\n//\t#n2:基数(2 は２進数, 8 は８進数, 16 は１６進数、 それ以外は１０進数になります)\n//返り値:--- (８進数の先頭の "0"、１６進数の先頭の "0x" は付加されません)\n//例:\n$s = dllfuncstr("ITOA",12,2);  //  $s == "1100" (２進数)\n$s = dllfuncstr("ITOA",12,8);  //  $s == "14"\t(８進数)\n$s = dllfuncstr("ITOA",12,16); //  $s == "c"\t(１６進数)\n$s = dllfuncstr("ITOA",12,0);  //  $s == "12"\t(１０進数)\n
STRICMP_dg=//田楽dllの機能を利用\n//STRICMP\n//使い方:#n = dllfunc("STRICMP",$s1,$s2);\n//説明:半角アルファベットの大小を無視して２つの文字列を比較します。\n//\n//引数:\n//\t$s1:文字列１\n//\t$s2:文字列２\n//返り値:２つの文字列が一致していれば 0 を返します。 異なっている場合は正または負の整数を返します。\n//例:\n#r = dllfunc("STRICMP","ABC","Abc");\t//\t#r == 0\n#r = dllfunc("STRICMP","ＡＢＣ","ａｂｃ");\t//\t#r != 0 (全角文字のため)\n
STRCOUNT_dg=//田楽dllの機能を利用\n//STRCOUNT\n//使い方:#n = dllfunc("STRCOUNT",$s1,$s2);\n//説明:文字列中の部分文字列の個数を返します。\n//引数:\n//\t$s1:検索対象文字列\n//\t$s2:部分文字列\n//返り値:見つかった部分文字列の個数を返します。\n//例:\n$str = hidemarudir;\nmessage $str + " 中の円記号の個数は " +\n\t\tstr(dllfunc("STRCOUNT",$str,"\\\\")) + " 個です";\n$str = "AAAAA";\nmessage $str + " 中の AA の個数は " +\n\t\tstr(dllfunc("STRCOUNT",$str,"AA")) + " 個です"; // 2 個になります\n
GSUB_dg=//田楽dllの機能を利用\n//GSUB\n//使い方:$s = dllfuncstr("GSUB",$s1,$s2,$s3,#n4);\n//説明:文字列中の部分文字列を別の文字列に置換します。\n//引数:\n//\t$s1:置換対象文字列\n//\t$s2:検索文字列\n//\t$s3:置換文字列\n//\t#n4:最初から何個の文字列を置換するか\n//\t(-1 を指定すると見つかったものを全て置換します)\n//返り値:置換された結果の文字列が返ります。\n//例:\n$str = "C:\\\\usr\\\\home\\\\sugiura\\\\public_html\\\\index.html";\nmessage "DOS  name: " + $str + "\\n" +\n\t\t"UNIX name: " + dllfuncstr("GSUB",$str,"\\\\","/",-1);\n
GETTOKEN_dg=//田楽dllの機能を利用\n//GETTOKEN\n//使い方:$s = dllfuncstr("GETTOKEN",$s1,$s2);\n//説明:文字列から指定文字を区切り子として分割し、分割された文字列を返します。\n//引数:\n//\t$s1:対象文字列\n//\t$s2:区切り文字 (複数指定可)\n//返り値:最初の呼出しで先頭の文字列が返ります。 ２回目以降の呼出しで $s1 を "" とすると 次々に文字列を返します。\n//なお、取り出せる文字列がまだ残っているかどうかは HASMORETOKENS 関数で調べて下さい。\n//例:\n//\t円記号、コロン、ピリオドを区切りとして文字列を分割\n$token = dllfuncstr("GETTOKEN","C:\\\\dir\\\\foo.txt","\\\\:.");\nwhile (1) {\n\t//\t"C", "", "dir", "foo", "txt" の順に表\示される\n\tmessage "取り出された文字列は " + $token + " です。";\n\t//\tまだ文字列があるかどうか確認\n\tif (dllfunc("HASMORETOKENS") == 0) break;\n\t//\t次の文字列を取り出す\n\t$token = dllfuncstr("GETTOKEN","","\\\\:.");\n}\n
HASMORETOKENS_dg=//田楽dllの機能を利用\n//HASMORETOKENS\n//使い方:#n = dllfunc("HASMORETOKENS");\n//説明:GETTOKEN 関数 の実行中に まだ取り出せる文字列が残っているかどうかを調べます。\n//引数:\n//\t(なし)\n//返り値:まだ取り出せる文字列が残っていれば０でない値を、 もう取り出\n//す文字列がない場合は０を返します。\n//例:(GETTOKEN 関数 の例を参照して下さい)\n
LTRIM_dg=//田楽dllの機能を利用\n//LTRIM\n//使い方:$s = dllfuncstr("LTRIM",$s1);\n//説明:文字列の左端にある空白文字(半角スペース、タブ等)を取り除きます。\n//引数:\n//\t$s1:対象文字列\n//返り値:空白を除いた残りの文字列を返します。\n//例:(省略)\n
RTRIM_dg=//田楽dllの機能を利用\n//RTRIM\n//使い方:$s = dllfuncstr("RTRIM",$s1);\n//説明:文字列の右端にある空白文字(半角スペース、タブ等)を取り除きます。\n//引数:\n//\t$s1:対象文字列\n//返り値:空白を除いた残りの文字列を返します。\n//例:(省略)\n
STRLEN_dg=//田楽dllの機能を利用\n//STRLEN/STRLEN2\n//使い方:#n = dllfunc("STRLEN",$s1);\n//説明:文字列の長さを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:文字列の長さを返します。 STRLEN は全角文字を２文字と数えた長さを返しますが、 STRLEN2 は全角文字も１文字と数えた長さを返します。\n//例:\n#len = dllfunc("STRLEN","こんにちは"); // #len == 10\n#len = dllfunc("STRLEN2","こんにちは"); // #len == 5\n
STRLEN2_dg=//田楽dllの機能を利用\n//STRLEN/STRLEN2\n//使い方:#n = dllfunc("STRLEN",$s1);\n//説明:文字列の長さを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:文字列の長さを返します。 STRLEN は全角文字を２文字と数えた長さを返しますが、 STRLEN2 は全角文字も１文字と数えた長さを返します。\n//例:\n#len = dllfunc("STRLEN","こんにちは"); // #len == 10\n#len = dllfunc("STRLEN2","こんにちは"); // #len == 5\n
STRSTR_dg=//田楽dllの機能を利用\n//STRSTR/STRSTR2\n//使い方:#n = dllfunc("STRSTR",$s1,$s2);\n//説明:文字列中の先頭から部分文字列を検索し、 最初に見つかった位置を返します。\n//引数:\n//\t$s1:対象文字列\n//\t$s2:検索文字列\n//返り値:見つかった場合はその位置を返します。 先頭が 0 です。見つからなかった場合は -1 を返します。 STRSTR は全角文字を２文字と数えますが、 STRSTR2 は全角文字も１文字と数えます。\n//例:\n#s = dllfunc("STRSTR","こんばんは","ん"); // #s == 2\n#s = dllfunc("STRSTR2","こんばんは","ん"); // #s == 1\n
STRSTR2_dg=//田楽dllの機能を利用\n//STRSTR/STRSTR2\n//使い方:#n = dllfunc("STRSTR",$s1,$s2);\n//説明:文字列中の先頭から部分文字列を検索し、 最初に見つかった位置を返します。\n//引数:\n//\t$s1:対象文字列\n//\t$s2:検索文字列\n//返り値:見つかった場合はその位置を返します。 先頭が 0 です。見つからなかった場合は -1 を返します。 STRSTR は全角文字を２文字と数えますが、 STRSTR2 は全角文字も１文字と数えます。\n//例:\n#s = dllfunc("STRSTR","こんばんは","ん"); // #s == 2\n#s = dllfunc("STRSTR2","こんばんは","ん"); // #s == 1\n
STRRSTR_dg=//田楽dllの機能を利用\n//STRRSTR/STRRSTR2\n//使い方:#n = dllfunc("STRRSTR",$s1,$s2);\n//説明:文字列中の最後から部分文字列を検索し、 最初に見つかった位置を返します。\n//引数:\n//\t$s1:対象文字列\n//\t$s2:検索文字列\n//返り値:見つかった場合はその位置を返します。 先頭が 0 です。見つからなかった場合は -1 を返します。 STRRSTR は全角文字を２文字と数えますが、 STRRSTR2 は全角文字も１文字と数えます。\n//例:\n#s = dllfunc("STRRSTR","こんばんは","ん"); // #s == 6\n#s = dllfunc("STRRSTR2","こんばんは","ん"); // #s == 3\n
STRRSTR2_dg=//田楽dllの機能を利用\n//STRRSTR/STRRSTR2\n//使い方:#n = dllfunc("STRRSTR",$s1,$s2);\n//説明:文字列中の最後から部分文字列を検索し、 最初に見つかった位置を返します。\n//引数:\n//\t$s1:対象文字列\n//\t$s2:検索文字列\n//返り値:見つかった場合はその位置を返します。 先頭が 0 です。見つからなかった場合は -1 を返します。 STRRSTR は全角文字を２文字と数えますが、 STRRSTR2 は全角文字も１文字と数えます。\n//例:\n#s = dllfunc("STRRSTR","こんばんは","ん"); // #s == 6\n#s = dllfunc("STRRSTR2","こんばんは","ん"); // #s == 3\n
LEFTSTR_dg=//田楽dllの機能を利用\n//LEFTSTR/LEFTSTR2\n//使い方:$s = dllfuncstr("LEFTSTR",$s1,#n2);\n//説明:文字列の左端から指定文字分を抜き出します。\n//引数:\n//\t$s1:対象文字列\n//\t#n2:抜き出す文字数\n//返り値:抜き出した文字列を返します。 $s1 の長さが #n2 より短い場合は $s1 が そのまま返されます。 LEFTSTR は全角文字を２文字と数えますが、 LEFTSTR2 は全角文字も１文字と数えます。\n//例:\n$s = dllfuncstr("LEFTSTR","こんばんは",4); // $s == "こん"\n$s = dllfuncstr("LEFTSTR2","こんばんは",4); // $s == "こんばん"\n
LEFTSTR2_dg=//田楽dllの機能を利用\n//LEFTSTR/LEFTSTR2\n//使い方:$s = dllfuncstr("LEFTSTR",$s1,#n2);\n//説明:文字列の左端から指定文字分を抜き出します。\n//引数:\n//\t$s1:対象文字列\n//\t#n2:抜き出す文字数\n//返り値:抜き出した文字列を返します。 $s1 の長さが #n2 より短い場合は $s1 が そのまま返されます。 LEFTSTR は全角文字を２文字と数えますが、 LEFTSTR2 は全角文字も１文字と数えます。\n//例:\n$s = dllfuncstr("LEFTSTR","こんばんは",4); // $s == "こん"\n$s = dllfuncstr("LEFTSTR2","こんばんは",4); // $s == "こんばん"\n
RIGHTSTR_dg=//田楽dllの機能を利用\n//RIGHTSTR/RIGHTSTR2\n//使い方:$s = dllfuncstr("RIGHTSTR",$s1,#n2);\n//説明:文字列の右端から指定文字分を抜き出します。\n//引数:\n//\t$s1:対象文字列\n//\t#n2:抜き出す文字数\n//返り値:抜き出した文字列を返します。 $s1 の長さが #n2 より短い場合は $s1 が そのまま返されます。 RIGHTSTR は全角文字を２文字と数えますが、 RIGHTSTR2 は全角文字も１文字と数えます。\n//例:\n$s = dllfuncstr("RIGHTSTR","こんばんは",4); // $s == "んは"\n$s = dllfuncstr("RIGHTSTR2","こんばんは",4); // $s == "んばんは"\n
RIGHTSTR2_dg=//田楽dllの機能を利用\n//RIGHTSTR/RIGHTSTR2\n//使い方:$s = dllfuncstr("RIGHTSTR",$s1,#n2);\n//説明:文字列の右端から指定文字分を抜き出します。\n//引数:\n//\t$s1:対象文字列\n//\t#n2:抜き出す文字数\n//返り値:抜き出した文字列を返します。 $s1 の長さが #n2 より短い場合は $s1 が そのまま返されます。 RIGHTSTR は全角文字を２文字と数えますが、 RIGHTSTR2 は全角文字も１文字と数えます。\n//例:\n$s = dllfuncstr("RIGHTSTR","こんばんは",4); // $s == "んは"\n$s = dllfuncstr("RIGHTSTR2","こんばんは",4); // $s == "んばんは"\n
MIDSTR_dg=//田楽dllの機能を利用\n//MIDSTR/MIDSTR2\n//使い方:$s = dllfuncstr("MIDSTR",$s1,#n2,#n3);\n//説明:文字列の途中から指定文字数分の文字列を抜き出します。\n//引数:\n//\t$s1:対象文字列\n//\t#n2:抜き出す文字列の先頭の位置\n//\t#n3:抜き出す文字数\n//返り値:抜き出された文字列を返します。 #n2 が 0 の時は dllfuncstr("\n//LEFTSTR",$s1,#n3) と同じ結果になります。 MIDSTR は全角文字を２文字と数えますが、 MIDSTR2 は全角文字も１文字と数えます。\n//例:\n$s = dllfuncstr("MIDSTR","こんにちは",2,2); // $s == "ん"\n$s = dllfuncstr("MIDSTR2","こんにちは",2,2); // $s == "にち"\n
MIDSTR2_dg=//田楽dllの機能を利用\n//MIDSTR/MIDSTR2\n//使い方:$s = dllfuncstr("MIDSTR",$s1,#n2,#n3);\n//説明:文字列の途中から指定文字数分の文字列を抜き出します。\n//引数:\n//\t$s1:対象文字列\n//\t#n2:抜き出す文字列の先頭の位置\n//\t#n3:抜き出す文字数\n//返り値:抜き出された文字列を返します。 #n2 が 0 の時は dllfuncstr("\n//LEFTSTR",$s1,#n3) と同じ結果になります。 MIDSTR は全角文字を２文字と数えますが、 MIDSTR2 は全角文字も１文字と数えます。\n//例:\n$s = dllfuncstr("MIDSTR","こんにちは",2,2); // $s == "ん"\n$s = dllfuncstr("MIDSTR2","こんにちは",2,2); // $s == "にち"\n
TOLOWER_dg=//田楽dllの機能を利用\n//TOLOWER/TOLOWER2\n//使い方:$s = dllfuncstr("TOLOWER",$s1);\n//説明:指定文字列中のアルファベットの大文字を 全て小文字に変換したものを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。 TOLOWER は半角アルファベットのみを変換しますが、 TOLOWER2 は全角アルファベットも変換します。\n//例:\n$s = dllfuncstr("TOLOWER","ABCＤＥＦ"); // $s == "abcＤＥＦ"\n$s = dllfuncstr("TOLOWER2","ABCＤＥＦ"); // $s == "abcｄｅｆ"\n
TOLOWER2_dg=//田楽dllの機能を利用\n//TOLOWER/TOLOWER2\n//使い方:$s = dllfuncstr("TOLOWER",$s1);\n//説明:指定文字列中のアルファベットの大文字を 全て小文字に変換したものを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。 TOLOWER は半角アルファベットのみを変換しますが、 TOLOWER2 は全角アルファベットも変換します。\n//例:\n$s = dllfuncstr("TOLOWER","ABCＤＥＦ"); // $s == "abcＤＥＦ"\n$s = dllfuncstr("TOLOWER2","ABCＤＥＦ"); // $s == "abcｄｅｆ"\n
TOUPPER_dg=//田楽dllの機能を利用\n//TOUPPER/TOUPPER2\n//使い方:$s = dllfuncstr("TOUPPER",$s1);\n//説明:指定文字列中のアルファベットの小文字を 全て大文字に変換したものを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。 TOUPPER は半角アルファベットのみを変換しますが、 TOUPPER2 は全角アルファベットも変換します。\n//例:\n$s = dllfuncstr("TOUPPER","abcｄｅｆ"); // $s == "ABCｄｅｆ"\n$s = dllfuncstr("TOUPPER2","abcｄｅｆ"); // $s == "ABCＤＥＦ"\n
TOUPPER2_dg=//田楽dllの機能を利用\n//TOUPPER/TOUPPER2\n//使い方:$s = dllfuncstr("TOUPPER",$s1);\n//説明:指定文字列中のアルファベットの小文字を 全て大文字に変換したものを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。 TOUPPER は半角アルファベットのみを変換しますが、 TOUPPER2 は全角アルファベットも変換します。\n//例:\n$s = dllfuncstr("TOUPPER","abcｄｅｆ"); // $s == "ABCｄｅｆ"\n$s = dllfuncstr("TOUPPER2","abcｄｅｆ"); // $s == "ABCＤＥＦ"\n
REVERSE_dg=//田楽dllの機能を利用\n//REVERSE/REVERSE2\n//使い方:$s = dllfuncstr("REVERSE",$s1);\n//説明:指定文字列の文字の並びを反転したものを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。 REVERSE は２バイト文字を意識せずに反転しますが、 REVERSE2 は２バイト文字を意識して反転します。\n//例:\n$s = dllfuncstr("REVERSE","abcde");  // $s == "edcba"\n// "ＡＢ" == "\\x82\\x60\\x82\\x61"\n$s = dllfuncstr("REVERSE","ＡＢ"); // $s == "x61x82x60x82"\n$s = dllfuncstr("REVERSE2","ＡＢ"); // $s == "ＢＡ"\n
REVERSE2_dg=//田楽dllの機能を利用\n//REVERSE/REVERSE2\n//使い方:$s = dllfuncstr("REVERSE",$s1);\n//説明:指定文字列の文字の並びを反転したものを返します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。 REVERSE は２バイト文字を意識せずに反転しますが、 REVERSE2 は２バイト文字を意識して反転します。\n//例:\n$s = dllfuncstr("REVERSE","abcde");  // $s == "edcba"\n// "ＡＢ" == "\\x82\\x60\\x82\\x61"\n$s = dllfuncstr("REVERSE","ＡＢ"); // $s == "x61x82x60x82"\n$s = dllfuncstr("REVERSE2","ＡＢ"); // $s == "ＢＡ"\n
TOHANKAKU_dg=//田楽dllの機能を利用\n//田楽DLLVer2.6x〜にて対応\n//TOHANKAKU\n//使い方:$s = dllfuncstr("TOHANKAKU",$s1);\n//説明:全角文字を半角に変換します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。\n//例:\n$s = dllfuncstr("TOHANKAKU","Ａあ％"); // $s == "Aア%"\n
TOZENKAKUHIRA_dg=//田楽dllの機能を利用\n//田楽DLLVer2.6x〜にて対応\n//TOZENKAKUHIRA\n//使い方:$s = dllfuncstr("TOZENKAKUHIRA",$s1);\n//説明:半角文字を全角ひらがなに変換します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。\n//例:\n$s = dllfuncstr("TOZENKAKUHIRA","Aア%"); // $s == "Ａあ％"\n
TOZENKAKUKATA_dg=//田楽dllの機能を利用\n//田楽DLLVer2.6x〜にて対応\n//TOZENKAKUKATA\n//使い方:$s = dllfuncstr("TOZENKAKUKATA",$s1);\n//説明:半角文字を全角カタカナに変換します。\n//引数:\n//\t$s1:対象文字列\n//返り値:変換された文字列が返ります。\n//例:\n$s = dllfuncstr("TOZENKAKUHIRA","Aア%"); // $s == "Ａア％"\n
GETVERSION_dg=//田楽dllの機能を利用\n//GETVERSION\n//使い方:$s = dllfuncstr("GETVERSION");\n//説明:DengakuDLL.dll のバージョンを表\す文字列を返します。\n//引数:\n//\t(なし)\n//返り値:"X.YY" または "X.YYβ"\n//(X はメジャーバージョン、YY はマイナーバージョン)\n//例:\nif (leftstr(dllfuncstr("GETVERSION"),1) == "0") {\n\t// 0.0X の場合\n} else {\n\t// それ以上の場合\n}\n
GETOSINFO_dg=//田楽dllの機能を利用\n//GETOSINFO\n//使い方:$s = dllfuncstr("GETOSINFO",$s1);\n//説明:OS の情報を表\す文字列を返します。\n//引数:\n//\t$s1:1. 取得したい情報を表\す文字列:* ＯＳの種類 ("type")\n//\t\t\t\tWindows NT または Windows 2000 の場合は "NT"、 Windows 95 または Windows 98 の場合は "9X" という文字列になります。\n//\t\t\t  * メジャーバージョン番号 ("major")\n//\t\t\t\tWindows NT3.51 の場合は "3"、Windows NT4.0 の場合は "4"、 Windo\n//\tws 2000 の場合は "5"、 Windows 95/98 の場合は "4" という文字列になります。\n//\t\t\t  * マイナーバージョン番号 ("minor")\n//\t\t\t\tWindows NT3.51 の場合は "51"、Windows NT4.0/2000 の場合は "0"、\n//\t Windows 95 の場合は "0"、Windows 98 の場合は "10" という 文字列になります。Windows 98SE(Second Edition)の場合は… 誰か教えて下さい(^^;。\n//\t\t\t  * ビルド番号 ("build")\n//\t\t\t\tビルド番号を返します。まぁ、あまり役には立ちませんが…(^^;。\n//\t\t\t  * その他の情報 ("extra")\n//\t\t\t\tＯＳ固有の情報を返します。Windows NT の場合は "Service Pack X" \n//\t(X には番号が入る)という文字列が、Windows 95 OSR2 の場合は " B" という文字列が返ってきます。\n//\t   2. "/f" に続けて書式指定を渡すと、 その書式に従った文字列を返します。 書式指定は普通の文字と "%" に続けて特定の文字が続いたものから 構\成されます。 これらは以下の物を使用できます。\n//\t\t  "%t"\tＯＳの種類\n//\t\t  "%M"\tメジャーバージョン番号\n//\t\t  "%m"\tマイナーバージョン番号\n//\t\t  "%b"\tビルド番号\n//\t\t  "%e"\tその他の情報\n//\t   3. $s1 に "" を指定した場合は 各情報をカンマで区切ったものが返されます。\n//返り値:$s1 の指定に従った文字列を返します。\n//例:\nif (dllfuncstr("GETOSINFO","type") == "NT") {\n\t// NT の場合\n\tmessage dllfuncstr("GETOSINFO","/f 'Windows NT%M.%m(build:%b) %e'");\n\t//\t例： "Windows NT4.0(build:1381) Service Pack 5"\n} else {\n\t// 95/98 の場合\n\tmessage dllfuncstr("GETOSINFO","/f 'Windows %t (version:%M.%m%e)'");\n\t//\t例： "Windows 95 (version:4.0B)"\n}\n
GETCARETPOS_dg=//田楽dllの機能を利用\n//田楽DLLVer2.7x〜にて対応\n//GETCARETPOS\n//使い方:$s = dllfuncstr("GETCARETPOS");\n//説明:現在のキャレット（キーボード入力）の位置を返します。\n//引数:\n//\t(なし)\n//返り値:現在のキャレット（キーボード入力）の（右下端の）スクリーン座標を 「x,y」という書式で返します（単位はピクセル）。 キャレットが見つからなかった場合は空文字列を返します。\n//例:\n$pos = dllfuncstr("GETCARETPOS"); // "x,y" という書式で返る\n// カーソ\ルの直下にダイアログを表\示\n#_ = dllfunc("NEWDIALOG", "test", 32, $pos + " screen '' '' px");\n
GETCURSORPOS_dg=//田楽dllの機能を利用\n//田楽DLLVer2.7x〜にて対応\n//GETCURSORPOS\n//使い方:$s = dllfuncstr("GETCURSORPOS");\n//説明:現在のマウスカーソ\ルの位置を返します。\n//引数:\n//\t(なし)\n//返り値:現在のマウスカーソ\ルのスクリーン座標を 「x,y」という書式で返します（単位はピクセル）。\n//例:\n// マウスカーソ\ルの座標をモニタするサンプル\nwhile (1) {\n\tinsert dllfuncstr("GETCURSORPOS") + "\\n";\n\t#n = dllfunc("SLEEP", 1000); // 1秒待つ\n}\n
SLEEP_dg=//SLEEP_dg\n//田楽dllの機能を利用\n//田楽DLLVer2.7x〜にて対応\n//SLEEP\n//使い方:#n = dllfunc("SLEEP", #n1);\n//説明:指定した時間だけスリープします。\n//引数:\n//\t#n1:スリープしたい時間をミリ秒単位で指定します。 内部的に符号なし整数と解釈されるので、2Mミリ秒以上を 指定したいときは（符号なし整数を符号あり整数と解釈した） 対応する負の値を指定してください。 なお、-1 を指定すると永遠に関数から返ってこなくなるので 注意してください。\n//返り値:常に1を返します。\n//例:(GETCURSORPOSの例を参照してください。)\n
MSGBOX_dg=//田楽dllの機能を利用\n//田楽DLLVer2.8x〜にて対応\n//MSGBOX\n//使い方:$s = dllfuncstr("MSGBOX", $s1, $s2, $s3);\n//説明:メッセージボックスを表\示します。 オプション引数によりボタンの種類やアイコン、 タイムアウト時間を指定できます。\n//引数:\n//\t$s1:メッセージ文字列\n//\t$s2:オプション文字列(複数指定可)\n//\t/b type:ボタンの組み合わせを指定します。 typeには以下の６種類から \n//\t１つを指定できます。\n//\t\t* ok\n//\t\t  [OK]ボタンのみを表\示します(デフォルト)。\n//\t\t* okcancel\n//\t\t  [OK]ボタンと[キャンセル]ボタンを表\示します。\n//\t\t* abortretryignore\n//\t\t  [中止][再試行][無視]ボタンを表\示します。\n//\t\t* yesnocancel\n//\t\t  [はい][いいえ][キャンセル]ボタンを表\示します。\n//\t\t* yesno\n//\t\t  [はい][いいえ]ボタンを表\示します。\n//\t\t* retrycancel\n//\t\t  [再試行][キャンセル]ボタンを表\示します。\n//\t/i type:メッセージの横に表\示するアイコンの種類を指定します。 typeには以下の５種類から １つを指定できます。\n//\t\t* none\n//\t\t  アイコンを表\示しません(デフォルト)。\n//\t\t* critical\n//\t\t  警告メッセージアイコンを表\示します。\n//\t\t* question\n//\t\t  問い合わせメッセージアイコンを表\示します。\n//\t\t* exclamation\n//\t\t  注意メッセージアイコンを表\示します。\n//\t\t* information\n//\t\t  情報メッセージアイコンを表\示します。\n//\t/d type:デフォルトボタンを指定します。 typeには以下の７種類から １\n//\tつを指定できます。 オプション指定がないか、/b で指定したボタンの 組み合わせに存在しないボタンを指定した場合は 左端のボタンがデフォルトボタンになります。\n//\t\t* ok\n//\t\t  [OK]ボタンをデフォルトボタンにします。\n//\t\t* yes\n//\t\t  [はい]ボタンをデフォルトボタンにします。\n//\t\t* no\n//\t\t  [いいえ]ボタンをデフォルトボタンにします。\n//\t\t* cancel\n//\t\t  [キャンセル]ボタンをデフォルトボタンにします。\n//\t\t* abort\n//\t\t  [中止]ボタンをデフォルトボタンにします。\n//\t\t* retry\n//\t\t  [再試行]ボタンをデフォルトボタンにします。\n//\t\t* ignore\n//\t\t  [無視]ボタンをデフォルトボタンにします。\n//\t/t time:メッセージボックスを自動的に閉じるまでのタイムアウト 時間を秒単位で指定します。 このオプションを省略するか、 0または負の値を指定するとタイムアウトしません。\n//\t$s3:メッセージボックスのタイトルバーに表\示する文字列\n//返り値:押されたボタンに対応する文字列（/d オプションのボタン指定と同じ）。 タイムアウトでメッセージボックスが閉じられた場合は""を返します。\n//例:\n// [はい][いいえ][キャンセル]ボタンと「？」アイコンを表\示\n// [いいえ]ボタンがデフォルトボタン\n// 10秒で自動的にメッセージボックスが閉じる\n$s = dllfuncstr("MSGBOX",\n\t\t\t\t"どれかボタンを押すか10秒待ってください",\n\t\t\t\t"/b yesnocancel /i question /d no /t 10",\n\t\t\t\t"MSGBOXのテスト");\nif ($s == "yes") {\n\t// [はい] ボタンが押された\n} else if ($s == "no") {\n\t// [いいえ] ボタンが押された\n} else if ($s == "cancel") {\n\t// [キャンセル] ボタンが押された\n} else if ($s == "") {\n\t// タイムアウトした\n}\n
NEWMENU_dg=//田楽dllの機能を利用\n//NEWMENU\n//使い方:#n = dllfunc("NEWMENU",$s1);\n//説明:MENU 関数 で表示するための ポップアップメニューの作成を開始します。 この関数は単に新しいメニュー(の識別名)を定義するだけです。 実際にメニューの項目を追加するには ADDMENUITEM 関数 を使用します。\n//引数:\n//\t$s1:メニューの識別名\n//返り値:関数が成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\nif (dllfunc("NEWMENU","main") == 0\t||\n\tdllfunc("ADDMENUITEM","","項目１","") == 0\t||\n\tdllfunc("ADDMENUITEM","","","") == 0\t||\n\tdllfunc("ADDMENUITEM","","サブメニュー","sub") == 0) {\n\tmessage "メインメニューの作成に失敗!!";\n\t//...\n}\nif (dllfunc("NEWMENU","sub") == 0\t||\n\tdllfunc("ADDMENUITEM","","サブ項目１","") == 0\t||\n\tdllfunc("ADDMENUITEM","","サブ項目２","") == 0) {\n\tmessage "サブメニューの作成に失敗!!";\n\t//...\n}\n$select_item = dllfuncstr("MENU","main",hidemaruhandle(0));\nif ($select_item == "!") {\n\t//\tエラー！！\n} else if ($select_item == "0") {\n\t//\tキャンセル\n} else if (leftstr($select_item,4) == "main") {\n\t//\tメインメニュー("main")の項目が選択された\n\t#index = val(midstr($select_item,5,1)); //\t項目のインデックス\n\t//...\n} else {\n\t//\tサブメニュー("sub")の項目が選択された\n\t#index = val(midstr($select_item,4,1)); //\t項目のインデックス\n\t//...\n}\n
ADDMENUITEM_dg=//田楽dllの機能を利用\n//ADDMENUITEM\n//使い方:#n = dllfunc("ADDMENUITEM",$s1,$s2,$s3);\n//説明:NEWMENU 関数 で作成したメニューに 項目を追加します。\n//(ADDMENUITEMEX 関数 の 第４引数に "" を指定した場合と同じです。)\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t（"" を指定すると、最新の NEWMENU 関数で作成したメニュー を指定したと解釈されます）\n//\t$s2:メニュー項目の文字列\n//\t（"" を指定するとセパレータと解釈されます）\n//\t$s3:この項目がサブメニューを持つ時はそのサブメニューの識別名\n//\tサブメニューがない時は ""\n//返り値:関数が成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(NEWMENU 関数 の例を参照して下さい)\n
ADDMENUITEMEX_dg=//田楽dllの機能を利用\n//田楽DLLVer1.1x〜にて対応\n//ADDMENUITEMEX\n//使い方:#n = dllfunc("ADDMENUITEMEX",$s1,$s2,$s3,$s4);\n//説明:NEWMENU 関数 で作成したメニューに 項目を追加します。 チェック\n//の有無や有効・無効の状態を指定できます。\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t（"" を指定すると、最新の NEWMENU 関数で作成したメニュー を指定したと解釈されます）\n//\t$s2:メニュー項目の文字列\n//\t（"" を指定するとセパレータと解釈されます）\n//\t$s3:この項目がサブメニューを持つ時はそのサブメニューの識別名\n//\tサブメニューがない時は ""\n//\t$s4:項目の状態\n//\t"c" を指定すると項目の前にチェックがつきます。\n//\tまた "d" を指定すると項目が無効状態(グレー表\示)になり、 選択できなくなります。\n//\t"cd" のように両方を同時に指定することもできます。\n//返り値:関数が成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\n#n = dllfunc("ADDMENUITEMEX","","チェックをつける","","c");\n#n = dllfunc("ADDMENUITEMEX","","無効にする","","d");\n#n = dllfunc("ADDMENUITEMEX","","両方の指定","","cd");\n
CHANGEMENUITEM_dg=//田楽dllの機能を利用\n//CHANGEMENUITEM\n//使い方:#n = dllfunc("CHANGEMENUITEM",$s1,#n2,$s3);\n//説明:メニュー項目のテキストを変更します。 なお、項目の種類（普通の項目か、セパレータか、サブメニューの有無）は 変更できません。\n//(CHANGEMENUITEMEX 関数 の 第４引数に "" を指定した場合と同じです。\n//)\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t（"" を指定すると、最新の NEWMENU 関数で作成したメニュー を指定したと解釈されます）\n//\t#n2:変更する項目の番号\n//\t（番号は セパレータも含めて 1 から数えます）\n//\t$s3:新しい項目テキスト\n//返り値:関数が成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\nif (!dllfunc("NEWMENU","test")\t||\n\t!dllfunc("ADDMENUITEM","","1 回目の表示","")) {\n\tmessage "メニューの作成に失敗しました";\n\t//...\n}\n#n = 1;\nwhile (1) {\n\t$sel = dllfuncstr("MENU","test",hidemaruhandle(0));\n\tif ($sel == "!" || $sel == "") break;\n\t#n = #n + 1;\n\tif (!dllfunc("CHANGEMENUITEM","test",1,str(#n)+" 回目の表示")) break;\n}\n//...\n
CHANGEMENUITEMEX_dg=//田楽dllの機能を利用\n//田楽DLLVer1.1x〜にて対応\n//CHANGEMENUITEMEX\n//使い方:#n = dllfunc("CHANGEMENUITEMEX",$s1,#n2,$s3,$4);\n//説明:メニュー項目のテキスト及び属性を変更します。 なお、項目の種類（普通の項目か、セパレータか、サブメニューの有無）は 変更できません。\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t（"" を指定すると、最新の NEWMENU 関数で作成したメニュー を指定したと解釈されます）\n//\t#n2:変更する項目の番号\n//\t（番号は セパレータも含めて 1 から数えます）\n//\t$s3:新しい項目テキスト\n//\t$s4:新しい項目属性\n//\t(指定方法は ADDMENUITEMEX 関数 と同じです)\n//返り値:関数が成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(省略)\n
DELETEMENUITEM_dg=//田楽dllの機能を利用\n//DELETEMENUITEM\n//使い方:#n = dllfunc("DELETEMENUITEM",$s1,#n2);\n//説明:指定したメニュー項目を削除します。\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t（"" を指定すると、最新の NEWMENU 関数で作成したメニュー を指定したと解釈されます）\n//\t#n2:削除する項目の番号\n//\t（番号は セパレータも含めて 1 から数えます） （0 を指定すると全ての項目を削除します）\n//返り値:関数が成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\n//...\nif (!dllfunc("DELETEMENUITEM","main",0)) {\n\tmessage "メニュー項目のクリアに失敗しました";\n\t//...\n}\n##a = 1;\nwhile (##a > 10) {\n\tif (!dllfunc("ADDMENUITEM","main","新項目"+str(##a),"") break;\n\t##a = ##a + 1;\n}\n//...\n
MENU_dg=//田楽dllの機能を利用\n//MENU\n//使い方:$s = dllfuncstr("MENU",$s1,#n2);\n//説明:NEWMENU 関数、 ADDMENUITEM 関数 等で作成した メニューを表\示して、ユーザーが選択した結果を返します。\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t#n2:マウスカーソ\ルの位置にメニューを表\示する時は 0、\n//\tキャレット（|）の位置にメニューを表\示する時は 秀丸のウィンドウハンドル(= hidemaruhandle(0))\n//\t注意:disabledraw 等によりカーソ\ルが表\示されていない状態で ウィンド\n//\tウハンドルを指定すると、メニューの表\示位置がずれて しまいます。\n//返り値:* エラーの場合は "!"\n//\t* キャンセルの場合は "0"\n//\t* 選択された場合は "menuname:index"\n//\t  menuname は選択項目を含むメニュー（またはサブメニュー）の識別名、 index は項目の番号 （一番上が 1 で、セパレータも含めて順番に 1 づつ増える）\n//例:(NEWMENU 関数 の例を参照して下さい)\n
MENUEX_dg=//田楽dllの機能を利用\n//田楽DLLVer2.6x〜にて対応\n//MENUEX\n//使い方:$s = dllfuncstr("MENUEX",$s1,#n2);\n//説明:NEWMENU 関数、 ADDMENUITEM 関数 等で作成した メニューを指定した位置に表示して、 ユーザーが選択した結果を返します。\n//引数:\n//\t$s1:NEWMENU 関数 の引数で指定した メニューの識別名\n//\t#n2:マウスカーソルの位置にメニューを表示する時は 0、\n//\tキャレット（|）の位置にメニューを表示する時は 秀丸のウィンドウハンドル(= hidemaruhandle(0))\n//\t注意:disabledraw 等によりカーソルが表示されていない状態で ウィンド\n//\tウハンドルを指定すると、メニューの表示位置がずれて しまいます。\n//\t#n3:#2 で指定した位置からの横方向のずれ(ピクセル単位)\n//\t#n4:#2 で指定した位置からの縦方向のずれ(ピクセル単位)\n//返り値:* エラーの場合は "!"\n//\t* キャンセルの場合は "0"\n//\t* 選択された場合は "menuname:index"\n//\t  menuname は選択項目を含むメニュー（またはサブメニュー）の識別名、 index は項目の番号 （一番上が 1 で、セパレータも含めて順番に 1 づつ増える）\n//例:\n// (これ以前に "main" という名前でメニューを作成しておく)\n// カーソル位置から１行分下にメニューを表示\n// (fontsize はフォントの高さを表す秀丸マクロのキーワード)\n$select_item = dllfuncstr("MENUEX","main",hidemaruhandle(0),0,fontsize);\nif ($select_item == "!") {\n\t//\tエラー！！\n} else if ($select_item == "0") {\n\t//\tキャンセル\n} else if (leftstr($select_item,4) == "main") {\n\t//\tメインメニュー("main")の項目が選択された\n\t#index = val(midstr($select_item,5,1)); //\t項目のインデックス\n\t//...\n} else {\n\t//\tサブメニュー("sub")の項目が選択された\n\t#index = val(midstr($select_item,4,1)); //\t項目のインデックス\n\t//...\n}\n
LOADSPI_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//LOADSPI\n//使い方:#n = dllfunc("LOADSPI",$s1);\n//説明:Susie Plug-in をロードします。\n//なお、既にプラグインがロードされている時はこの関数は失敗します。 別のプラグインを使いたい時は、一度 FREESPI 関数 を呼び出した後に 再度 LOADSPI 関数でロードして下さい。\n//ちなみに、プラグインには画像処理用と 圧縮ファイル展開用の２種類がありますが、 この関数では画像処理用の物だけロードすることができます＆ 圧縮ファイル展開用の物をロードしようとしても失敗します。\n//引数:\n//\t$s1:Susie Plug-in のファイル名\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\n//\tSusie プラグインのロード\nif (dllfunc("LOADSPI","c:\\\\Program Files\\\\susie32\\\\ifjpeg.spi") == 0) {\n\tmessage "Susie Plug-in のロードに失敗!!";\n\t//...\n}\n//\tプラグインの情報を取得\nmessage "Plug-in version : " + dllfuncstr("GETSPIINFO",0);\nmessage "Info string : " + dllfuncstr("GETSPIINFO",1);\n##a = 1;\nwhile (1) {\n\t$$type = dllfuncstr("GETSPIINFO",##a*2);\n\tif ($$type == "") break;\n\tmessage "Supported format [" + str(##a) + "]\\n Extension(s) : " + $type +\n\t\t\t"\\n Info string : " + dllfuncstr("GETSPIINFO",##a*2+1);\n\t##a = ##a + 1;\n}\n//\t現在のプラグインが指定した画像に対応しているかどうかを調べる\n$image = "c:\\\\My Documents\\\\image\\\\jpeg\\\\foo.jpg";\nif (dllfunc("ISSUPPORTEDPIC",$image) == 0) {\n\tmessage "このプラグインは JPEG フォーマットに対応していません。";\n\t//...\n}\n//\t画像に関する情報を取得\n$info = dllfuncstr("GETPICINFO",$image);\n##left\t = val(dllfuncstr("GETTOKEN",$info,","));\n##top\t = val(dllfuncstr("GETTOKEN","",","));\n##width  = val(dllfuncstr("GETTOKEN","",","));\n##height = val(dllfuncstr("GETTOKEN","",","));\n//...\n//\tプラグインのアンロード\n##r = dllfunc("FREESPI");\n//...\n
FREESPI_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//FREESPI\n//使い方:#n = dllfunc("FREESPI");\n//説明:LOADSPI 関数 でロードした プラグインをアンロードします。\n//引数:\n//\t(なし)\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(LOADSPI 関数 の例を参照して下さい。)\n
GETSPIINFO_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//GETSPIINFO\n//使い方:$s = dllfuncstr("GETSPIINFO",#n1);\n//説明:LOADSPI 関数 でロードしたプラグインの 情報を取得します。\n//引数:\n//\t#n1:取得したい情報を表\す数値\n//\t(意味は Susie Plug-in API の GetPluginInfo を参照)\n//返り値:取得された情報\n//例:(LOADSPI 関数 の例を参照して下さい。)\n
ISSUPPORTEDPIC_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//ISSUPPORTEDPIC\n//使い方:#n = dllfunc("ISSUPPORTEDPIC",$s1);\n//説明:現在ロードされているプラグインが 指定した画像に対応しているかどうかを調べます。\n//引数:\n//\t$s1:画像ファイルのファイル名\n//返り値:対応している場合は 1 を、そうでなければ 0 を返します。\n//例:(省略)\n
GETPICINFO_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//GETPICINFO\n//使い方:$s = dllfuncstr("GETPICINFO",$s1);\n//説明:画像の情報を取得します。\n//引数:\n//\t$s1:画像ファイルのファイル名\n//返り値:Susie Plug-in API の GetPictureInfo で返される値を カンマで区切ったものを返します。 エラーの場合は "" を返します。\n//例:(LOADSPI 関数 の例を参照して下さい。)\n
APPENDCOPY_dg=//田楽dllの機能を利用\n//APPENDCOPY\n//使い方:#n = dllfunc("APPENDCOPY",$s1,$s2);\n//説明:指定ファイルの最後に別のファイルの内容を連結(追加コピー)します。\n//(テキストファイルの連結には APPENDCOPYTEXT 関数 を使用して下さい)\n//\n//引数:\n//\t$s1:追加・変更されるファイルの名前\n//\t$s2:追加するファイルの名前\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\nif (!dllfunc("APPENDCOPY","foo.dat","bar.dat")) {\n\tmessage "foo.dat に bar.dat の内容を連結できませんでした";\n\t//...\n}\n
APPENDCOPYTEXT_dg=//APPENDCOPYTEXT_dg\n//田楽dllの機能を利用\n//APPENDCOPYTEXT\n//使い方:#n = dllfunc("APPENDCOPYTEXT",$s1,$s2);\n//説明:指定ファイルの最後に別のファイルの内容を連結(追加コピー)します。 追加されるファイルの最後に [EOF](^Z, 0x1A) があった場合は それを削除してから連結します。\n//引数:\n//\t$s1:追加・変更されるファイルの名前\n//\t$s2:追加するファイルの名前\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\nif (!dllfunc("APPENDCOPY","foo.txt","bar.txt")) {\n\tmessage "foo.txt に bar.txt の内容を連結できませんでした";\n\t//...\n}\n
COPY_dg=//田楽dllの機能を利用\n//COPY\n//使い方:#n = dllfunc("COPY",$s1,$s2);\n//説明:ファイルまたはフォルダをコピーします。\n//引数:\n//\t$s1:(オプション文字列＋)コピー元ファイル(フォルダ)名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] file [file...]"\n//\t\t* オプション文字列(options)\n//\t\t  /r:フォルダをその内容ごとコピーします。\n//\t\t  /i:全てのファイル・フォルダについて 上書きの確認をします。 通常は読取専用またはシステムファイルの 上書きのみ確認します。\n//\t\t  /f:確認せずに全て強制的に上書きします。\n//\t\t  /u:コピー先のタイムスタンプがコピー元より 古い場合のみ上書きします。\n//\t\t  /n:戻り値として実際にコピーしたファイルの数を返し、 処理結果を \n//\tFILEOPRESULT() で 取得できるようになります。\n//\t\t  /N:上書きの確認を求めるダイアログに対して 自動で「いいえ」と答えたとして処理を進めます。 （上書きを一切したくない場合は /i オプションと 併用して下さい）\n//\t\t* ファイルまたはフォルダ名(file)\n//\t\t  ファイル名またはフォルダ名を複数指定できます。 ワイルドカードも使用できます。 ただしフォルダを指定する場合は "/r" オプションを指定して下さい。\n//\t$s2:コピー先ファイル(フォルダ)名\n//\t\t* もし $s2 が存在しないか、または既存のファイル名の場合は $s1 の内容を $s2 を別名としてコピーします。\n//\t\t* もし $s2 が既存のフォルダ名の場合は $s1 を $s2 の中に 同名でコピーします。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//(/n を指定した場合を除く)\n//例:\n//\t別名コピー\nif (!dllfunc("COPY","index.html","index.orig")) {\n\tmessage "ファイルのコピーに失敗しました";\n\t//...\n}\n//\t別フォルダへファイルをコピー\nif (!dllfunc("COPY","*.html *.txt","A:\\\\")) {\n\tmessage "ファイルのコピーに失敗しました";\n\t//...\n}\n//\t別フォルダへフォルダ・ファイルをコピー\nif (!dllfunc("COPY",\n\t\t\t"/ru 'C:\\\\Program Files\\\\*.*'",\n\t\t\t"G:\\\\Backup\\\\Program Files"\n\t\t)\n\t) {\n\tmessage "プログラムフォルダのバックアップに失敗しました";\n\t//...\n}\n
MOVE_dg=//田楽dllの機能を利用\n//MOVE\n//使い方:#n = dllfunc("MOVE",$s1,$s2);\n//説明:ファイルまたはフォルダを移動(または名前を変更)します。\n//引数:\n//\t$s1:(オプション文字列＋)移動元ファイル(フォルダ)名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] file [file...]"\n//\t\t* オプション文字列(options)\n//\t\t  /i:全てのファイル・フォルダについて 上書きの確認をします。 通常は読取専用またはシステムファイルの 上書きのみ確認します。\n//\t\t  /f:確認せずに全て強制的に上書きします。\n//\t\t  /u:コピー先のタイムスタンプがコピー元より 古い場合のみ上書きします。\n//\t\t  /n:戻り値として実際に移動したファイルの数を返し、 処理結果を FI\n//\tLEOPRESULT() で 取得できるようになります。\n//\t\t  /N:上書きの確認を求めるダイアログに対して 自動で「いいえ」と答えたとして処理を進めます。 （上書きを一切したくない場合は /i オプションと 併用して下さい）\n//\t\t* ファイルまたはフォルダ名(file)\n//\t\t  ファイル名またはフォルダ名を複数指定できます。 ワイルドカードも使用できます。\n//\t$s2:移動先ファイル(フォルダ)名\n//\t\t* $s2 が存在しない場合は $s1 を $s2 に名前を変えて 移動します。\n//\t\t* $s2 が既存のファイル名の場合は $s1 を $s2 に 上書き移動します。\n//\t\n//\t\t* もし $s2 が既存のフォルダ名の場合は $s1 を $s2 の中に 同名で移動します。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//(/n を指定した場合を除く)\n//例:\n//\t名前の変更\nif (!dllfunc("MOVE","index.html","index.orig")) {\n\tmessage "ファイルの名前の変更に失敗しました";\n\t//...\n}\n//\t別フォルダへファイル・フォルダを移動\nif (!dllfunc("MOVE","*.*","A:\\\\")) {\n\tmessage "ファイルの移動に失敗しました";\n\t//...\n}\n
REMOVE_dg=//田楽dllの機能を利用\n//REMOVE\n//使い方:#n = dllfunc("REMOVE",$s1);\n//説明:ファイルまたはフォルダを削除します。\n//引数:\n//\t$s1:(オプション文字列＋)削除するファイル(フォルダ)名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] file [file...]"\n//\t\t* オプション文字列(options)\n//\t\t  /r:フォルダをその内容ごと削除します。\n//\t\t  /i:全てのファイル・フォルダについて 削除の確認をします。 通常は読取専用またはシステムファイルの 削除のみ確認します。\n//\t\t  /f:確認せずに全て強制的に削除します。\n//\t\t  /g:ファイルを実際に削除する代わりに ごみ箱へ移動します。\n//\t\t  /n:戻り値として実際に削除したファイルの数を返し、 処理結果を FI\n//\tLEOPRESULT() で 取得できるようになります。\n//\t\t  /N:削除の確認を求めるダイアログに対して 自動で「いいえ」と答えたとして処理を進めます。\n//\t\t* ファイルまたはフォルダ名(file)\n//\t\t  ファイル名またはフォルダ名を複数指定できます。 ワイルドカードも使用できます。 ただしフォルダを指定する場合は "/r" オプションを指定して下さい。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//(/n を指定した場合を除く)\n//例:\nif (!dllfunc("REMOVE","/f *.bak")) {\n\tmessage "バックアップファイルの削除に失敗しました";\n\t//...\n}\n
SETATTRIBUTE_dg=//田楽dllの機能を利用\n//SETATTRIBUTE\n//使い方:#n = dllfunc("SETATTRIBUTE", $s1);\n//説明:指定されたファイル・フォルダの属性を変更します。\n//引数:\n//\t$s1:(オプション文字列＋)属性指定子＋変更するファイル(フォルダ\n//\t)名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] modes file [file...]"\n//\t\t* オプション文字列(options)\n//\t\t  /R:サブフォルダ内の全てのファイル・フォルダの 属性を変更します。\n//\t\t  /n:戻り値として実際に属性を変更した数を返し、 処理結果を FILEOP\n//\tRESULT() で 取得できるようになります。\n//\t\t* 属性指定子(modes)\n//\t\t  書式は以下の通りです。\n//\t\t  "(+|-|=)flags[(+|-|=)flags...]"\n//\t\t  + \t現在の属性に flags の属性を加えます。\n//\t\t  - \t現在の属性から flags の属性を除きます。\n//\t\t  = \t現在の属性を flags の属性に置き換えます。\n//\t\t  flags \t以下の属性を複数指定できます。\n//\t\t  a アーカイブ属性\n//\t\t  r 読取専用属性\n//\t\t  h 隠し属性\n//\t\t  s システム属性\n//\t\t* ファイル・フォルダ名(file)\n//\t\t  ファイル・フォルダ名を複数指定できます。 ワイルドカードも指定できます。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n//\t読取専用・隠し・システムファイルに変更\n#r = dllfunc("SETATTRIBUTE","=rhs C:\\\\boot.ini");\n//\t現在の属性に読取専用属性を加え、アーカイブ属性と隠し属性を除く\n#r = dllfunc("SETATTRIBUTE","/R +r-ah *.*");\n
TOUCH_dg=//田楽dllの機能を利用\n//TOUCH\n//使い方:#n = dllfunc("TOUCH", $s1);\n//説明:指定されたファイルのタイムスタンプを(現在の時刻に)変更します。\n//引数:\n//\t$s1:(オプション文字列＋)変更するファイル(フォルダ)名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] file [file...]"\n//\t\t* オプション文字列(options)\n//\t\t  /a:最終アクセス日付・時刻のみを変更します。\n//\t\t  /c:存在するファイルのみ変更します。(下記参照)\n//\t\t  /m:最終更新日付・時刻のみを変更します。\n//\t\t  /R:フォルダが指定された場合に、 その下にあるファイル・サブフォルダも更新します。\n//\t\t  /r reffile:現在の日付・時刻の代わりに reffile のタイムスタンプを使用します。\n//\t\t  /t timestamp:現在の日付・時刻の代わりに指定した日付・時刻を 使用します。 指定(timestamp)は "[YY]YY/MM/DD#hh:mm:ss" の形式で指定します。 (西暦が２桁の場合は 1900 年からの経過年として 処理します。)\n//\t\t  /n:戻り値として実際にタイムスタンプを変更した ファイル・フォルダの数を返し、 処理結果を FILEOPRESULT() で 取得できるようになります。\n//\t\t* ファイル・フォルダ名(file)\n//\t\t  ファイル・フォルダ名を複数指定できます。 ワイルドカードも指定できます。 指定されたファイルがなければ サイズ 0 のファイルを作成します ("/c" オプションを指定しない場合)。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n//\t現在時刻のサイズ０のファイルを作成\n#r = dllfunc("TOUCH","newfile.txt");\n//\t既存ファイルのタイムスタンプを foo.txt に揃える\n#r = dllfunc("TOUCH","/r foo.txt *.*");\n//\tフォルダ内のファイル・フォルダを指定日付・時刻に変更する\n#r = dllfunc("TOUCH","/R /t 2000/01/01#00:00:00 dir1");\n
FILEOPRESULT_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//FILEOPRESULT\n//使い方:$s = dllfuncstr("FILEOPRESULT");\n//説明:"/n" オプションを受け付けるファイル操作系関数 (COPY, MOVE, RE\n//MOVE, MKDIR, RMDIR, SETATTRIBUTE, TOUCH) の処理結果を受け取ります。\n//引数:\n//\t(なし)\n//返り値:１回の呼出し毎に直前のファイル操作系関数の処理結果が１つ返ります。 結果が存在しない時は "" を返します。\n//ここで、処理結果の書式は以下の通りです。\n//\t  "result|filename[|filename2]"\n//\t* 処理の結果コード(result)\n//\t  0:成功\n//\t  1:失敗\n//\t  2:("/i" オプション指定時のみ)ユーザーが「いいえ」または「キャンセル」を選択\n//\t* 処理対象のファイル・フォルダ名(filename)\n//\t  ※実際に存在する場合はフルパス名、 そうでなければ引数で指定した名前になります。\n//\t* (COPY, MOVE のみ)コピー・移動先の ファイル・フォルダ名(filename\n//2)\n//\t  ※実際に存在する場合はフルパス名、 そうでなければ引数で指定した名前になります。\n//例:\n// ユーザーに上書き確認をしつつ、ファイル・フォルダをコピー\n#r = dllfunc("COPY", "/rin 'C:\\\\My Documents\\\\*.*'", "D:\\\\backup");\nwhile (1) {\n\t$res = dllfuncstr("FILEOPRESULT");\n\tif ($res == "") break;\n\t// GETTOKEN() により結果文字列を分割\n\t$retcode = dllfuncstr("GETTOKEN", $res, "|"); // 結果コードの取得\n\t$srcfile = dllfuncstr("GETTOKEN", "", "|");   // コピー元ファイル名\n\t$dstfile = dllfuncstr("GETTOKEN", "", "|");   // コピー先ファイル名\n\tif ($retcode == "0") {\n\t\t// 処理に成功\n\t\tinsert $srcfile + " -> " + $dstfile + " : OK\\n";\n\t} else if ($retcode == "1") {\n\t\t// 処理に失敗\n\t\tinsert $srcfile + " -> " + $dstfile + " : NG\\n";\n\t} else if ($retcode == "2") {\n\t\t// ユーザーによりキャンセル\n\t\tinsert $srcfile + " -> " + $dstfile + " : キャンセル\\n";\n\t}\n}\n//...\n
GETCURDIR_dg=//田楽dllの機能を利用\n//GETCURDIR\n//使い方:$s = dllfuncstr("GETCURDIR");\n//説明:カレントフォルダ名を取得します。\n//引数:\n//\t(なし)\n//返り値:カレントフォルダ名が返ります。 なお、ルートフォルダの場合は最後が円記号で終了します(例:"A:\\")。 それ以外は最後に円記号はつきません。\n//例:(省略)\n
SETCURDIR_dg=//田楽dllの機能を利用\n//SETCURDIR\n//使い方:#n = dllfunc("SETCURDIR",$s1);\n//説明:カレントフォルダを移動します。\n//引数:\n//\t$s1:フォルダ名 (UNC パスは指定できません)\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n#r = dllfunc("SETCURDIR","C:\\\\Windows");\nif (!dllfunc("COPY","win.ini","win.bak")) {\n\tmessage "win.ini のバックアップコピーに失敗しました";\n\t//...\n}\n
MKDIR_dg=//田楽dllの機能を利用\n//MKDIR\n//使い方:#n = dllfunc("MKDIR",$s1);\n//説明:指定されたフォルダを作成します。\n//引数:\n//\t$s1:(オプション文字列＋)作成するフォルダ名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] dir [dir...]"\n//\t\t* オプション文字列(options)\n//\t\t  /p:(もし存在しなければ) 指定された全てのサブフォルダを作成します。 このオプションを付けない場合、 "C:\\\\dir1\\\\dir2" という指定で dir1 が存在しない場合は関数が失敗します。\n//\t\t  /n:戻り値として実際に作成したフォルダの数を返し、 処理結果を FI\n//\tLEOPRESULT() で 取得できるようになります。\n//\t\t* フォルダ名(dir)\n//\t\t  フォルダ名を複数指定できます。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//("/n" オプションを指定した場合を除く)\n//例:\nif (!dllfunc("MKDIR","/p .\\\\newdir\\\\subdir")) {\n\tmessage "フォルダの作成に失敗しました";\n\t//...\n}\n
RMDIR_dg=//田楽dllの機能を利用\n//RMDIR\n//使い方:#n = dllfunc("RMDIR",$s1);\n//説明:指定された(空の)フォルダを削除します。\n//引数:\n//\t$s1:(オプション文字列＋)削除するフォルダ名 (複数指定可)\n//\t書式は以下の通りです。\n//\t\t  "[options] dir [dir...]"\n//\t\t* オプション文字列(options)\n//\t\t  /i:全てのフォルダについて削除の確認をします。 通常は読取専用またはシステムフォルダの削除のみ 確認します。\n//\t\t  /f:確認せずにすべて強制的に削除します。\n//\t\t  /n:戻り値として実際に削除したフォルダの数を返し、 処理結果を FI\n//\tLEOPRESULT() で 取得できるようになります。\n//\t\t  /N:削除の確認を求めるダイアログに対して 自動で「いいえ」と答えたとして処理を進めます。\n//\t\t* フォルダ名(dir)\n//\t\t  フォルダ名を複数指定できます。 なお、フォルダの中にファイルまたはサブフォルダがある 場合この関数は失敗します。 (REMOVE 関数 も参照して下さい)\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//("/n" オプションを指定した場合を除く)\n//例:\nif (!dllfunc("RMDIR","/f *.*")) {\n\tmessage "フォルダの削除に失敗しました";\n\t//...\n}\n
ENUMFILE_dg=//田楽dllの機能を利用\n//ENUMFILE\n//使い方:#n = dllfunc("ENUMFILE",$s1);\n//説明:(ワイルドカードで)指定されたファイルを検索します。 なお、実際に見つかったファイル名を取得するには FINDNEXT 関数 を使用します。\n//引数:\n//\t$s1:(オプション文字列＋)ワイルドカード指定\n//\t書式は以下の通りです。\n//\t\t  "[options] wildcard_specs"\n//\t\t* オプション文字列(options)\n//\t\t  /o order_spec:ファイル・フォルダ名のソ\ートの 優先順位を指定します。 order_spec には 以下の４つの文字を 優先度の高い順に並べたものを指定します。\n//\t\t  n:ファイル名でソ\ート\n//\t\t  e:拡張子(ファイルの種類)でソ\ート\n//\t\t  t:タイムスタンプでソ\ート\n//\t\t  s:ファイルサイズでソ\ート\n//\t\t  このオプションによる指定をしなかった場合は、 "-o nets" を指定した場合と同じ結果になります。\n//\t\t  なお、n が最初に来る指定をした場合は デフォルトの動作と同じになることに注意して下さい。 同一のフォルダに同じ名前のファイルは 存在しないため、 残りのソ\ート指定は実際には使われないからです。\n//\t\t  /r:ソ\ート順序を逆順にします。\n//\t\t* ワイルドカード指定(wildcard_specs)\n//\t\t  以下の方法のいずれかで指定して下さい。\n//\t\t\t  o folder_name\\spec\n//\t\t\t  o folder_name specs\n//\t\t  ここで、\n//\t\t  folder_name は検索対象のフォルダ名、\n//\t\t  spec は１つのワイルドカード指定、\n//\t\t  specs は複数のワイルドカード指定を セミコロンまたは空白で区切ったもの\n//\t\t  です。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// カレントフォルダの *.bak ファイルを検索\n#r = dllfunc("ENUMFILE","*.bak");\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\t#r = dllfunc("REMOVE","/i '" + $file + "'");\n}\n// カレントフォルダ(.)の *.bat, *.cmd, *.com, *.exe ファイルを検索し、\n// タイムスタンプ、拡張子(ファイルの種類)、ファイルサイズ、名前、\n// という優先順位でソ\ートしたものを逆順に取得\n#r = dllfunc("ENUMFILE","/r /o tesn . *.bat;*.cmd *.com *.exe");\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\tmessage $file;\n}\n
ENUMDIR_dg=//田楽dllの機能を利用\n//ENUMDIR\n//使い方:#n = dllfunc("ENUMDIR",$s1);\n//説明:(ワイルドカードで)指定されたフォルダを検索します。 実際に見つかったフォルダ名を取得するには FINDNEXT 関数 を使用します。 なお、現在のフォルダを表\す "." と、 親フォルダを表\す ".." は必ず返されるので注意して下さい。\n//引数:\n//\t$s1:(オプション文字列＋)ワイルドカード指定\n//\t書式は以下の通りです。\n//\t\t  "[options] wildcard_specs"\n//\t\t* オプション文字列(options)\n//\t\t  /o order_spec:ファイル・フォルダ名のソ\ートの 優先順位を指定します。\n//\t\t  具体的な指定方法は ENUMFILE 関数 の説明を 参照して下さい。\n//\t\t  /r:ソ\ート順序を逆順にします。 但し、"." と ".." は最初に返されるので 注意して下さい。\n//\t\t* ワイルドカード指定(wildcard_specs)\n//\t\t  具体的な指定方法は ENUMFILE 関数 の説明を 参照して下さい。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// Windows フォルダのサブフォルダを検索\n#r = dllfunc("ENUMDIR",windir + "\\\\*.*");\nwhile (1) {\n\t$dir = dllfuncstr("FINDNEXT");\n\tif ($dir == "") break;\n\telse if ($dir == "." || $dir == "..") continue;\n\tmessage $dir;\n}\n
ENUMPATH_dg=//田楽dllの機能を利用\n//ENUMPATH\n//使い方:#n = dllfunc("ENUMPATH",$s1);\n//説明:(ワイルドカードで)指定されたファイルを サブフォルダの中も含めて再帰的に検索します。 なお、実際に見つかったファイル名を取得するには FINDNEXT 関数 を使用します。\n//引数:\n//\t$s1:(オプション文字列＋)ワイルドカード指定\n//\t書式は以下の通りです。\n//\t\t  "[options] wildcard_specs"\n//\t\t* オプション文字列(options)\n//\t\t  /o order_spec:ファイル・フォルダ名のソ\ートの 優先順位を指定します。\n//\t\t  具体的な指定方法は ENUMFILE 関数 の説明を 参照して下さい。\n//\t\t  /r:通常はファイル→フォルダの順に検索しますが、 これを指定した場合はフォルダ→ファイルの順に 検索します。 また、/o によるソ\ート指定も逆順になります。\n//\t\t  /f:通常は(全ての)サブフォルダ名を表\示しますが、 これを指定した場合は(サブフォルダ内部も含めて) ファイルのみを検索します。\n//\t\t* ワイルドカード指定(wildcard_specs)\n//\t\t  具体的な指定方法は ENUMFILE 関数 の説明を 参照して下さい。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// My Documents フォルダとそのサブフォルダ内にある *.bak ファイルを全て削除\n#r = dllfunc("ENUMPATH","/f 'C:\\\\My Documents\\\\*.bak'");\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\t#r = dllfunc("REMOVE","/i 'C:\\\\My Documents\\\\" + $file + "'");\n}\n
FINDNEXT_dg=//田楽dllの機能を利用\n//FINDNEXT\n//使い方:$s = dllfuncstr("FINDNEXT");\n//説明:ENUMPATH, ENUMFILE, ENUMDIR 関数による ファイル(フォルダ)の検索の結果を受け取ります。\n//引数:\n//\t(なし)\n//返り値:１回の呼出し毎に１つのファイル(フォルダ)名を返します。 もうファイルが存在しない時は "" を返します。 なお、ENUMPATH 関数 の場合は 検索を開始したフォルダからの相対パスが返されます。\n//例:(ENUMPATH, ENUMFILE, ENUMDIR 関数の例を参照して下さい)\n
ISREADONLY_dg=//田楽dllの機能を利用\n//ISREADONLY\n//使い方:$s = dllfuncstr("ISREADONLY",$s1);\n//説明:ファイルまたはフォルダが書き込み禁止かどうかを調べます。 なお、FINDNEXT 関数 の実行後に 引数なし($s1 = "")で呼び出すと、 FINDNEXT で取得したファイルについての情報を返します。\n//引数:\n//\t$s1:ファイル(フォルダ)名 (または "")\n//返り値:書き込み禁止の場合は "!" を、そうでなければ "" を返します。\n// なお、ファイルが見つからなかった場合も "" を返します。\n//例:\nif (!dllfunc("ENUMFILE","*.txt")) goto END;\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\telse if (dllfuncstr("ISREADONLY","") == "!") {\n\t\tmessage $file + " は読取専用ファイルです";\n\t}\n}\n//...\n
SIZEOF_dg=//田楽dllの機能を利用\n//SIZEOF\n//使い方:$s = dllfuncstr("SIZEOF",$s1);\n//説明:ファイルのサイズを(文字列で)返します。 なお、FINDNEXT 関数 の実行後に 引数なし($s1 = "")で呼び出すと、 FINDNEXT で取得したファイルについての情報を返します。\n//引数:\n//\t$s1:ファイル(フォルダ)名 (または "")\n//返り値:サイズを文字列で表\したものが返ります。 ファイルが見つからなかった場合は "" を返します。\n//例:\nif (!dllfunc("ENUMFILE","*.txt")) goto END;\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\tmessage $file + " のファイルサイズは " +\n\t\t\tdllfuncstr("SIZEOF","") + " です";\n}\n//...\n
TIMESTAMPOF_dg=//田楽dllの機能を利用\n//TIMESTAMPOF\n//使い方:$s = dllfuncstr("TIMESTAMPOF",$s1);\n//説明:指定ファイルのタイムスタンプを返します。 なお、FINDNEXT 関数 \n//の実行後に ファイル名なしで呼び出すと、 FINDNEXT で取得したファイルについての情報を返します。\n//引数:\n//\t$s1:(オプション文字列＋)ファイル(フォルダ)名\n//\t書式は以下の通りです。\n//\t\t  "[options] file"\n//\t\t* オプション文字列(options)\n//\t\t  /l:タイムスタンプの西暦を４桁にしたものを返します。\n//\t\t* ファイル(フォルダ)名(file)\n//\t\t  ファイルまたはフォルダ名\n//返り値:タイムスタンプを "[YY]YY/MM/DD HH:MM:SS" の形式で返します。\n// ファイルが見つからなかった場合は "" を返します。\n//例:\nif (!dllfunc("ENUMFILE","*.txt")) goto END;\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\tmessage $file + " のタイムスタンプは " +\n\t\t\tdllfuncstr("TIMESTAMPOF","/l") + " です";\n}\n//...\n
TIMECOUNTOF_dg=//田楽dllの機能を利用\n//TIMECOUNTOF\n//使い方:$s = dllfuncstr("TIMECOUNTOF",$s1);\n//説明:指定ファイルのタイムスタンプをある整数値(を文字列)で返します。 なお、FINDNEXT 関数 の実行後に 引数なし($s1 = "")で呼び出すと、 FINDNEXT で取得したファイルについての情報を返します。\n//引数:\n//\t$s1:ファイル(フォルダ)名 (または "")\n//返り値:タイムスタンプを世界標準時(UTC)に変換して32ビットの 整数で表\したものを文字列として返します。 ここで、各ビットには以下のように日付・時刻が割り当てられています。\n//\t  0-4\tビット\t\t２秒刻みの秒\n//\t  5-10\tビット\t\t分(0-59)\n//\t  11-15 ビット\t\t24時間形式での時(0-23)\n//\t  16-20 ビット\t\t日(1-31)\n//\t  21-24 ビット\t\t月(1-12)\n//\t  25-31 ビット\t\t1980 年からの経過年(+1980 で実際の年になる)\n//ファイルが見つからなかった場合は "" を返します。\n//※\tややこしい定義ですが、 要するにタイムスタンプが新しければこの整数値は より大きくなるようになっています。\n//例:\n$ftm1 = dllfuncstr("TIMECOUNTOF","file1.txt");\n$ftm2 = dllfuncstr("TIMECOUNTOF","file2.txt");\nif (val($ftm1) >= val($ftm2))\n\tmessage "file1.txt は file2.txt より新しい(か同時刻の)ファイルです";\nelse\n\tmessage "file1.txt は file2.txt より古いファイルです";\n//...\n
ATTRIBUTEOF_dg=//田楽dllの機能を利用\n//ATTRIBUTEOF\n//使い方:$s = dllfuncstr("ATTRIBUTEOF",$s1);\n//説明:指定ファイル・フォルダの属性を表\す文字列を返します。 なお、FI\n//NDNEXT 関数 の実行後に 引数なし($s1 = "")で呼び出すと、 FINDNEXT で取得したファイルについての情報を返します。\n//引数:\n//\t$s1:ファイル(フォルダ)名 (または "")\n//返り値:以下の文字の組み合わせが返ります。\n//\t  a \tアーカイブ属性\n//\t  r \t読取専用属性\n//\t  h \t隠し属性\n//\t  s \tシステム属性\n//\t  d \tフォルダ\n//ファイルがないか属性がない場合は "" を返します。\n//例:\nif (!dllfunc("ENUMPATH","*.*")) goto END;\nwhile (1) {\n\t$file = dllfuncstr("FINDNEXT");\n\tif ($file == "") break;\n\telse if (strstr(dllfuncstr("ATTRIBUTEOF",""),"d") != -1) {\n\t\tmessage $file + " はフォルダです";\n\t}\n}\n//...\n
GETDRIVES_dg=//田楽dllの機能を利用\n//GETDRIVES\n//使い方:$s = dllfuncstr("GETDRIVES");\n//説明:現在利用可能\なディスクドライブを取得します。\n//引数:\n//\t(なし)\n//返り値:"1" または "0" からなる 32 文字の文字列で返ってきます。 例えば、以下のような感じです。\n//\t  "10110000000000000000000000000000"\n//左から順に A, B, C ドライブに対応しています。 "1" の場合は利用可能\\n//、"0" の場合は利用不可能\です。 上記の例の場合、A と C と D ドライブが利用可能\です。 27 文字目(ドライブ Z)以降は意味がありません。\n//例:(省略)\n
GETLONGNAME_dg=//田楽dllの機能を利用\n//GETLONGNAME\n//使い方:$s = dllfuncstr("GETLONGNAME",$s1);\n//説明:指定ファイルまたはフォルダのロングファイル名をフルパスで返します。\n//引数:\n//\t$s1:ファイル(フォルダ)名\n//返り値:ロングファイルネームに変換された フルパスのファイル(フォルダ)名が返ります。 パスの最後のファイルまたはフォルダ名は 実際に存在しないものでも構\いませんが、 途中のサブフォルダが存在しない場合は "" を返します。\n//例:\n$file = "C:\\\\PROGRA~1";\nmessage $file + " のロングファイル名は " +\n\t\tdllfuncstr("GETLONGNAME",$file) + " です";\n//...\n
RUN_dg=//田楽dllの機能を利用\n//田楽DLLVer1.7x〜にて対応\n//RUN / MAXRUN / ICONRUN / HIDERUN\n//使い方:#n = dllfunc("RUN",$s1);\n//説明:$s1 をコマンドとみなしてプログラムを実行します。 それぞれ 普通に (RUN)、最大化状態で (MAXRUN)、 アイコン化状態で (ICONRUN)、不可視状態で (HIDERUN) 実行します。\n//引数:\n//\t$s1:コマンド名、及びオプションを指定します。\n//\tなお、ファイルがアプリケーションに関連付けられている時は、 そのファイル名だけを指定すれば 関連付けられたアプリケーションでそのファイルを開きます。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// foo.txt を最大化状態で開く\nif (!dllfunc("MAXRUN", hidemarudir + "\\\\hidemaru.exe foo.txt")) {\n\tmessage "foo.txt を開けませんでした";\n\t//...\n}\n// 通常使うブラウザで bar.html を開く\nif (!dllfunc("RUN", "bar.html")) {\n\tmessage "bar.html を開けませんでした";\n\t//...\n}\n
MAXRUN_dg=//田楽dllの機能を利用\n//田楽DLLVer1.7x〜にて対応\n//RUN / MAXRUN / ICONRUN / HIDERUN\n//使い方:#n = dllfunc("RUN",$s1);\n//説明:$s1 をコマンドとみなしてプログラムを実行します。 それぞれ 普通に (RUN)、最大化状態で (MAXRUN)、 アイコン化状態で (ICONRUN)、不可視状態で (HIDERUN) 実行します。\n//引数:\n//\t$s1:コマンド名、及びオプションを指定します。\n//\tなお、ファイルがアプリケーションに関連付けられている時は、 そのファイル名だけを指定すれば 関連付けられたアプリケーションでそのファイルを開きます。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// foo.txt を最大化状態で開く\nif (!dllfunc("MAXRUN", hidemarudir + "\\\\hidemaru.exe foo.txt")) {\n\tmessage "foo.txt を開けませんでした";\n\t//...\n}\n// 通常使うブラウザで bar.html を開く\nif (!dllfunc("RUN", "bar.html")) {\n\tmessage "bar.html を開けませんでした";\n\t//...\n}\n
ICONRUN_dg=//田楽dllの機能を利用\n//田楽DLLVer1.7x〜にて対応\n//RUN / MAXRUN / ICONRUN / HIDERUN\n//使い方:#n = dllfunc("RUN",$s1);\n//説明:$s1 をコマンドとみなしてプログラムを実行します。 それぞれ 普通に (RUN)、最大化状態で (MAXRUN)、 アイコン化状態で (ICONRUN)、不可視状態で (HIDERUN) 実行します。\n//引数:\n//\t$s1:コマンド名、及びオプションを指定します。\n//\tなお、ファイルがアプリケーションに関連付けられている時は、 そのファイル名だけを指定すれば 関連付けられたアプリケーションでそのファイルを開きます。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// foo.txt を最大化状態で開く\nif (!dllfunc("MAXRUN", hidemarudir + "\\\\hidemaru.exe foo.txt")) {\n\tmessage "foo.txt を開けませんでした";\n\t//...\n}\n// 通常使うブラウザで bar.html を開く\nif (!dllfunc("RUN", "bar.html")) {\n\tmessage "bar.html を開けませんでした";\n\t//...\n}\n
HIDERUN_dg=//田楽dllの機能を利用\n//田楽DLLVer1.7x〜にて対応\n//RUN / MAXRUN / ICONRUN / HIDERUN\n//使い方:#n = dllfunc("RUN",$s1);\n//説明:$s1 をコマンドとみなしてプログラムを実行します。 それぞれ 普通に (RUN)、最大化状態で (MAXRUN)、 アイコン化状態で (ICONRUN)、不可視状態で (HIDERUN) 実行します。\n//引数:\n//\t$s1:コマンド名、及びオプションを指定します。\n//\tなお、ファイルがアプリケーションに関連付けられている時は、 そのファイル名だけを指定すれば 関連付けられたアプリケーションでそのファイルを開きます。\n//返り値:#n が 1 なら成功、0 なら失敗しています。\n//例:\n// foo.txt を最大化状態で開く\nif (!dllfunc("MAXRUN", hidemarudir + "\\\\hidemaru.exe foo.txt")) {\n\tmessage "foo.txt を開けませんでした";\n\t//...\n}\n// 通常使うブラウザで bar.html を開く\nif (!dllfunc("RUN", "bar.html")) {\n\tmessage "bar.html を開けませんでした";\n\t//...\n}\n
SHOWDIALOG_dg=//田楽dllの機能を利用\n//SHOWDIALOG\n//使い方:#n = dllfunc("SHOWDIALOG",#n1,#n2);\n//説明:NEWDIALOG, NEWCONTROL 関数等で作成した ユーザー定義ダイアログ\n//を表\示します。\n//引数:\n//\t#n1:ダイアログのオーナーウィンドウのハンドル(または 0)\n//\t#n2:常に手前に表\示する場合は 1、そうでなければ 0\n//返り値:成功した場合は 1 以上の整数を、失敗した場合は 0 を返します。\n//この関数はダイアログ表\示中に呼び出すと必ず失敗します。 したがって、一度に表\示可能\なダイアログは１つだけです。\n//例:(同梱の dgdll.mac を参照して下さい)\n
ENDDIALOG_dg=//田楽dllの機能を利用\n//ENDDIALOG\n//使い方:#n = dllfunc("ENDDIALOG");\n//説明:SHOWDIALOG 関数 で表\示したダイアログを 閉じます。\n//引数:\n//\t(なし)\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
WAITCTRLNOTIFY_dg=//田楽dllの機能を利用\n//WAITCTRLNOTIFY\n//使い方:$s = dllfuncstr("WAITCTRLNOTIFY",#n1);\n//説明:ダイアログからの通知コードを取得します。\n//引数:\n//\t#n1:ダイアログからの通知コードを待つ時間(単位はミリ秒)\n//\t（0 以下の値を指定すると、 関数呼出しの時点で通知コードが届いていなければ すぐに復帰します）\n//返り値:コントロールの通知コードが（文字列で）返ります。 ダイアログ\n//が表\示されていないか、 通知コードが届かなかった場合は "" を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SHOWMESSAGE_dg=//田楽dllの機能を利用\n//SHOWMESSAGE\n//使い方:#n = dllfunc("SHOWMESSAGE",$s1,$s2);\n//説明:(ユーザー定義のダイアログを表\示中に)メッセージボックスを表\示します。\n//引数:\n//\t$s1:「ＯＫ」ボタンが押された時に通知する通知コード\n//\t$s2:メッセージ文字列\n//返り値:メッセージボックスの表\示に成功したら 1 を、失敗したら 0 を返します。 「ＯＫ」ボタンが押されたかどうかは WAITCTRLNOTIFY 関数 の返り値(通知コード) で判定して下さい。\n//例:\n#n = dllfunc("NEWDIALOG","メッセージボックスのテスト",20,"0 0 center");\n#n = dllfunc("NEWCONTROL","button","","ボタン１");\n#n = dllfunc("SETCTRLNOTIFY","","10");\n#n = dllfunc("NEWCONTROL","okcancel","","");\n#n = dllfunc("SHOWDIALOG",0,1);\nwhile (1) {\n\t$ntf_code = dllfuncstr("WAITCTRLNOTIFY",100);\n\tif ($ntf_code == "" || $nft_code == "999") continue;\n\telse if ($ntf_code == "1" || $ntf_code == "0") break;\n\telse if ($ntf_code == "10") {\n\t\t// ボタンが押されたらメッセージボックスを表\示\n\t\t#n = dllfunc("SHOWMESSAGE","999","ボタンが押されました。");\n\t}\n}\n#n = dllfunc("ENDDIALOG");\n//...\n
SHOWQUESTION_dg=//田楽dllの機能を利用\n//SHOWQUESTION\n//使い方:#n = dllfunc("SHOWQUESTION",$s1,$s2,$s3);\n//説明:(ユーザー定義のダイアログを表\示中に) 質問のためのメッセージボ\n//ックスを表\示します。\n//引数:\n//\t$s1:「はい」ボタンが押された時に通知する通知コード\n//\t$s2:「いいえ」ボタンが押された時に通知する通知コード\n//\t$s3:メッセージ文字列\n//返り値:メッセージボックスの表\示に成功したら 1 を、失敗したら 0 を返します。 「はい」と「いいえ」のどちらのボタンが押されたかは WAITCTRLNOTIFY 関数 の返り値(通知コード) で判定して下さい。\n//例:\n#n = dllfunc("NEWDIALOG","メッセージボックスのテスト",20,"0 0 center");\n#n = dllfunc("NEWCONTROL","button","","ボタン１");\n#n = dllfunc("SETCTRLNOTIFY","","10");\n#n = dllfunc("NEWCONTROL","okcancel","","");\n#n = dllfunc("SHOWDIALOG",0,1);\nwhile (1) {\n\t$ntf_code = dllfuncstr("WAITCTRLNOTIFY",100);\n\tif ($ntf_code == "" || $ntf_code == "999") continue;\n\telse if ($ntf_code == "1" || $ntf_code == "0") break;\n\telse if ($ntf_code == "10") {\n\t\t// ボタンが押されたらメッセージボックスを表\示\n\t\t#n = dllfunc("SHOWQUESTION","100","200","何ですか？");\n\t} else if ($ntf_code == "100") {\n\t\t//\t「はい」ボタンが押された場合\n\t\t#n = dllfunc("SHOWMESSAGE","999","「はい」が押されました。");\n\t} else if ($ntf_code == "200") {\n\t\t//\t「いいえ」ボタンが押された場合\n\t\t#n = dllfunc("SHOWMESSAGE","999","「いいえ」が押されました。");\n\t}\n}\n#n = dllfunc("ENDDIALOG");\n//...\n
NEWDIALOG_dg=//田楽dllの機能を利用\n//NEWDIALOG\n//使い方:#n = dllfunc("NEWDIALOG",$s1,#n2,$s3);\n//説明:ユーザー定義ダイアログのテンプレートの作成を開始します。\n//引数:\n//\t$s1:ダイアログのタイトル文字列\n//\t#n2:ダイアログの横幅（単位は半角文字１文字分）\n//\t$s3:ダイアログの表\示位置その他のオプション\n//\t書式は以下の通りです(後ろから順に省略可能\)。\n//\t\t  "x y origin fontname fontsize unit"\n//\t\t  x:ダイアログの表\示位置の x 座標(デフォルト = 0) 単位は半角文字幅の４分の１です。\n//\t\t  y:ダイアログの表\示位置の y 座標(デフォルト = 0) 単位は文字高の８分の１です。\n//\t\t  origin:ダイアログの表\示位置(の座標原点)を指定\n//\t\t  window:親ウィンドウのクライアント領域の左上が原点\n//\t\t  screen:デスクトップの左上が原点\n//\t\t  caret:文字入力カーソ\ル位置が原点(Ver.2.20〜)\n//\t\t  cursor:マウスカーソ\ル位置が原点(Ver.2.20〜)\n//\t\t  center:デスクトップの中央に表\示 (x, y は無視される)\n//\t\t  それ以外:親ウィンドウのクライアント領域の中央に表\示 (x, y は無視される) (デフォルト)\n//\t\t  fontname:フォント名 (デフォルト = システム定義)\n//\t\t  fontsize:フォントサイズ(単位は pt) (デフォルト = システム定義)\n//\t\n//\t\t  unit:"px" を指定すると、x, y の各座標 指定をピクセル値とみなすようになります (デフォルト = 無指定)\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中に呼び出すと必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
NEWDLGPAGE_dg=//田楽dllの機能を利用\n//NEWDLGPAGE\n//使い方:#n = dllfunc("NEWDLGPAGE",$s1,#n2);\n//説明:frame, group, tab コントロールの内部に表\示する 子ダイアログの作成を開始します。\n//引数:\n//\t$s1:子ダイアログの名前("root" は予\約名なので使わないで下さい)\n//\t\n//\t#n2:子ダイアログの横幅（単位は半角文字１文字分）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中に呼び出すと必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCURDLGPAGE_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//SETCURDLGPAGE\n//使い方:#n = dllfunc("SETCURDLGPAGE",$s1);\n//説明:NEWCONTROL 関数で コントロールを追加する対象の(子)ダイアログを変更します。\n//※\tframe や tab コントロールのページ切り替えは SETCTRLSTATE() 関数を使って下さい。\n//引数:\n//\t$s1:子ダイアログの名前(親ダイアログを指定する時は "root")\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:\n//...\nadd_groupbox:\n\t//\t現在追加対象の子ダイアログの名前を取得\n\t$$cur_page = dllfuncstr("GETCURDLGPAGE");\n\tif ($$cur_page == "gb1") {\n\t\tmessage "同じ名前の子ダイアログが既に登録されています。";\n\t\treturn;\n\t}\n\t//\t追加対象の子ダイアログを変更/新規作成\n\tif (!dllfunc("SETCURDLGPAGE","gb1"))\n\t\tif (!dllfunc("NEWDLGPAGE","gb1",30)) goto exit;\n\t//\t子ダイアログにコントロールを追加\n\tif (!dllfunc("NEWCONTROL","rdbtn","rdb1@gb1","item1")) goto exit;\n\tif (!dllfunc("NEWCONTROL","rdbtn","rdb2@gb1","item2")) goto exit;\n\tif (!dllfunc("NEWCONTROL","rdbtn","rdb3@gb1","item3")) goto exit;\n\tif (!dllfunc("SETCTRLWIDTH","",10)) goto exit;\n\tif (!dllfunc("NEWCONTROL","edit","ed3@gb1","")) goto exit;\n\t//\t追加対象を元に戻す\n\tif (!dllfunc("SETCURDLGPAGE",$$cur_page)) goto exit;\n\t//\t今作成した子ダイアログをグループボックス内に表\示させる\n\tif (!dllfunc("NEWCONTROL","group","grp1","select")) goto exit;\n\tif (!dllfunc("SETCTRLITEM","","gb1","0")) goto exit;\n\treturn;\n//...\n}\n
GETCURDLGPAGE_dg=//田楽dllの機能を利用\n//田楽DLLVer1.2x〜にて対応\n//GETCURDLGPAGE\n//使い方:$s = dllfuncstr("GETCURDLGPAGE");\n//説明:現在コントロールを追加する対象になっている (子)ダイアログの名前を返します。\n//※\tframe や tab コントロールで表\示中の子ダイアログの取得は GETCTRL\n//STATE() 関数を使って下さい。\n//引数:\n//\t(なし)\n//返り値:現在コントロールを追加する対象になっている(子)ダイアログの名前。 追加対象が親ダイアログだった場合は "root" が返ります。 追加対象の(子)ダイアログがない場合は "" が返ります。\n//例:(SETCURDLGPAGE 関数 の例を参照して下さい)\n
SETDLGTITLE_dg=//田楽dllの機能を利用\n//SETDLGTITLE\n//使い方:#n = dllfunc("SETDLGTITLE",$s1);\n//説明:ダイアログのタイトルを(動的に)変更します。\n//引数:\n//\t$s1:ダイアログの新しいタイトル文字列\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
GETDLGTITLE_dg=//田楽dllの機能を利用\n//GETDLGTITLE\n//使い方:$s = dllfuncstr("GETDLGTITLE");\n//説明:ダイアログのタイトルを返します。\n//引数:\n//\t(なし)\n//返り値:ダイアログのタイトル文字列\n//例:(同梱の dgdll.mac を参照して下さい)\n
SAVEDIALOG_dg=//田楽dllの機能を利用\n//SAVEDIALOG\n//使い方:#n = dllfunc("SAVEDIALOG",$s1,$s2);\n//説明:ダイアログのデータを指定されたデータファイルに保存します。\n//引数:\n//\t$s1:データファイル名\n//\t$s2:データファイルを識別するための署名文字列 (必要なければ "" を指\n//\t定)\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(省略)\n
LOADDIALOG_dg=//田楽dllの機能を利用\n//LOADDIALOG\n//使い方:#n = dllfunc("LOADDIALOG",$s1,$s2);\n//説明:ダイアログのデータを指定されたデータファイルから読み込みます。\n//引数:\n//\t$s1:データファイル名\n//\t$s2:データファイルを識別するための署名文字列 (必要なければ "" を指\n//\t定)\n//\t指定した場合は データファイルの署名と指定したものが一致した時にのみデータ を読み込みます。\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:\nif (!dllfunc("LOADDIALOG",\n\t\t"foo.dat",\n\t\t"This is dialog data of HOGE macro"\n\t\t)\n\t) {\n\tmessage "ダイアログのデータファイルの読込みに失敗しました";\n\t//...\n}\n
GETSIGNATURE_dg=//田楽dllの機能を利用\n//GETSIGNATURE\n//使い方:$s = dllfuncstr("GETSIGNATURE",$s1);\n//説明:指定したデータファイルから署名を読み取ります。\n//引数:\n//\t$s1:データファイル名\n//返り値:データファイルの署名文字列\n//例:\nif (dllfuncstr("GETSIGNATURE","foo.dat")\n\t\t!=\n\t"This is dialog data of HOGE macro") {\n\tmessage "データファイルが違います";\n\t//...\n}\n
SETDLGPOS_dg=//田楽dllの機能を利用\n//田楽DLLVer2.6x〜にて対応\n//SETDLGPOS\n//使い方:#n = dllfunc("SETDLGPOS",#n1,#n2,$s3,$s4);\n//説明:ダイアログの位置を指定した位置に変更します。\n//引数:\n//\t#n1:ダイアログの横方向の座標値\n//\t#n2:ダイアログの縦方向の座標値\n//\t$s3:座標原点の指定\n//\tNEWDIALOG() のダイアログ表\示位置の指定と同じ 値を指定します（cente\n//\tr または空文字指定の場合は #n1, #n2 の値は無視されます）。\n//\t$s4:座標値の単位の指定\n//\t""(空文字) を指定した場合はフォントサイズに基づいた値 （横方向は半角文字幅の４分の１、縦方向は文字高の８分の１）、 "px" を指定した場合はピクセル値と解釈されます。\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(省略)\n
GETDLGPOS_dg=//田楽dllの機能を利用\n//田楽DLLVer2.6x〜にて対応\n//GETDLGPOS\n//使い方:$s = dllfuncstr("GETDLGPOS");\n//説明:ダイアログの現在位置を返します。\n//引数:\n//\t(なし)\n//返り値:ダイアログの現在の座標値を "x,y" という形式で返します。 ここで、各座標値は NEWDIALOG() または直前の SETDLGPOS() により 指定した座標原点および単位で表\現されます。\n//例:(省略)\n
GETDLGSIZE_dg=//田楽dllの機能を利用\n//田楽DLLVer2.7x〜にて対応\n//GETDLGSIZE\n//使い方:$s = dllfuncstr("GETDLGSIZE");\n//説明:ダイアログの大きさをピクセル単位で返します。\n//引数:\n//\t(なし)\n//返り値:ダイアログの横、縦のサイズを "width,height" という 形式で返します。ただし、この関数が有効なのは SHOWDIALOG() 関数の 呼び出しから ENDDIALOG() 関数の呼び出しまで、すなわちダイアログの 表\示中のみです。それ以外のタイミングで呼ばれた場合、空文字列を 返します。\n//例:(省略)\n
SETDLGIMESTATE_dg=//田楽dllの機能を利用\n//田楽DLLVer2.7x〜にて対応\n//SETDLGIMESTATE\n//使い方:#n = dllfunc("SETDLGIMESTATE", #n1);\n//説明:ダイアログ中の edit, mledit, combo コントロールが入力フォーカ\n//スを 得た時の IME の状態を指定します。\n//個別のコントロールに状態を設定したいときは SETCTRLIMESTATE() を 使\n//ってください。 両者の関係については GETCTRLIMESTATE() の備考を 参照してください。\n//引数:\n//\t#n1:0:指定なし、1:常に IME を ON、2:常に IME を OFF、 3:最初にフォーカスを得たときのみ IME を ON、 4:最初にフォーカスを得たときのみ IME を OFF\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(省略)\n
GETDLGIMESTATE_dg=//田楽dllの機能を利用\n//田楽DLLVer2.7x〜にて対応\n//GETDLGIMESTATE\n//使い方:$s = dllfuncstr("GETDLGIMESTATE");\n//説明:edit, mledit, combo コントロールが入力フォーカスを得た時の IM\n//E の状態を返します。\n//個別のコントロールの状態は GETCTRLIMESTATE() を 使って取得します。\n// 両者の関係については GETCTRLIMESTATE() の備考を 参照してください。\n//引数:\n//\t(なし)\n//返り値:"0":指定なし、"1":常に IME を ON、"2":常に IME を OFF、 "3"\n//:最初にフォーカスを得たときのみ IME を ON、 "4":最初にフォーカスを得たときのみ IME を OFF\n//例:(省略)\n
NEWCONTROL_dg=//田楽dllの機能を利用\n//NEWCONTROL\n//使い方:#n = dllfunc("NEWCONTROL",$s1,$s2,$s3);\n//説明:(子)ダイアログにコントロールを追加します。\n//引数:\n//\t$s1:コントロール名\n//\t$s2:コントロール識別名 (必要なければ "" を指定)\n//\t$s3:コントロールの初期化のための文字列\n//\t※\tコントロール名の一覧と初期化文字列の書式については こちらを参照して下さい。\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
ENABLECTRL_dg=//田楽dllの機能を利用\n//ENABLECTRL\n//使い方:#n = dllfunc("ENABLECTRL",#n1,$s2);\n//説明:指定したコントロールの表\示状態を変更します。\n//引数:\n//\t#n1:1 なら通常の状態、 0 なら入力を受け付けない状態に変更\n//\t$s2:コントロール識別名（複数指定可）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
NEWCOLUMN_dg=//田楽dllの機能を利用\n//NEWCOLUMN\n//使い方:#n = dllfunc("NEWCOLUMN",#n1);\n//説明:現在コントロールを配置している列の右側に 新しいコントロール配\n//置列を追加します。\n//引数:\n//\t#n1:新しい配置列の横幅（単位は半角文字１文字分）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
NEWPAGE_dg=//田楽dllの機能を利用\n//NEWPAGE\n//使い方:#n = dllfunc("NEWPAGE",#n1);\n//説明:現在のコントロール配置行の下に 新しいコントロール配置行を追加します。\n//引数:\n//\t#n1:新しい配置行の横幅（単位は半角文字１文字分）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLSTRING_dg=//田楽dllの機能を利用\n//SETCTRLSTRING\n//使い方:#n = dllfunc("SETCTRLSTRING",$s1,$s2);\n//説明:指定したコントロールのテキストを(動的に)変更します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:コントロールのテキスト\n//\t（コントロールの種類によって指定する値の意味が違います。 詳細はこちらを参照して下さい。）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
GETCTRLSTRING_dg=//田楽dllの機能を利用\n//GETCTRLSTRING\n//使い方:$s = dllfuncstr("GETCTRLSTRING",$s1);\n//説明:指定したコントロールのテキストを返します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//返り値:コントロールのテキスト （コントロールの種類によって返される値の意味が違います。 詳細はこちらを参照して下さい。）\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLSTATE_dg=//田楽dllの機能を利用\n//SETCTRLSTATE\n//使い方:#n = dllfunc("SETCTRLSTATE",$s1,$s2);\n//説明:指定したコントロールの選択状態を(動的に)変更します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:コントロールの選択状態を表\す文字列\n//\t（コントロールの種類によって指定する値の意味が違います。 詳細はこちらを参照して下さい。）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
GETCTRLSTATE_dg=//田楽dllの機能を利用\n//GETCTRLSTATE\n//使い方:$s = dllfuncstr("GETCTRLSTATE",$s1);\n//説明:指定したコントロールの選択状態を返します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//返り値:コントロールの状態を表\す文字列 （コントロールの種類によって返される値の意味が違います。 詳細はこちらを参照して下さい。）\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLWIDTH_dg=//田楽dllの機能を利用\n//SETCTRLWIDTH\n//使い方:#n = dllfunc("SETCTRLWIDTH",$s1,#n2);\n//説明:指定したコントロールの幅を変更し、 次回の NEWCONTROL 関数 で追加される コントロールをその右側の余白に配置します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t#n2:コントロールの横幅（単位は半角文字１文字分）\n//\t（-1 を指定すると現在の余白の半分を指定したものと見なされます）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLHEIGHT_dg=//田楽dllの機能を利用\n//SETCTRLHEIGHT\n//使い方:#n = dllfunc("SETCTRLHEIGHT",$s1,#n2);\n//説明:指定したコントロールの高さを変更します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t#n2:コントロールの縦幅（単位は半角文字１文字分）\n//\t（この関数による指定が無視されるコントロールがあります。 詳細はこちらを参照して下さい。）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLNOTIFY_dg=//田楽dllの機能を利用\n//SETCTRLNOTIFY\n//使い方:#n = dllfunc("SETCTRLNOTIFY",$s1,$s2);\n//説明:指定したコントロールの通知コードを指定します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:コントロールに割り当てる通知コード\n//\tコントロールの種類によっては複数の通知コードを 割り当てることができますが、 その場合は各通知コードを半角のカンマで区切って 指定して下さい。\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、この関数はダイアログ表\示中は必ず失敗します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLFONT_dg=//田楽dllの機能を利用\n//SETCTRLFONT\n//使い方:#n = dllfunc("SETCTRLFONT",$s1,$s2);\n//説明:指定したコントロールのフォントを(動的に)変更します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:フォント属性を指定する文字列\n//\t書式は以下の通りです。\n//\t\t  "属性指定 色指定 [フォント名]"\n//\t\t* 属性指定:以下の文字の組み合わせを指定します。\n//\t\t\t"b":ボールド体\n//\t\t\t"i":イタリック体\n//\t\t\t"u":下線あり\n//\t\t\t"s":打ち消し線あり\n//\t\t  例:"biu" …ボールド＆イタリック＆下線あり\n//\t\t* 色指定:(こちら を参照して下さい)\n//\t\t* フォント名:"ＭＳ Ｐゴシック" 等のフォント名を指定して下さい。 省略した場合はシステムフォントを使用します。\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLIMESTATE_dg=//田楽dllの機能を利用\n//田楽DLLVer1.5x〜にて対応\n//SETCTRLIMESTATE\n//使い方:#n = dllfunc("SETCTRLIMESTATE",$s1,#n2);\n//説明:指定したコントロールがフォーカスを得た時の IME の状態を指定します。\n//(edit, mledit, combo コントロールのみで有効)\n//この関数による設定は SETDLGIMESTATE() の設定を上書きします。 両者の関係については GETCTRLIMESTATE() の備考を 参照してください。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t#n2:0:指定なし、1:常に IME を ON、2:常に IME を OFF、 3:最初にフォ\n//\tーカスを得たときのみ IME を ON、 4:最初にフォーカスを得たときのみ IME を OFF\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(省略)\n
GETCTRLIMESTATE_dg=//田楽dllの機能を利用\n//田楽DLLVer1.5x〜にて対応\n//GETCTRLIMESTATE\n//使い方:$s = dllfuncstr("GETCTRLIMESTATE",$s1);\n//説明:指定したコントロールがフォーカスを得た時の IME の状態を返します。\n//(edit, mledit, combo コントロールのみで有効)\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//返り値:"0":指定なし、"1":常に IME を ON、"2":常に IME を OFF、 "3"\n//:最初にフォーカスを得たときのみ IME を ON、 "4":最初にフォーカスを得たときのみ IME を OFF\n//SETDLGIMESTATE() で設定した値は 反映されていません。 このコントロールに個別に設定された値が返ります。\n//備考:SETDLGIMESTATE() による全体設定と SETCTRLIMESTATE() による個別設定の 関係を表\にすると、下記のようになります。 ここで、３列目以降の「全体１/２〜」「個別１/２〜」は、 フォーカスを得る回数を表\しています。 「全体１」はダイアログの全ての入力フォーカスを持つコントロールの中で 最初にフォーカスを得たとき、 「個別１」はそのコントロールが最初にフォーカスを得たとき、 「＊＊２〜」は２回目以降のフォーカスを得たときを意味します。 また、「ON/OFF」は（設定に従い）IMEの状態の制御を行うこと、 「--」はIMEの制御を行わないことを意味しています。\n//全体設定\t個別設定\t全体１/個別１\t全体２〜/個別１ \t全体２〜/個別２〜\n//\n//0\t0\t--\t--\t--\n//1/2 0\tON/OFF\tON/OFF\tON/OFF\n//3/4 0\tON/OFF\t--\t--\n//(任意)\t1/2 ON/OFF\tON/OFF\tON/OFF\n//(任意)\t3/4 ON/OFF\tON/OFF\t--\n//例:(省略)\n
SETFOCUSEDCTRL_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//SETFOCUSEDCTRL\n//使い方:#n = dllfunc("SETFOCUSEDCTRL", $s1);\n//説明:フォーカスを得るコントロールを指定します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定するとテキストコントロールを除いた一番左上の コントロールが対象になります)\n//返り値:フォーカスの移動に成功した場合は 1、失敗した場合は 0 を返します。\n//例:\n#r = dllfunc("NEWDIALOG", "フォーカスのテスト", 40, "");\n#r = dllfunc("NEWCONTROL", "edit", "edt1", "最初のコントロール");\n#r = dllfunc("NEWCONTROL", "edit", "edt2", "２番目のコントロール");\n#r = dllfunc("NEWCONTROL", "okcancel", "", "");\n#r = dllfunc("SETFOCUSEDCTRL", "edt2"); // ２番目のコントロールにフォーカスを移す\n// ... (省略)\n
GETFOCUSEDCTRL_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//GETFOCUSEDCTRL\n//使い方:$s = dllfuncstr("GETFOCUSEDCTRL");\n//説明:(現在)フォーカスを得ているコントロールの識別名を返します。\n//引数:\n//\t(なし)\n//返り値:現在フォーカスを得ているコントロールの識別名\n//何らかの理由で関数が失敗した場合は "" を返します。\n//例:(省略)\n
SETCTRLSORT_dg=//田楽dllの機能を利用\n//田楽DLLVer2.3x〜にて対応\n//SETCTRLSORT\n//使い方:#n = dllfunc("SETCTRLSORT",$s1,$s2);\n//説明:指定したコントロールの項目のソ\ート機能\の状態を指定します。\n//(list, combo, cmblist, lview, chklist, tree コントロールのみで有効)\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:ソ\ート機能\の状態を指定する文字列\n//\t（コントロールの種類によって指定する値の意味が違います。 詳細はこちらを参照して下さい。）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//なお、ダイアログ表\示中は必ず 0 を返します。\n//例:(省略)\n
GETCTRLSORT_dg=//田楽dllの機能を利用\n//田楽DLLVer2.3x〜にて対応\n//GETCTRLSORT\n//使い方:$s = dllfuncstr("GETCTRLSORT",$s1);\n//説明:指定したコントロールのソ\ート機能\の状態を返します。\n//(list, combo, cmblist, lview, chklist, tree コントロールのみで有効)\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//返り値:（コントロールの種類によって返される値の意味が違います。 詳細はこちらを参照して下さい。）\n//例:(省略)\n
SETCTRLITEM_dg=//田楽dllの機能を利用\n//SETCTRLITEM\n//使い方:#n = dllfunc("SETCTRLITEM",$s1,$s2,$s3);\n//説明:指定したコントロールに(動的に)項目を追加します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:コントロールの項目テキスト\n//\t（コントロールの種類によって指定する値の意味が違います。 詳細はこちらを参照して下さい。）\n//\t$s3:項目を追加する位置を表\す文字列\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
CHANGECTRLITEM_dg=//田楽dllの機能を利用\n//CHANGECTRLITEM\n//使い方:#n = dllfunc("CHANGECTRLITEM",$s1,$s2,$s3);\n//説明:指定したコントロールの既存の項目を(動的に)変更します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:コントロールの項目テキスト\n//\t（コントロールの種類によって指定する値の意味が違います。 詳細はこちらを参照して下さい。）\n//\t$s3:変更する項目の位置を表\す文字列\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
DELETECTRLITEM_dg=//田楽dllの機能を利用\n//DELETECTRLITEM\n//使い方:#n = dllfunc("DELETECTRLITEM",$s1,$s2);\n//説明:指定したコントロールの既存の項目を削除します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:削除する項目の位置を表\す文字列\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
RESETCTRLITEM_dg=//田楽dllの機能を利用\n//RESETCTRLITEM\n//使い方:#n = dllfunc("RESETCTRLITEM",$s1);\n//説明:指定したコントロールの全項目を削除します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
GETCTRLITEM_dg=//田楽dllの機能を利用\n//GETCTRLITEM\n//使い方:$s = dllfuncstr("GETCTRLITEM",$s1,$s2);\n//説明:指定したコントロールの項目テキストを返します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:取得する項目の位置を表\す文字列\n//返り値:取得された項目テキスト\n//$s2 の位置指定が有効でない値だった場合は ""(空文字列)を返します。\n//\n//例:(同梱の dgdll.mac を参照して下さい)\n
SETCTRLFOCUSEDITEM_dg=//田楽dllの機能を利用\n//SETCTRLFOCUSEDITEM\n//使い方:#n = dllfunc("SETCTRLFOCUSEDITEM",$s1,$s2);\n//説明:指定したコントロール中のフォーカスを得る項目を(動的に)変更します。\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//\t$s2:項目の指定\n//\t（コントロールの種類によって指定する値の意味が違います。 詳細はこちらを参照して下さい。）\n//返り値:成功した場合は 1 を、失敗した場合は 0 を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
GETCTRLFOCUSEDITEM_dg=//田楽dllの機能を利用\n//GETCTRLFOCUSEDITEM\n//使い方:$s = dllfuncstr("GETCTRLFOCUSEDITEM",$s1);\n//説明:指定したコントロール中のフォーカスを得ている項目を返します。\n//\n//引数:\n//\t$s1:コントロール識別名\n//\t("" を指定すると直前に NEWCONTROL 関数 で追加した コントロールが対象になります)\n//返り値:項目を表\す文字列 （コントロールの種類によって返される値の意味が違います。 詳細はこちらを参照して下さい。）\n//フォーカスを得ている項目がない場合、またはエラーの場合は 空文字列を返します。\n//例:(同梱の dgdll.mac を参照して下さい)\n
GETFILENAME_dg=//田楽dllの機能を利用\n//GETFILENAME\n//使い方:$s = dllfuncstr("GETFILENAME",#n1,$s2,$s3,$s4);\n//説明:「ファイルを開く」コモンダイアログを表\示して、 ユーザーが選んだファイル名を返します。\n//引数:\n//\t#n1:オーナーウィンドウのウィンドウハンドル(または 0)\n//\t$s2:ダイアログのタイトル文字列(ex. "ファイルの参照")\n//\t$s3:初期フォルダ名(\\初期ファイル名)\n//\t"" または "." を指定すると現在のフォルダになります。\n//\tまた、現在のフォルダで初期ファイル名を指定したい時は ".\\初期ファイ\n//\tル名" として下さい。\n//\t$s4:「ファイルの種類」コンボボックスに追加するフィルタ文字列 （複数指定可。なければ "" を指定）\n//\t(一つの)フィルタ文字列の書式は以下の通りです。\n//\t\t  "explain(ext[;ext...])"\n//\t\t  explain:説明文\n//\t\t  ext:拡張子指定(例:"*.txt")\n//\t\t  (複数ある場合はセミコロンで区切って指定)\n//返り値:ダイアログで指定されたファイルのフルパス名が返ります。\n//ファイルが複数指定された場合は、 フォルダ名に続けてファイル名を "|\n//" で区切ったものが返ってきます ("dirname|file1|file2|..")。\n//キャンセルの場合は "" が返ります。\n//例:\n$selectfile = dllfuncstr("GETFILENAME",\n\t\t\t\thidemaruhandle(0),\n\t\t\t\t"ファイルを選択して下さい",\n\t\t\t\t"C:\\\\windows",\n\t\t\t\t"'実行ファイル(*.com;*.exe)' 'スクリーンセーバー(*.scr)'"\n\t\t\t);\nif ($selectfile != "") {\n\tmessage "選択されたファイルは " + $selectfile + " です";\n}\n
GETDIRNAME_dg=//田楽dllの機能を利用\n//GETDIRNAME\n//使い方:$s = dllfuncstr("GETDIRNAME",#n1,$s2,$s3);\n//説明:「フォルダの指定」コモンダイアログを表\示して、 ユーザーが選んだフォルダ名を返します。\n//なお、各フォルダは名前順にソ\ートされます (GETDIRNAMEEX() も同様)。\n//\n//引数:\n//\t#n1:オーナーウィンドウのウィンドウハンドル(または 0)\n//\t$s2:ダイアログのタイトル文字列(ex. "フォルダの参照")\n//\t$s3:初期フォルダ（＆ファイル）名("" ならカレントフォルダ)\n//返り値:ダイアログで指定されたフォルダ名が返ります。 キャンセルの場合は "" が返ります。\n//例:\n$selectdir = dllfuncstr("GETDIRNAME",\n\t\t\t\thidemaruhandle(0),\n\t\t\t\t"フォルダを選択して下さい",\n\t\t\t\t"C:\\\\windows"\n\t\t\t);\nif ($selectdir != "") {\n\tmessage "選択されたフォルダは " + $selectdir + " です";\n}\n
GETDIRNAMEEX_dg=//田楽dllの機能を利用\n//田楽DLLVer1.3x〜にて対応\n//GETDIRNAMEEX\n//使い方:$s = dllfuncstr("GETDIRNAMEEX",#n1,$s2,$s3,#n4);\n//説明:「フォルダの指定」コモンダイアログを表\示して、 ユーザーが選んだフォルダ名を返します。 GETDIRNAME 関数とは異なり、 フォルダの作成・名前の変更・削除ができるようになっています。\n//引数:\n//\t#n1:オーナーウィンドウのウィンドウハンドル(または 0)\n//\t$s2:ダイアログのタイトル文字列(ex. "フォルダの参照")\n//\t$s3:初期フォルダ（＆ファイル）名("" ならカレントフォルダ)\n//\t#n4:1 を指定するとフォルダ操作ができるようになります。\n//\t0 を指定するとフォルダ操作を禁止します。\n//返り値:ダイアログで指定されたフォルダ名が返ります。 キャンセルの場合は "" が返ります。\n//例:\n$selectdir = dllfuncstr("GETDIRNAMEEX",\n\t\t\t\thidemaruhandle(0),\n\t\t\t\t"フォルダを選択して下さい",\n\t\t\t\t"C:\\\\windows",\n\t\t\t\t1\n\t\t\t);\nif ($selectdir != "") {\n\tmessage "選択されたフォルダは " + $selectdir + " です";\n}\n
GETCOLOR_dg=//田楽dllの機能を利用\n//GETCOLOR\n//使い方:$s = dllfuncstr("GETCOLOR",#n1,$s2,$s3);\n//説明:「色の指定」コモンダイアログを表\示して、 ユーザーが選んだ色を RGB 値の文字列で返します。\n//引数:\n//\t#n1:オーナーウィンドウのウィンドウハンドル(または 0)\n//\t$s2:ダイアログのタイトル文字列(ex. "フォルダの参照")\n//\t$s3:初期色指定\n//\t(色指定については こちらを参照して下さい)\n//\t空白またはカンマで区切って(※)複数の色を 指定することができますが、 その場合最初の指定が初期選択色、 それ以降の指定はユーザー定義の色指定になります。\n//\t※\t(Ver.1.XX との互換性により) RGB 値による指定の場合に限り、 "#FF\n//\t0000#010101#F0F0F0" のように 連続して指定することもできます。\n//返り値:ダイアログで選択された色指定（＋ユーザー定義色）が RGB 値で返ります。 キャンセルの場合は "" が返ります。\n//例:\n$selectcolors = dllfuncstr("GETCOLOR",\n\t\t\t\t\thidemaruhandle(0),\n\t\t\t\t\t"色を選択して下さい",\n\t\t\t\t\t"white #0F0F0F #E0E0E0" // "white #0F0F0F#E0E0E0" もＯＫ\n\t\t\t\t);\n// $selectcolors == "#??????#0F0F0F#E0E0E0" (#?????? はユーザーが選んだ色)\nif ($selectcolors != "") {\n\tmessage "選択された色は " + leftstr($selectcolors,7) + " です";\n}\n
GETFONT_dg=//田楽dllの機能を利用\n//GETFONT\n//使い方:$s = dllfuncstr("GETFONT",#n1,$s2,$s3);\n//説明:「フォントの選択」コモンダイアログを表\示して、 ユーザーが選んだフォント名その他の属性を返します。\n//引数:\n//\t#n1:オーナーウィンドウのウィンドウハンドル(または 0)\n//\t$s2:ダイアログのタイトル文字列(ex. "フォルダの参照")\n//\t$s3:初期フォント名＆属性指定\n//\t$s3 （と返り値）の書式は以下の通りです。\n//\t\t  "face,size,color,attr"\n//\t\t  face:フォント名\n//\t\t  size:フォントサイズ (単位は pt)\n//\t\t  color:色指定 (こちらを参照して下さい)\n//\t\t  attr:属性指定 (以下の文字の組み合わせ)\n//\t\t  b ボールド体\n//\t\t  i イタリック体\n//\t\t  u 下線あり\n//\t\t  s 打ち消し線あり\n//\t\t  （例:"biu" …ボールド＆イタリック＆下線あり）\n//返り値:ダイアログで指定されたフォント指定が返ります。 キャンセルの場合は "" が返ります。\n//例:\n$selectfont = dllfuncstr("GETFONT",\n\t\t\t\t\thidemaruhandle(0),\n\t\t\t\t\t"フォントを選択して下さい",\n\t\t\t\t\t"ＭＳ Ｐゴシック,12,black,bi"\n\t\t\t\t);\nif ($selectfont != "") {\n\t$face = dllfuncstr("GETTOKEN",$selectfont,",");\n\t$size = dllfuncstr("GETTOKEN","",",");\n\t$color = dllfuncstr("GETTOKEN","",",");\n\t$attr = "(なし)";\n\tif (dllfunc("HASMORETOKENS")) {\n\t\t$$a = dllfuncstr("GETTOKEN","",",");\n\t\tif (strstr($$a,"b") != -1) $attr = "ボールド";\n\t\tif (strstr($$a,"i") != -1) {\n\t\t\tif (strlen($attr) > 0) $attr = $attr + ",";\n\t\t\t$attr = $attr + "イタリック";\n\t\t}\n\t\tif (strstr($$a,"u") != -1) {\n\t\t\tif (strlen($attr) > 0) $attr = $attr + ",";\n\t\t\t$attr = $attr + "下線あり";\n\t\t}\n\t\tif (strstr($$a,"s") != -1) {\n\t\t\tif (strlen($attr) > 0) $attr = $attr + ",";\n\t\t\t$attr = $attr + "打ち消し線あり";\n\t\t}\n\t}\n\tmessage "選択されたフォントは\\n" +\n\t\t\t"フォント名： " + $face + "\\n" +\n\t\t\t"サイズ： " + $size + " pt\\n" +\n\t\t\t"色： " + $color + "\\n" +\n\t\t\t"属性： " + $attr + "\\n" +\n\t\t\t"です";\n}\n
CLR_LOAD_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//CLR_LOAD\n//使い方:#n = dllfunc("CLR_LOAD", $s1);\n//説明:色の名前("black", "yellow", etc.)と RGB 値による色指定("#0000\n//00", "#FFFF00", etc.)の関連付けを定義した データファイルをロードします。\n//(データファイルの書式については こちらを参照して下さい)\n//引数:\n//\t$s1:データファイルのパス名\n//\t(存在しないファイル名を指定してこの関数を呼ぶと、 ＤＬＬが内部で管理しているテーブルを初期化します)\n//返り値:常に 1 を返します。\n//例:(省略)\n
CLR_SAVE_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//CLR_SAVE\n//使い方:#n = dllfunc("CLR_SAVE", $s1);\n//説明:ＤＬＬが保持している色指定テーブルの内容をファイルに保存します。\n//引数:\n//\t$s1:データファイルのパス名\n//返り値:常に 1 を返します。\n//例:(省略)\n
CLR_SETNAME_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//CLR_SETNAME\n//使い方:#n = dllfunc("CLR_SETNAME", $name, $rgb);\n//説明:ＤＬＬが保持している色指定テーブルに色名($name)とRGB値($rgb)の 対応を追加(または変更)します。\n//引数:\n//\t$name:色の名前("black", "yellow", etc.)\n//\t$rgb:色の RGB 値("#000000", "#FFFF00", etc.)\n//返り値:色指定テーブルの変更に成功した場合は 1、失敗した場合は 0 を返します。\n//例:\n#r = dllfunc("CLR_SETNAME", "purple", "#800080");\n// ... (省略)\n//\tテーブルに登録しておけば、他の関数で色指定を名前で行うことができる\n//\t#r = dllfunc("GETCOLOR", hidemaruhandle(0), "色の指定", "#800080");\n#r = dllfunc("GETCOLOR", hidemaruhandle(0), "色の指定", "purple");\n
CLR_GETNAME_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//CLR_GETNAME\n//使い方:$s = dllfuncstr("CLR_GETNAME", $rgb);\n//説明:ＤＬＬが保持している色指定テーブルから RGB 値が $rgb に一致する 全ての色名を返します。\n//引数:\n//\t$rgb:色の RGB 値("#000000", "#FFFF00", etc.)\n//返り値:$rgb に一致した色の名前\n//複数ある場合は色名をカンマで区切ったものが返ります。 また、一致するものがなければ "" が返ります。\n//例:\n// #r = dllfunc("CLR_SETNAME", "black", "#000000"); // 初期状態で登録済み\n#r = dllfunc("CLR_SETNAME", "kuro", "#000000");  // 同じRGB値を別名で登録\nmessage dllfuncstr("CLR_GETNAME", "#000000");\n// "black,kuro" と表\示される\n
CLR_GETRGB_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//CLR_GETRGB\n//使い方:$rgb = dllfuncstr("CLR_GETRGB", $name);\n//説明:ＤＬＬが保持している色指定テーブルから色名($name) に対応する \n//RGB 値を返します。\n//引数:\n//\t$name:色の名前("black", "yellow", etc.)\n//返り値:$name に対応する色の RGB 値("#000000", "#FFFF00", etc.)\n//名前に対応するものがなければ "" が返ります。\n//例:\n//\t色の名前に対応する RGB 値を表示\n$cname = input("色の名前を指定して下さい", "black");\nmessage "色の RGB 値 ＝ " + dllfuncstr("CLR_GETRGB", $cname);\n//色指定及びデータファイルの書式について\n//\t  田楽ＤＬＬの関数の中で（フォント等の）色を指定する時には、 以下の書式に従って RGB 値によって指定するか、 ＤＬＬが内部で保持している色名と RGB 値の対応テーブルに 登録されている名前によって指定します。\n//\t  RGB 値の書式：\n//\t\t\t#RRGGBB\n//\t\t\tここで、 RR, GG, BB は、各々の色の割合を 0 〜 255 の数値(を 16 進数で表したもの)で指定します。\n//\t  ＤＬＬが内部で保持しているテーブルに登録されている色名：\n//\t\t\t以下の表は(初期状態の)テーブルに登録されている色名と RGB 値の対応です。\n//\t\t\t色名\tRGB 値\t色\t\t色名\tRGB 値\t色\t\t色名\tRGB 値\t色\t\t色名\tRGB 値\t色\n//\t\t\tblack\t#000000 \t\t\twhite\t#FFFFFF \t\t\tred \t#FF0000 \t\t\tlime\t#00FF00\n//\t\t\tblue\t#0000FF \t\t\tfuchsia \t#FF00FF \t\t\tyellow\t#FFFF00 \t\t\taqua\t#00FFFF\n//\t\t\tnavy\t#000080 \t\t\tteal\t#008080 \t\t\tgreen\t#008000 \t\t\tmaroon\t#800000\n//\t\t\tpurple\t#800080 \t\t\tolive\t#808000 \t\t\tgray\t#808080 \t\t\tsilver\t#C0C0C0\n//\t\t\tなお、これらの色名以外をテーブルに登録したい場合は CLR_LOAD() や CLR_SETNAME() 等の関数で テーブルの内容を追加・変更して下さい。\n//\t  色名と RGB 値の対応テーブルの定義データファイルの書式：\n//\t\t\tCLR_LOAD()/CLR_SAVE() で扱うデータファイルの書式は以下の通りです (中身は INI ファイル)。\n//\t\t\t[RGBNames]\n//\t\t\tblack=#000000\n//\t\t\twhite=#FFFFFF\n//\t\t\tred=#FF0000\n//\t\t\t...\n//\t\t\t色名(左辺)と対応する RGB 値(右辺)を "=" でつなげます。\n
BRE_LOAD_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_LOAD\n//使い方:#n = dllfunc("BRE_LOAD", $s1);\n//説明:Babaさん作の Perl 互換正規表現ライブラリ BREGEXP.DLL を ロードします。\n//引数:\n//\t$s1:BREGEXP.DLL のパス名\n//\tフォルダを省略するか、空文字列を指定すると、 ＯＳ標準のDLL検索方法\n//\tにより BREGEXP.DLL を探します。\n//返り値:DLL のロードに成功した場合は 1、失敗した場合は 0 を返します。\n//例:\nif (!dllfunc("BRE_LOAD", "BREGEXP.DLL")) {\n\tmessage "BREGEXP.DLL が見つかりません";\n\tfreedll;\n\tendmacro;\n}\n// ...(省略)\n#r = dllfunc("BRE_FREE"); // 使い終わったら BRE_FREE() で開放\n
BRE_FREE_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_FREE\n//使い方:#n = dllfunc("BRE_FREE");\n//説明:BRE_LOAD() でロードした BREGEXP.DLL を アンロードします。\n//引数:\n//\t(なし)\n//返り値:DLL のアンロードに成功した場合は 1、失敗した場合は 0 を返します。\n//例:(BRE_LOAD() の例を参照して下さい)\n
BRE_VERSION_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_VERSION\n//使い方:$s = dllfuncstr("BRE_VERSION");\n//説明:ロードした BREGEXP.DLL のバージョン情報を返します。\n//引数:\n//\t(なし)\n//返り値:BREGEXP.DLL の BRegexpVersion() によって得られるバージョン情報文字列\n//例:(省略)\n
BRE_ERRORMSG_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_ERRORMSG\n//使い方:$s = dllfuncstr("BRE_ERRORMSG");\n//説明:BREGEXP DLL の最後に呼び出した関数のエラーメッセージを返します。\n//引数:\n//\t(なし)\n//返り値:BREGEXP.DLL の BMatch(), BSubst(), BTrans(), BSplit() の呼び出し時に 得られた最後のエラーメッセージ\n//例:\n$ret = dllfuncstr("BRE_MATCH", "/[0-9]+/", "abcdef");\nif ($ret == "") {\n\tmessage dllfuncstr("BRE_ERRORMSG"); // エラーの原因を表\示\n}\n// ...\n
BRE_MATCH_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_MATCH\n//使い方:$pos = dllfuncstr("BRE_MATCH", $ptn, $str);\n//説明:与えられた正規表\現パターンに一致する部分文字列の範囲を返します。\n//なお、パターン中の丸括弧に一致する部分は BRE_GETNEXT(), BRE_HASMOR\n//ERESULTS() で 取得することができます。\n//引数:\n//\t$ptn:正規表\現パターン文字列\n//\t$str:検索対象文字列\n//返り値:$str 中の $ptn にマッチした範囲を表\す文字列。\n//書式は以下の通り。\n//\t  head:len\n//\t  head:マッチした範囲の先頭位置(0 から数えます)\n//\t  len:マッチした範囲のバイト数\n//パターンに一致する部分がなかったときは "" を返します。\n//例:\n$str = "Yokohama 045-222-1111"; // この中から電話番号を抜き出す\n$pos = dllfuncstr("BRE_MATCH", "/0\\\\d{1,4}-\\\\d{1,4}-\\\\d{4}/", $str);\nif ($pos != "") {\n\t// 見つかったら番号を表\示\n\t##s = strstr($pos, ":");\n\t##head = val(leftstr($pos, ##s));\n\t##len  = val(midstr($pos, ##s + 1, strlen($pos)));\n\tmessage "電話番号：" + midstr($str, ##head, ##len);\n\t// 上の４行は以下の１行と等価\n//\tmessage "電話番号：" + dllfuncstr("BRE_POSTOSTR", $pos);\n}\n
BRE_SUBST_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_SUBST\n//使い方:$s = dllfuncstr("BRE_SUBST", $ptn, $str);\n//説明:与えられた正規表\現パターンに一致する部分文字列を パターン内で指定した別の文字列に置換します。\n//引数:\n//\t$ptn:正規表\現パターン文字列＋置換文字列\n//\t$str:置換対象文字列\n//返り値:置換結果の文字列\n//例:\n//\t$str を $ptn の指定に従って置換したものを出力します。\n$ptn = "s/(\\\\d\\\\d)-\\\\d{4}-\\\\d{4}/$1-xxxx-xxxx/g";\n$str = "Yokohama 045-222-1111  Osaka 06-5555-6666";\n$s = dllfuncstr("BRE_SUBST", $ptn, $str);\ninsert "result: " + $s + "\\n";\n//\t出力結果\n//\tresult: Yokohama 045-222-1111  Osaka 06-xxxx-xxxx\n
BRE_TRANS_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_TRANS\n//使い方:$s = dllfuncstr("BRE_TRANS", $ptn, $str);\n//説明:与えられたパターンの通りに文字を置換します。\n//引数:\n//\t$ptn:置換パターン文字列\n//\t$str:置換対象文字列\n//返り値:置換結果の文字列\n//例:\n//\t$str を $ptn の指定に従って置換したものを出力します。\n$ptn = "tr/A-Z0-9/a-zx/g"; // アルファベットを小文字に、数字を x に置換\n$str = "Yokohama 045-222-1111  Osaka 06-5555-6666";\n$s = dllfuncstr("BRE_TRANS", $ptn, $str);\ninsert "result: " + $s + "\\n";\n//\t出力結果\n//\tresult: yokohama xxx-xxx-xxxx  osaka xx-xxxx-xxxx\n
BRE_SPLIT_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_SPLIT\n//使い方:#n = dllfunc("BRE_SPLIT", $ptn, $str, #lim);\n//説明:与えられた正規表\現パターンを区切り文字列として文字列を分割します。\n//なお、区切られた部分文字列は BRE_GETNEXT(), BRE_HASMORERESULTS() 等で取得することができます。\n//引数:\n//\t$ptn:置換パターン文字列\n//\t$str:置換対象文字列\n//\t#lim:分割の最大数(0 を指定すると無制限に分割)\n//返り値:分割された数\n//何らかのエラーが起こった場合は -1 が返ります。\n//例:\n//\t$str を $ptn にマッチする文字列を区切り文字列として分割します。\n$ptn = "/[ \\t]*/"; // 空白またはタブで区切る\n$str = "Yokohama 045-222-1111  Osaka 06-5555-6666";\n#n = dllfunc("BRE_SPLIT", $ptn, $str, 0);\nwhile (dllfunc("BRE_HASMORERESULTS")) {\n\t$$p = dllfuncstr("BRE_GETNEXT");\n\tif ($$p == "") break;\n\t$s = dllfuncstr("BRE_POSTOSTR", $$p);\n\tinsert " split content: " + $s + "\\n";\n}\n//\t出力結果\n//\tsplit content: Yokohama\n//\tsplit content: 045-222-1111\n//\tsplit content: Osaka\n//\tsplit content: 06-5555-6666\n
BRE_GETNEXT_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_GETNEXT\n//使い方:$pos = dllfuncstr("BRE_GETNEXT");\n//説明:BRE_MATCH(), BRE_SPLIT() で得られた結果(範囲)を順に取得します。\n//引数:\n//\t(なし)\n//返り値:直前の BRE_MATCH(), BRE_SPLIT() の呼び出し時に渡した 文字列内の範囲 (書式は BRE_MATCH() を参照して下さい)\n//返すものがなくなったら以後は "" を返します。\n//例:\n$$p = dllfuncstr("BRE_MATCH",\n\t\t\t\t "/(\\\\d{1,4})-(\\\\d{1,4})-(\\\\d{4})/",\n\t\t\t\t "03-765-5678");\nif (dllfunc("BRE_HASMORERESULTS")) {\n\t$$p = dllfuncstr("BRE_GETNEXT");\n\tinsert "市外局番：" + dllfuncstr("BRE_POSTOSTR", $$p) + "\\n";\n}\nif (dllfunc("BRE_HASMORERESULTS")) {\n\t$$p = dllfuncstr("BRE_GETNEXT");\n\tinsert "局番：" + dllfuncstr("BRE_POSTOSTR", $$p) + "\\n";\n}\nif (dllfunc("BRE_HASMORERESULTS")) {\n\t$$p = dllfuncstr("BRE_GETNEXT");\n\tinsert "番号：" + dllfuncstr("BRE_POSTOSTR", $$p) + "\\n";\n}\n//\t出力結果\n//\t市外局番：03\n//\t局番：765\n//\t番号：5678\n
BRE_POSTOSTR_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_POSTOSTR\n//使い方:$s = dllfuncstr("BRE_POSTOSTR", $pos);\n//説明:BRE_MATCH(), BRE_GETNEXT() で返された範囲の文字列を返します。\n//\n//引数:\n//\t$pos:直前の BRE_MATCH(), BRE_GETNEXT() の戻り値\n//返り値:BRE_MATCH(), BRE_SPLIT() の呼び出し時に渡した文字列中の $po\n//s の範囲にある文字列\n//例:(BRE_SPLIT(), BRE_GETNEXT() の例を参照して下さい)\n
BRE_HASMORERESULTS_dg=//田楽dllの機能を利用\n//田楽DLLVer2.0x〜にて対応\n//BRE_HASMORERESULTS\n//使い方:#n = dllfunc("BRE_HASMORERESULTS");\n//説明:BRE_GETNEXT() の呼び出しが まだ成功するかどうかを返します。\n//引数:\n//\t(なし)\n//返り値:BRE_GETNEXT() によってまだ範囲情報が取得できる場合は 0 でない値、 そうでなければ 0 を返します。\n//例:(BRE_SPLIT(), BRE_GETNEXT() の例を参照して下さい)\n
